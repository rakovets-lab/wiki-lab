= Docker
:imagesdir: ../assets/img/common/docker

*Docker* - это сервис для запуска приложений в контейнерах. Другими словами, *Docker* - это инструмент, который использует контейнеры для упрощения создания, развертывания и запуска приложений. Он связывает приложение и его зависимости внутри контейнера. При этом *Docker* можно использовать как в процессе разработки приложений, так и для запуска приложений в продакшене.

Основные характеристики *Docker*:

* Приложения запускаются в изолированной среде. Контейнер, в котором запускается приложение изолирован от других контейнеров и от хоста где он запускается.
* Легко запускать приложения на разных серверах и они будут работать абсолютно везде одинаково.
* Все зависимости, которые необходимы приложению устанавливаются внутри контейнеров, поэтому нет необходимости устанавливать их вне контейнеров на самих серверах, где эти контейнеры запускаются.
* Приложения, запущенные в контейнерах легко горизонтально масштабировать путем увеличения количества этих контейнеров.
* Очень удобно использовать в процессе разработки приложений, так как не нужно устанавливать дополнительные зависимости внутри контейнеров.

== Отличие Docker от виртуальной машины

*Виртуальная машина* (*virtual machine*)- это система, которая действует точно так же, как и компьютер. *VM* позволяют запускать операционную систему в приложении, которое ведет себя как полноценный отдельный компьютер.

image:docker-vs-vm.png[]

=== Поддержка операционной системы

Поддержка операционной системы *VM* и *контейнеры* сильно отличается. Каждая *VM* имеет свою *гостевую операционную систему* над основной операционной системой, что делает *VM* тяжелыми. С другой стороны, *контейнеры* используют общую операционную систему хоста, и поэтому они легковесны.

Совместное использование операционной системы хоста между *контейнеры* делает их очень легкими и помогает им загружаться всего за несколько секунд. Следовательно, накладные расходы на управление контейнерной системой очень низкие по сравнению с *VM*.

*Контейнеры* подходят для ситуаций, когда вы хотите запустить несколько приложений в одном ядре операционной системы. Но если у вас есть приложения или серверы, которые должны работать в разных версиях операционной системы, тогда требуются *VM*.

=== Безопасность

*VM* не имеет общей операционной системы, и в ядре хоста существует сильная изоляция. Следовательно, они более *безопасны* по сравнению с контейнерами. *Контейнер* имеет много угроз безопасности и уязвимостей, поскольку *контейнеры* имеют общее ядро хоста.

Кроме того, поскольку ресурсы *Docker* являются общими и не имеют пространства имен, злоумышленник может использовать все контейнеры в кластере, если он получает доступ даже к одному контейнеру. В *VM* вы не получаете прямого доступа к ресурсам, а гипервизор предназначен для ограничения использования ресурсов в виртуальной машине.

=== Портативность

*Контейнеры* легко переносимы, поскольку у них нет отдельных операционных систем. *Контейнер* может быть перенесен на другую *ОС*, и он может запуститься немедленно. С другой стороны, *VM* имеют отдельную *ОС*, поэтому портирование *VM* затруднено по сравнению с *контейнерами*, а также требуется много времени для портирования *VM* из-за ее размера. Для целей разработки, где приложения должны разрабатываться и тестироваться на разных платформах, *контейнеры* являются идеальным выбором.

=== Производительность

Сравнение *VM* и контейнеров было бы несправедливым, поскольку они оба используются для разных целей. Но легкая архитектура *контейнеров* и его менее ресурсоемкая функция делают его лучшим выбором, чем *VM*. В результате *контейнеры* могут запускаться очень быстро по сравнению с *VM*, а использование ресурсов варьируется в зависимости от нагрузки или трафика в нем.

В отличие от *VM*, нет необходимости постоянно выделять ресурсы для *контейнеров*. Масштабирование и дублирование *контейнеров* также является простой задачей по сравнению с *VM*, поскольку в них нет необходимости устанавливать операционную систему.

[options="header"]
|===
|Virtual machine|Контейнер
|Изоляция процесса на аппаратном уровне|Изоляция процесса на уровне ОС
|Каждая *VM* имеет отдельную ОС|Каждый *контейнер* может совместно использовать ОС
|Загружается в считанные минуты|Загружается в считанные секунды
|*VM* занимают несколько ГБ|*Контейнеры* легкие (КБ / МБ)
|Готовые *VM* трудно найти|Готовые контейнеры легко доступны
|*VM* могут легко перейти на новый хост|*Контейнеры* уничтожаются и воссоздаются, а не перемещаются
|Создание *VM* занимает относительно больше времени|*Контейнеры* могут быть созданы в считанные секунды
|Больше использования ресурса|Меньшее использование ресурсов
|===

== Компоненты Docker

В *Docker* имеются следующие компоненты:

* *Client* (*клиент*) - запускается в командной строке и с помощью клиента можно подключаться к службе *Docker*, причем как локальной, так и удаленной.
* *Daemon* *(служба)* - *Docker*-сервер, который отвечает за все задачи по созданию контейнеров и по обработке запросов от клиентов.
* *Host* *(хост)* - компьютер, где запущен *Docker*.

С помощью клиента происходит взаимодействие со службой *Docker*, а служба *Docker* запущена на каком-то хосте/компьютере.

* *Container* *(контейнер)* - это самый маленький элемент в *Docker*, где запускаются приложения. Обычно одно приложение - один контейнер.
* *Image* (*образ*) - основа для создания контейнеров.

Причем с одного образа можно создавать любое множество контейнеров, и они будут все независимые друг от друга, но образ будет один и тот же.

* *Repository* (*репозиторий*) - хранятся различные версии образов.
* *Registry* (*реестр*) - находятся различные репозитории.

Реестр может быть как локальный, так и удаленный. Самый популярный удаленный реестр - *Docker Hub*

=== Image

*Образ* - это набор файлов, образ статичен. С образа создаются контейнеры. Контейнер отличается от образа тем, что в контейнере есть запущенные процессы, которые выполняют задачи. Но информация о процессах, которые запустятся в контейнерах, находится в образе.

image:image.png[]

Образы можно скачивать из удаленных репозиториев, и после скачивания он будет находиться в кеше *Docker*.

Каждый образ состоит из слоев. Каждый слой это набор файлов. У каждого образа есть базовый слой и другие слои, которые добавляются к базовому слою. Такая структура построения образа была создана для того, чтобы переиспользовать слои в разных образах, что позволяет не хранить копии. *Docker* в процессе создания контейнера будет собирать его из разных слоев, которые указаны определенном в образе. Также переиспользование слоев позволяет ускорить процесс создания кастомных образов.

image:layers-image.png[]

Характеристика образов:

* Стоит понимать, что все слои в образе доступны только для чтения (*read-only*), то есть образ создан и слои соответствующие созданы в них нельзя вносить изменения.
* Образы можно перемещать и удалять.
* Образы хранятся в репозиториях.

Можно создавать свои собственные образы или использовать только те, которые созданы другими и опубликованы в реестре. Чтобы создать собственный образ, необходимо создать файл `Dockerfile` — без расширения, с простым синтаксисом для определения шагов, необходимых для создания образа и его запуска. Каждая инструкция в `Dockerfile` создает слой в образе. При изменении `Dockerfile` и перестроении образа перестраиваются только те слои, которые изменились. Это часть того, что делает образы такими легкими, маленькими и быстрыми по сравнению с другими технологиями виртуализации.

=== Repository

*Репозиторий* - это набор различных версий какого-то образа. У каждой версии конкретного образа могут быть различное теги.

image:repository.png[]

Характеристика репозиториев:

* В репозиториях хранятся *разные версии* образа.
* Разные версии помечаются разными *тегами*.
* Одна версия образа может иметь *несколько* тегов.

Репозиторий можно сохранять локально, либо в любой удаленный реестр репозиториев.

== Рабочий процесс в Docker

Как говорилось ранее, контейнеры создаются из образов, причем с одного образа можно запустить любое количество контейнеров.

Контейнеры запускаются в *Linux*-системах. У любой *Linux*-системы имеется ядро (*Linux Kernel*), оперативная память (*RAM*), процессор (*CPU*), сеть (*Network*) и жесткий диск (*Disk*). Для того чтобы запустить контейнер необходим *Docker Engine*, который запускает *docker*-сервер.

image:docker-host.png[]

При запуске контейнера на диске для него создадутся файлы, которые будут доступны только этому контейнеру. Далее у контейнера запускается определенный процесс. И когда процесс в контейнере останавливается, контейнер тоже останавливается. При этом, если будет запущено несколько контейнеров все они будут использовать одни и те же ресурсы системы (*ядро*, *RAM*, *CPU*, *Disk*), но у каждого контейнера будет свое изолированное место на жестком диске, где будут храниться его файлы.

Также стоит упомянуть, что если создаются контейнеры с одного и того же образа, то у этих контейнеров будут определенные общие файлы, причем эти файлы будут только в одном месте для всех контейнеров.

После остановки контейнера, на диске удаляются все файлы, связанные с этим контейнером. *Docker* также автоматически останавливает контейнеры, в которых нет активных процессов.

== Команды Docker

=== Команды Docker для управления образами

Для управления образами используются команды, которые выглядят так: `docker image *my_command*`.

Команды, которые могут быть подставлены вместо *my_command*:

* `build` — собирает образ с нуля.
* `push` — отправляет образ в реестр.
* `pull` — загружает готовый образ с необходимыми для работы параметрами.
* `ls` — показывает все существующие образы.
* `history` — показывает каждый слой образа в ретроспективе, отображая ряд полезных сведений.
* `inspect` — рассказывает все, что известно об образе, включая данные, касающиеся отдельных слоев.
* `rm` — удаляет образ Docker из системы.
* `images` — списком показывает все образы *Docker*, найденные на диске.

=== Создание образа

`Dockerfile` — это обычный конфигурационный файл, описывающий пошаговое создание среды вашего приложения. В этом файле подробно описывается инструкции по созданию образа, причем этих инструкций может быть несколько. Инструкции, при сборке образа, обрабатываются сверху вниз. Также описываются какие команды будут выполнены, какие образы задействованы, и какие настройки будут применены. При создании образа можно указать имя и тег для образа.

Чтобы создать собственный образ, необходимо создать файл с названием `Dockerfile` без разрешения. Обычно `Dockerfile` помещают в корне папки приложения.

Вот как выглядит `Dockerfile`:

[source,dockerfile]
----
FROM openjdk:11-jre
EXPOSE 8080 5005
ARG JAR_FILE=target/project_name-0.0.1-SNAPSHOT.jar
ADD ${JAR_FILE} app.jar
ENV JAVA_TOOL_OPTIONS -agentlib:jdwp=transport=dt_socket,address=*:5005,server=y,suspend=n
COPY ./cacerts /usr/local/openjdk-11/lib/security/cacerts
ENTRYPOINT ["java","-jar","/app.jar"]
----

Список инструкций `Dockerfile`:

* `FROM` — задаёт базовый (родительский) образ.
* `LABEL` — описывает метаданные. Например — сведения о том, кто создал и поддерживает образ.
* `ENV` — устанавливает постоянные переменные среды.
* `RUN` — выполняет команду и создаёт слой образа. Используется для установки в контейнер пакетов.
* `COPY` — копирует в контейнер файлы и папки.
* `ADD` — копирует файлы и папки в контейнер, может распаковывать локальные `.tar`-файлы.
* `CMD` — описывает команду с аргументами, которую нужно выполнить, когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция `CMD`.
* `WORKDIR` — задаёт рабочую директорию для следующей инструкции.
* `ARG` — задаёт переменные для передачи Docker во время сборки образа.
* `ENTRYPOINT` — предоставляет команду с аргументами для вызова во время выполнения контейнера. Аргументы не переопределяются.
* `EXPOSE` — указывает на необходимость открыть порт.
* `VOLUME` — создаёт точку монтирования для работы с постоянным хранилищем.

Слои в итоговом образе создают только инструкции `FROM`, `RUN`, `COPY`, и `ADD`. Другие инструкции что-то настраивают, описывают метаданные, или сообщают *Docker* о том, что во время выполнения контейнера нужно что-то сделать, например — открыть какой-то порт или выполнить какую-то команду.

Чтобы собрать образ, нужно ввести команду `docker build [OPTIONS] PATH | URL | -`.

* `docker build .` - где `.` означает, что `Dockerfile` будет находиться в рутовой директории.

Если же `Dockerfile` файл лежит в другом месте или же он имеет другое имя, то нужно использовать флаг `-f` (`--file`):

* `docker build -f Dockerfile.debug .` - данная команда указывает, что вместо `Dockerfile` будет использоваться `Dockerfile.debug`.
* `docker build -f ctx/Dockerfile` - данная команда указывает относительный путь согласно рутовой директории, где будет находиться `Dockerfile`.

Чтобы указать название и тег образа, нужно использовать флаг `-t` (`--tag`)

* `docker build -t myname:2.0 .` - данная команда указывает, что у образа будет название `myname`, а версия `2.0`.

=== Команды для управления контейнерами

Общая схема команд для управления контейнерами выглядит так: `docker container *my_command*`

Команды, которые могут быть подставлены вместо *my_command*:

* `create` — создание контейнера из образа.
* `start` — запуск существующего контейнера.
* `run` — создание контейнера и его запуск.
* `ls` — вывод списка работающих контейнеров.
* `inspect` — вывод подробной информации о контейнере.
* `logs` — вывод логов.
* `stop` — остановка работающего контейнера с отправкой главному процессу контейнера сигнала *SIGTERM*, и, через некоторое время, *SIGKILL*.
* `kill` — остановка работающего контейнера с отправкой главному процессу контейнера сигнала *SIGKILL*.
* `rm` — удаление остановленного контейнера.

По-мимо вышеуказанных команд существуют следующие:

* `docker ps` / `docker container ls`- показывает список запущенных контейнеров.

Также, эту команду можно использовать с флагом `-a`:

* `docker ps -a` / `docker container ls -a` -где флаг `-a` (--all) показывает список запущенных и остановленных контейнеров.

=== Запуск контейнера

Чтобы запустить контейнер, нужно ввести команду

* `docker run name_image` - создает и запускает контейнер. Сначала *Docker* ищет данный образ локально, если не находит - идет в *Docker Hub*

Запуск контейнера и вход внутрь его:

* `docker run -it image_name bash` - позволяет войти внутрь контейнера, где флаг `-i` (`--interactive`) - подключается к *STDIN*, `-t` (`--tty`) - запускает псевдотерминал.

Запуск контейнера в фоновом режиме:

* `docker run -d name_image` - создает и запускает контейнер в фоновом режиме. По умолчанию, без флага `-d` (`--detach`) после запуска контейнера, происходит переход к *STDOUT*.

Запуск дополнительного процесса внутри запущенного контейнера:

* `docker exec -it name_container bash` - запускает дополнительный процесс в уже запущенном контейнере, где `bash` - название процесса, `-it` - опция подключения интерактивного терминала.

Установка своего имени контейнеру:

* `docker run --name custom_name name_image` - где флаг `--name` дает имя для контейнера.

Проброс портов:

* `docker run -d -p 8080:80 name_image` - где флаг `-p` (`--publish`) открывает порт на хосте 8080 (внешний порт) и пробрасывает его внутри контейнера 80 (порт контейнера).

Маппинг томов

* `docker run -d -v ${PWD}:/usr/share/nginx/html name_image` - где флаг `-v` (`--volume`) подключает том, `${PWD}` - путь к локальной папке, `/usr/share/nginx/html name_image` - пусть в папке внутри контейнера.

Удаление контейнера сразу после остановки

* `docker run -d --rm name_image` - где флаг `--rm` указывает, что контейнер будет удален после остановки.

=== Сбор логов

Логи получает командой `docker logs [OPTIONS] CONTAINER`.

Команду `docker logs` можно использовать со следующими флагами:

* `--details` - Отображение дополнительных сведений, предоставленных журналам.
* `--follow`, `-f` - Отслеживание выходных данных журнала.
* `--since` - Отображение журналов с отметки времени.
* `--tail,` `-n` - Количество строк, отображаемых с конца журналов.
* `--timestamps,` `-t` - Показать метки времени.
* `--until` - Отображение журналов перед меткой времени.

Для просмотра логов необходима команда:

`docker logs name_container` - означает что будет выведена информация из *STDOUT* и *STDERR* имеющая только до текущего периода времени.

Для того, следовать за журналом вывода логов, необходима команда:

`docker logs -f name_container` - где флаг `-f` (`--follow`) означает, что будет показана вся информация из *STDOUT* и *STDERR*, и плюс будут выводиться сообщения, которые еще будут получены.

=== Хранение данных в Docker.

Одна из главных особенностей *контейнеров* — эфемерность. Это означает, что контейнеры могут быть в любой момент остановлены, перезапущены или уничтожены. При этом все накопленные данные в контейнере будут потеряны. Поэтому приложения нужно разрабатывать так, чтобы они не полагались на хранилище данных в контейнере, это называется принципом *Stateless*.

Данные в *Docker* могут храниться либо временно, либо постоянно.

По умолчанию файлы, создаваемые приложением, работающим в контейнере, сохраняются в слое контейнера, поддерживающем запись.

Для сохранения данных в контейнерах предусмотрены несколько способов:

* Тома хранения данных (*Docker  volumes*) - это способ, при котором *Docker* сам создает директории для хранения данных. Их можно сделать доступными для разных контейнеров, чтобы они могли обмениваться данными. По умолчанию эти директории создаются на хост-машине, но можно использовать и удаленные хранилища: файловый сервер или объектное хранилище. Другими словами, тома служат для того, чтобы связать физическую папку хоста с папкой контейнера.
* Монтирование каталогов с хоста (*bind mount*) - в этом случае директория сначала создается в хост-системе, а уже потом монтируется в *Docker* контейнеры. Но этот способ не рекомендуется, потому что он усложняет резервное копирование, миграцию и совместное использование данных несколькими контейнерами.
* Монтирование *tmpfs* (только в *Linux*) - Временное файловое хранилище. Это некая специально отведённая область в оперативной памяти компьютера.*Tmpfs* нужно не для сохранения данных, а для безопасности, полученные в ходе работы приложения чувствительные данные безвозвратно исчезнут после завершения работы контейнера. Бонусом использования будет высокая скорость доступа к информации.

image:data.png[]

Ключ командной строки для *Docker* при работе с томами:

* `--volume` (`-v`)
* `--mount`
* `--tmpfs`

Например:

* `docker container run --mount source=my_volume, target=/container/path/for/volume my_image`

Однако это не всегда удобно создавать тома с командой `run`. Поэтому существует команда

* `docker volume create --name volume-name`

Помимо `create` имеются и другие:

* `create` - Создать том
* `inspect` - Отобразить детальную информацию
* `ls` - Вывести список томов
* `prune` - Удалить все неиспользуемые тома
* `rm` - Удалить один или несколько томов

Надо отметить, что при использовании флага `--mount` увеличивается объём дополнительных данных, которые приходится указывать в команде, но, по нескольким причинам, лучше использовать именно этот флаг, а не `--volume`. Флаг `--mount` — это единственный механизм, который позволяет работать с сервисами или указывать параметры драйвера тома. Кроме того, работать с этим флагом проще. Учитывайте то, что флаги `--mount` и `--volume` используют различные форматы параметров.

Главное различие между `--mount` и `--volume` заключается в том, что при использовании флага `--volume` все параметры собирают вместе, в одном поле, а при использовании `--mount` параметры разделяются.

При работе с `--mount` параметры представлены как пары вида ключ-значение, а именно, это выглядит как `key=value`. Эти пары разделяют запятыми. Вот часто используемые параметры `--mount`:

* `type` — тип монтирования. Значением для соответствующего ключа могут выступать bind, volume или `tmpfs`. Мы тут говорим о томах, то есть — нас интересует значение volume.
* `source` — источник монтирования. Для именованных томов это — имя тома. Для неименованных томов этот ключ не указывают. Он может быть сокращён до src.
* `destination` — путь, к которому файл или папка монтируется в контейнере. Этот ключ может быть сокращён до dst или target.
* `readonly` — монтирует том, который предназначен только для чтения. Использовать этот ключ необязательно, значение ему не назначают.

Пример использования `--mount` с множеством параметров:

* `docker run --mount type=volume,source=volume_name,destination=/path/in/container,readonly my_image`

== Docker Compose

*Docker Compose* - инструмент для определения и запуска много-контейнерных приложений. Когда имеется большое количество образов, которые нужно запустить, *Docker Compose* позволяет это сделать всего одной командой, и точно также все эти контейнеры остановить.

*Docker* применяется для управления отдельными контейнерами (сервисами), из которых состоит приложение. *Docker Compose* используется для одновременного управления несколькими контейнерами, входящими в состав приложения. Этот инструмент предлагает те же возможности, что и *Docker*, но позволяет работать с более сложными приложениями.

В основе лежит файл `docker-compose.yml`, расположенный в корневой папке проекта.

Файл содержит следующие секции:

* `version` — версия формата конфигурационного файла, скоро этот элемент должны исключить;
* `services` — список контейнеров, которые нужно запустить в изолированной среде, это обязательный элемент;
* `networks` — подсети Docker Network, которые объединяют группы контейнеров в локальную сеть, доступную из внешнего мира;
* `volumes` — список томов, которыми будут пользоваться контейнеры, указанные в файле конфигурации;
* `configs` — параметры, позволяющие запускать контейнеры в разных режимах без необходимости собирать их заново;
* `secrets` — чувствительные с точки зрения безопасности параметры, по сути, то же, что и `configs`, но специального назначения.

[source,yaml]
----
version: '3.7'

services:
  frontend:
    image: awesome/webapp
    ports:
      - "443:8043"
    networks:
      - front-tier
      - back-tier
    configs:
      - httpd-config
    secrets:
      - server-certificate

  db:
    image: postgres

  backend:
    image: awesome/database
    volumes:
      - db-data:/etc/data
    networks:
      - back-tier
    depends_on:
      - db

volumes:
  db-data:
    driver: flocker
    driver_opts:
      size: "10GiB"

configs:
  httpd-config:
    external: true

secrets:
  server-certificate:
    external: true

networks:
  front-tier: {}
  back-tier: {}
----

Файл `docker-compose.yaml` должен начинаться с тега `version`. Далее идет секция `services`. Следует учитывать, что *Docker Compose* работает с сервисами. `1 сервис = 1 контейнер`. Сервисом может быть клиент, сервер, сервер баз данных и т.д.

Краткое описание некоторых полей:

* `container_name` - Определяет имя контейнера. Эквивалент `--name` опции.
* `image` - Определяет, какое изображение извлекать из контейнера.
* `restart` - Определяет политику перезапуска для контейнера. Эквивалентно `--restart`.
* `networks` - Определяет сеть, к которой подключается контейнер. Эта сеть может быть создана, а может уже существовать. Это значение служит идентификатором *docker-compose*, а не фактическим именем сети (которое определено в разделе `networks` тегов).
* `ports` - Определяет порты хоста, к которым может подключаться контейнер. Эквивалентно `--publish`.
* `volumes` - Определяет объемы для контейнера. Эквивалентно `--volume`.
* `environment` - Определяет переменные среды для контейнера. Эквивалентно `--env`. Эта опция поддерживает два типа синтаксиса. Первый — `variable: value` это то, что используется здесь. Другой вариант, который может быть более знакомым, если вы привыкли к синтаксису *Docker CLI*, — это - `variable=value`.
* `depends_on` - Задает зависимости контейнера. Это используется, чтобы потребовать, чтобы контейнер не запускался до тех пор, пока не будут установлены его зависимости. Это принимает значения из списков контейнеров.

При работе с *Docker Compose* можно выделить следующие команды:

`build` - Сборка или перестроение сервисов
`create` - Создает сервисы
`down` - Останавливает и удаляет контейнеры, сети, образы и тома
`pause` - Приостанавливает сервисы
`restart`  Перезапускает сервисы
`start` - Запускает сервисы
`stop` - Останавливает сервисы
`unpause` - Восстановить сервисы
`up` - Создает и запускает контейнеры
`version` - Показывает информацию о версии *Docker Compose*

* `docker-compose up -d` - запускает все контейнеры в фоновом режиме, которые описаны в секции сервисы.
* `docker-compose down` - останавливает все запущение контейнеры

== Оркестрация

*Контейнеры* — отличный способ связать и запустить ваши приложения. В производственной среде необходимо управлять контейнерами, которые запускают приложения, и гарантировать отсутствие простоев. Например, если контейнер выходит из строя, необходимо запустить другой контейнер.

Для обеспечения балансировки нагрузки, масштабируемости и повышения отказоустойчивости могут использоваться вспомогательные средства — *оркестраторы*.

Оркестрация позволяет создавать информационные системы из множества контейнеров, каждый из которых отвечает только за одну определенную задачу, а общение осуществляется через сетевые порты и общие каталоги. При необходимости каждый такой контейнер можно заменить другим, что позволяет, например, быстро перейти на другую версию базы данных при необходимости.

*Оркестрация контейнеров* решает проблему за счет автоматизации планирования, развертывания, масштабируемости, балансировки нагрузки, доступности и организации сетей контейнеров. Оркестрация контейнеров - это автоматизация и управление жизненным циклом контейнеров и услуг.

Можно выделить следующие системы оркестрации:

* *Kubernetes/k8s*
* *OpenShift*
* *Docker Swarm*
* *Apache Mesos*

*Kubernetes* предоставляет:

* *Мониторинг сервисов и распределение нагрузки*. *Kubernetes* может обнаружить контейнер, используя имя *DNS* или собственный *IP*-адрес. Если трафик в контейнере высокий, *Kubernetes* может сбалансировать нагрузку и распределить сетевой трафик, чтобы развертывание было стабильным.
* *Оркестрация хранилища*. *Kubernetes* позволяет вам автоматически смонтировать систему хранения по вашему выбору, такую как локальное хранилище, провайдеры общедоступного облака и многое другое.
* *Автоматическое развертывание и откаты*. Используя *Kubernetes* можно описать желаемое состояние развернутых контейнеров и изменить фактическое состояние на желаемое. Например, вы можете автоматизировать *Kubernetes* на создание новых контейнеров для развертывания, удаления существующих контейнеров и распределения всех их ресурсов в новый контейнер.
* *Автоматическое распределение нагрузки* Вы предоставляете *Kubernetes* кластер узлов, который он может использовать для запуска контейнерных задач. Вы указываете *Kubernetes*, сколько ЦП и памяти (ОЗУ) требуется каждому контейнеру. *Kubernetes* может разместить контейнеры на ваших узлах так, чтобы наиболее эффективно использовать ресурсы.
* *Самоконтроль*. *Kubernetes* перезапускает отказавшие контейнеры, заменяет и завершает работу контейнеров, которые не проходят определенную пользователем проверку работоспособности, и не показывает их клиентам, пока они не будут готовы к обслуживанию.
* *Управление конфиденциальной информацией и конфигурацией*. *Kubernetes* может хранить и управлять конфиденциальной информацией, такой как пароли, *OAuth*-токены и ключи *SSH*. Вы можете развертывать и обновлять конфиденциальную информацию и конфигурацию приложения без изменений образов контейнеров и не раскрывая конфиденциальную информацию в конфигурации стека

== Links

* link:https://docs.docker.com/get-started/overview/[Официальная документация]
* link:https://habr.com/ru/post/310460/[Полное практическое руководство по Docker: с нуля до кластера на AWS]
* link:https://wiki.merionet.ru/servernye-resheniya/35/chem-docker-on-otlichaetsya-ot-virtualnoj-mashiny/[ЧЕМ DOCKER ОТЛИЧАЕТСЯ ОТ ВИРТУАЛЬНОЙ МАШИНЫ?]
* link:https://timeweb.com/ru/community/articles/osnovnye-komandy-docker[Основные команды Docker]
* link:https://habr.com/ru/company/flant/blog/336654/[Шпаргалка с командами Docker]
* link:https://gist.github.com/wtw24/66265a5707d5febd7ed51f570db94157[Шпаргалка с командами Docker]
* link:https://habr.com/ru/company/ruvds/blog/450312/[Руководство по Docker Compose для начинающих]
* link:https://www.youtube.com/watch?v=_uZQtRyF6Eg&t=96s&ab_channel=BogdanStashchuk[YouTube: Docker - Полный курс Docker Для Начинающих [3 ЧАСА]]

