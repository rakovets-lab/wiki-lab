= Servlet API

== Servlet Filter

Сервлетный фильтр, в соответствии со спецификацией, это Java-код, пригодный для повторного использования и позволяющий преобразовать содержание HTTP-запросов, HTTP-ответов и информацию, содержащуюся в заголовках HTML.
Сервлетный фильтр занимается предварительной обработкой запроса, прежде чем тот попадает в сервлет, и/или последующей обработкой ответа, исходящего из сервлета.

Сервлетные фильтры могут :

* перехватывать инициацию сервлета прежде, чем сервлет будет инициирован;
* определить содержание запроса прежде, чем сервлет будет инициирован;
* модифицировать заголовки и данные запроса, в которые упаковывается поступающий запрос;
* модифицировать заголовки и данные ответа, в которые упаковывается получаемый ответ;
* перехватывать инициацию сервлета после обращения к сервлету.

=== Интерфейс `javax.servlet.Filter`

Сервлетный фильтр может быть сконфигурирован так, что он будет работать с одним сервлетом или группой сервлетов.
Основой для формирования фильтров служит интерфейс javax.servlet.Filter, который реализует три метода :

* `void init (FilterConfig config) throws ServletException`
* `void destroy()`
* `void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException`

Метод `init` вызывается прежде, чем фильтр начинает работать, и определяет конфигурационные параметры фильтра.
Метод `doFilter` выполняет непосредственно работу фильтра.
Таким образом, сервер вызывает `init` один раз, чтобы запустить фильтр в работу, а затем вызывает `doFilter` столько раз, сколько запросов будет сделано непосредственно к данному фильтру.
После того, как фильтр заканчивает свою работу, вызывается метод `destroy`.

[source,java]
----
package common;

import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class FilterConnect implements Filter
{
    private FilterConfig config = null;
    private boolean active = false;

    public void init (FilterConfig config) throws ServletException
    {
        this.config = config;
        String act = config.getInitParameter("active");
        if (act != null)
            active = (act.toUpperCase().equals("TRUE"));
    }

    public void doFilter (ServletRequest request, ServletResponse response,
                          FilterChain chain) throws IOException, ServletException
    {
        if (active){
            // Здесь можно вставить код для обработки
        }
        chain.doFilter(request, response);
    }

    public void destroy()
    {
        config = null;
    }
}
----

В примере представленного шаблона фильтра инициализируется значение параметра `active`.
При вызове фильтра (`doFilter`) проверяется значение параметра `active`, и если `active = true`, могут быть выполнены действия, определенные разработчиком.

Интерфейс `FilterConfig` содержит метод для получения *имени фильтра*, его *параметров инициации* и *контекста* активного в данный момент сервлета.
С помощью своего метода `doFilter` каждый фильтр получает текущий запрос `ServletRequest` и ответ `ServletResponse`, а также `FilterChain`, содержащий *список фильтров*, предназначенных для обработки.
В методе `doFilter` фильтр может делать с запросом и ответом всё, что ему захочется - собирать данные или упаковывать объекты для придания им нового поведения.
Затем фильтр вызывает `chain.doFilter`, чтобы передать управление следующему фильтру.
После возвращения этого вызова фильтр может по окончании работы своего метода `doFilter` выполнить дополнительную работу над полученным ответом.
К примеру, сохранить регистрационную информацию об этом ответе.

После того, как класс-фильтр откомпилирован, его необходимо установить в *контейнер* и *приписать*(map) к одному или нескольким сервлетам.
Объявление и подключение фильтра определяется в дескрипторе приложения `web.xml` внутри элементов `<filter>` и `<filter-mapping>`.
Для подключение фильтра к сервлету необходимо использовать вложенные элементы `<filter-name>` и `<servlet-name>`.

[source,xml]
----
<filter>
    <filter-name>FilterName</filter-name>
    <filter-class>common.FilterConnect</filter-class>
    <init-param>
        <param-name>active</param-name>
        <param-value>true</param-true>
    </init-param>
</filter>

<filter-mapping>
    <filter-name>FilterName</filter-name>
    <servlet-name>ServletName</servlet-name>
</filter-mapping>
----

В представленном коде дескриптора приложения `web.xml` объявлен класс-фильтр `FilterConnect` с именем `FilterName`. Фильтр имеет параметр инициализации `active`, которому присвивается значение `true`. Фильтр `FilterName` в разделе `<filter-mapping>` подключен к сервлету `ServletName`.

Порядок, в котором контейнер строит цепочку фильтров для запроса определяется следующими правилами:

* цепочка, определяемая `url-pattern`, выстраивается в том порядке, в котором встречаются соответствующие описания фильтров в `web.xml`;
* последовательность сервлетов, определенных с помощью `servlet-name`, также выполняется в той последовательности, в какой эти элементы встречаются в дескрипторе поставки `web.xml`.

Для связи фильтра со страницами `HTML` или группой сервлетов необходимо использовать тег `<url-pattern>`. Например, после следующего кода:

[source,xml]
----
<filter-mapping>
    <filter-name>FilterName</filter-name>
    <url-pattern>*.html</url-pattern>
</filter-mapping>
----
фильтр будет применен ко всем вызовам страниц HTML.

Мапить фильтры можно также с использованием аннотации @WebFilter():

[source,java]
----
@WebFilter(name = "FilterName, url", urlPatterns={}, servletNames={})
public class FilterConnect implements Filter{}
----

В данном случае порядок вызова фильтров ничем не гарантирован.

=== Использование дополнительных ресурсов, RequestDispatcher

В отдельных случаях недостаточно вставить в сервлет фильтр или даже цепочку фильтров, а необходимо обратиться к другому сервлету, странице *JSP*, документу *HTML*, *XML* или другому ресурсу. Если требуемый ресурс находится в том же контексте, что и сервлет, который его вызывает, то для получения ресурса необходимо использовать метод:

[source,java]
----
public RequestDispatcher getRequestDispatcher(String path);
----

представленному в интерфейсе `ServletRequest`. Здесь `path` - это путь к ресурсу относительно контекста. Например, необходимо обратиться к сервлету `Connect`:

[source,java]
----
RequestDispatcher rd = request.getRequestDispatcher("Connect");
----

Если ресурс находится в другом контексте, то необходимо предварительно получить контекст методом

[source,java]
----
public ServletContext getContext(String uripath);
----

интерфейса `ServletContext`, а потом использовать метод

[source,java]
----
public RequestDispatcher getRequestDispatcher (String uripath);
----

интерфейса `ServletContext`. Здесь путь `uripath` должен быть абсолютным, т.е. начинаться с наклонной черты '/'. Например:

[source,java]
----
RequestDispatcher rd = config.getServletContext().getContext("/prod").getRequestDispatcher("/prod/Customer");
----

Если требуемый ресурс - сервлет, помещенный в контекст под своим именем, то для его получения можно обратиться к методу

[source,java]
----
RequestDispatcher getNamedDispatcher (String name);
----

интерфейса `ServletContext`. Все три метода возвращают `null`, если ресурс недоступен или сервер не реализует интерфейс `RequestDispatcher`.

Как видно из описания методов, к другим ресурсам можно обратиться только через объект типа `RequestDispatcher`, который предлагает два метода обращения к ресурсу. Первый метод

[source,java]
----
public void forward (ServletRequest request, ServletResponse response);
----

просто передает управление другому ресурсу, предоставив ему свои аргументы `ServletRequest` и `ServletResponse`. Вызывающий сервлет выполняет предварительную обработку объектов `request` и `response` и передает их вызванному сервлету или другому ресурсу, который окончательно формирует ответ `response` и отправляет его клиенту или, опять-таки, вызывает другой ресурс. Например:

[source,java]
----
if (rd != null)
rd.forward (request, response);
else
response.sendError (HttpServletResponse.SC_NO_CONTENT);
----

=== Исключение IllegalStateException

Вызывающий сервлет не должен выполнять какую-либо отправку клиенту до обращения к методу `forward`, иначе будет выброшено исключение класса `IllegalStateException`. Если же вызывающий сервлет уже что-то отправлял клиенту, то следует обратиться ко второму методу

[source,java]
----
public void include (ServletRequest request, ServletResponse response);
----

Этот метод вызывает ресурс, который на основании объекта request может изменить тело объекта response. Но вызванный ресурс не может изменить заголовки и код ответа объекта response. Это естественное ограничение, поскольку вызывающий сервлет мог уже отправить заголовки клиенту. Попытка вызванного ресурса изменить заголовок будет просто проигнорирована. Можно сказать, что метод include выполняет такую же работу, как вставки на стороне сервера SSI(Server Side Include).

== Servlet Listener

*Событие* (Event) - это то, что произошло. В мире веб-приложений событием может быть инициализация приложения, уничтожение приложения, запрос от клиента, создание / уничтожение сеанса, изменение атрибутов в сеансе и т. Д.

Servlet API предоставляет различные типы интерфейсов слушателей, которые мы можем реализовать и настроить в web.xml для обработки определенных событий, когда происходят определенные события. Например, в приведенном выше сценарии мы могли бы создать прослушиватель для события запуска приложения, чтобы прочитать параметры инициализации контекста и создать соединение с базой данных, а также установить его как свойство контекста для использования другими ресурсами.

=== Интерфейс Servlet Listener и объект Event

*Servlet API* предоставляет разные типы слушателей для разных типов событий. Интерфейс слушателя объявляет методы для обработки подобного набора событий.Например, у нас есть прослушиватель `ServletContext`, который прослушивает события запуска и завершения контекста. Каждый метод в интерфейсе слушателя принимает объект события в качестве входных данных. Объект события действует как оболочка, предоставляя конкретный объект для слушателя.

*Servlet API* предоставляет следующие объекты событий:

* `javax.servlet.AsyncEvent`- событие, которое вызывается, когда асинхронная операция, инициированная `ServletRequest` (путем вызова `ServletRequest` # `startAsync` или `ServletRequest` # `startAsync (ServletRequest, ServletResponse))`, завершилась по тайм-ауту или вызвала ошибку.
* `javax.servlet.http.HttpSessionBindingEvent` - отправьте событие этого типа объекту, который реализует `HttpSessionBindingListener`, когда объект связан или не связан с сеансом, или `HttpSessionAttributeListener`, настроенному в `web.xml`, когда любой атрибут связан , Отвязать или заменить в сеансе. Сеанс связывает объект, вызывая `HttpSession.setAttribute`, и отменяет привязку объекта, вызывая `HttpSession.removeAttribute`. Когда объект удаляется из сеанса, мы можем использовать это событие для операций очистки.
* `javax.servlet.http.HttpSessionEvent` - это класс, который представляет уведомления о событиях изменения сеанса в веб-приложении.
* `javax.servlet.ServletContextAttributeEvent` - класс событий для уведомлений об изменениях атрибутов `ServletContext` веб-приложения.
* `javax.servlet.ServletContextEvent`- это класс событий для уведомлений об изменениях контекста сервлета веб-приложения.
* `javax.servlet.ServletRequestEvent`- этот тип события представляет событие жизненного цикла `ServletRequest`. Исходный код события - `ServletContext` этого веб-приложения.
* `javax.servlet.ServletRequestAttributeEvent`- это класс событий для уведомления об изменениях атрибутов, запрошенных сервлетом в приложении.

*Servlet API* предоставляет следующие интерфейсы слушателя:

* `javax.servlet.AsyncListener`- слушатель будет уведомлен, если асинхронная операция, запущенная в ServletRequest с добавленным слушателем, завершилась, истекло время ожидания или вызвала ошибку.
* `javax.servlet.ServletContextListener`- интерфейс для получения уведомлений об изменениях жизненного цикла ServletContext.
* `javax.servlet.ServletContextAttributeListener`- интерфейс, который получает события уведомления об изменениях атрибута ServletContext.
* `javax.servlet.ServletRequestListener`- интерфейс для получения событий уведомления о запросах, входящих и выходящих из области веб-приложения.
* `javax.servlet.ServletRequestAttributeListener`- интерфейс, который получает события уведомления об изменениях атрибута ServletRequest.
* `javax.servlet.http.HttpSessionListener`- интерфейс для получения уведомлений об изменениях жизненного цикла HttpSession.
* `javax.servlet.http.HttpSessionBindingListener`- приводит к уведомлению объекта, когда он связан с или из сеанса.
* `javax.servlet.http.HttpSessionAttributeListener`- интерфейс для получения событий уведомления об изменениях атрибута HttpSession.
* `javax.servlet.http.HttpSessionActivationListener`-Objects, привязанные к сеансу, могут прослушивать события контейнера, сообщая им, что сеанс будет пассивирован и что сеанс будет активирован. Контейнер сеанса необходимо перенести между виртуальными машинами или постоянными сеансами, чтобы уведомить все свойства, связанные с сеансом, который реализует HttpSessionActivationListener.

=== Настройка Servlet Listener

Mожно использовать аннотацию `@WebListener` для объявления класса как `Listener`, но класс должен реализовывать один или несколько интерфейсов `Listener`.

Mожно определить слушателей в `web.xml`:

[source, xml]
----
<listener>
    <listener-class>
        com.journaldev.listener.AppContextListener
    </listener-class>
</listener>
----

