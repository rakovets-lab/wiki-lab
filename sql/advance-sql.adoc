= Продвинутый SQL

== Заявление `SELECT INTO`

Оператор `SELECT INTO` копирует данные из одной таблицы в новую таблицу.

=== Синтаксис `SELECT INTO`

Скопировать все столбцы в новую таблицу:

[source,sql]
----
SELECT *
INTO newtable [IN externaldb]
FROM oldtable
WHERE condition;
----

Скопировать только несколько столбцов в новую таблицу:

[source,sql]
----
SELECT column1, column2, column3, ...
INTO newtable [IN externaldb]
FROM oldtable
WHERE condition;
----

Новая таблица будет создана с именами и типами столбцов, как определено в старой таблице. Можно создавать новые имена столбцов, используя предложение `AS`.

=== Примеры SQL `SELECT INTO`

Следующий оператор SQL создает резервную копию `users`:

[source,sql]
----
SELECT * INTO usersBackup001
FROM users;
----

Следующий оператор использует предложение `IN` для копирования таблицы в новую таблицу в другой базе данных:

[source,sql]
----
SELECT * INTO usersBackup001 IN 'backup.mdb'
FROM users;
----

Следующий оператор копирует только несколько столбцов в новую таблицу:

[source,sql]
----
SELECT name, fullname INTO usersBackup001
FROM users;
----

== Оператор `INSERT INTO SELECT`

Оператор `INSERT INTO SELECT` копирует данные из одной таблицы и вставляет ее в другую таблицу. `INSERT INTO SELECT` требует, чтобы типы данных в исходной и целевой таблицах соответствовали.

Синтаксис `INSERT IN SELECT`
Скопировать все столбцы из одной таблицы в другую:

[source,sql]
----
INSERT INTO table2
SELECT * FROM table1
WHERE condition;
----

Скопировать только несколько столбцов из одной таблицы в другую таблицу:

[source,sql]
----
INSERT INTO table2 (column1, column2, column3, ...)
SELECT column1, column2, column3, ...
FROM table1
WHERE condition;
----

=== Пример SQL `INSERT INTO SELECT`

Следующий оператор копирует `clients` в `users` (столбцы, которые не заполнены данными, будет содержать `NULL`):

[source,sql]
----
INSERT INTO users (nme, fullname, balance)
SELECT nme, fullname, balance FROM clients;
----

== `CREATE INDEX`

Оператор `CREATE INDEX` используется для создания индексов в таблицах. Индексы используются для быстрого извлечения данных из базы данных. Пользователи не могут видеть индексы, они просто используются для ускорения поиска/запросов.

=== Синтаксис `CREATE INDEX`

`CREATE INDEX` создает индекс в таблице. Допускаются повторяющиеся значения:

[source,sql]
----
CREATE INDEX index_name
ON table_name (column1, column2, ...);
----

=== Синтаксис `CREATE UNIQUE INDEX`

Создает уникальный индекс в таблице. Дублирующие значения не допускаются:

[source,sql]
----
CREATE UNIQUE INDEX index_name
ON table_name (column1, column2, ...);
----

=== Пример `CREATE INDEX`

В приведенной ниже инструкции SQL создается индекс с именем `ind_name` в столбце `name` в таблице `users`:

[source,sql]
----
CREATE INDEX ind_name
ON users (name);
----

Если необходимо создать индекс в комбинации столбцов, можно указать имена столбцов в круглых скобках, разделенные запятыми:

[source,sql]
----
CREATE INDEX ind_name
ON users (name, fullname);
----

== Оператор `DROP INDEX`

Оператор `DROP INDEX` используется для удаления индекса в таблице.

[source,sql]
----
ALTER TABLE table_name
DROP INDEX index_name;
----

== Поле `AUTO INCREMENT`

`AUTO INCREMENT` позволяет создавать уникальный номер автоматически, когда новая запись вставляется в таблицу. Часто это поле основного ключа, которое необходимо создать автоматически каждый раз, когда будет вставлена новая запись.

=== Синтаксис для `MariaDB`

Следующий оператор SQL определяет столбец `user_id` как поле первичного ключа с автоматическим приращением в таблице `users`:

[source,sql]
----
CREATE TABLE users (
    user_id int NOT NULL AUTO_INCREMENT,
    name varchar(255) NOT NULL,
    fullname varchar(255),
    balance int,
    PRIMARY KEY (user_id)
);
----

MariaDB использует ключевое слово `AUTO_INCREMENT` для выполнения функции автоматического увеличения.

По умолчанию начальное значение для `AUTO_INCREMENT` равно `1`, и оно будет увеличиваться на 1 для каждой новой записи.

Чтобы последовательность `AUTO_INCREMENT` начиналась с другого значения, используйте следующий оператор:

[source,sql]
----
ALTER TABLE users AUTO_INCREMENT = 7;
----

Чтобы вставить новую запись в таблицу `user`, нам не нужно указывать значение для столбца `user_id`, так как уникальное значение будет добавляться автоматически:

[source,sql]
----
INSERT INTO users (name, fullname)
VALUES ('Том','Эдисон');
----

== Работа с датами

Пока ваши данные содержат только часть даты, ваши запросы будут работать должным образом. Однако, если задействована временная часть, она становится более сложной.

=== Типы данных `SQL Date`

MariaDB имеет следующие типы данных для хранения даты или значения даты/времени в базе данных:

* `DATE` - формат: `YYYY-MM-DD`
* `DATETIME` - формат: `YYYY-MM-DD HH:MI:SS`
* `TIMESTAMP` - формат: `YYYY-MM-DD HH:MI:SS`
* `YEAR` - формат: `YYYY` or `YY`

== Операторы

.Арифметические операторы SQL
[options="header"]
|===
|Оператор|Описание
|`+`|Добавление
|`-`|Вычитание
|`*`|Умножение
|`/`|Деление
|`%`|Модуль
|===

.Побитовые операции SQL
[options="header"]
|===
|Оператор|Описание
|`&`|Побитовое М
|/||Побитовое ИЛИ
|`^`|Побитовое исключение ИЛИ
|===

.Операторы сравнения SQL
[options="header"]
|===
|Оператор|Описание
|`=`|Равно
|`>`|Больше
|`<`|Меньше
|`>=`|Больше или равно
|`\<=`|Меньше или равно
|`<>`|Не равно
|===

.Составные операторы SQL
[options="header"]
|===
|Оператор|Описание
|`+=` |Добавить равно
|`-=`|Вычесть равно
|`*=`|Умножить равно
|`/=`|Разделить равно
|`%=`|Модуль равно
|`&=`|Побитовое И равно
|`^-=`|Побитовое исключающее равно
|`\|*=` |Побитовое ИЛИ равно
|===

.Логические операторы SQL
[options="header"]
|===
|Оператор|Описание
|`ALL` |Если все значения подзапроса являются `TRUE`
|`AND`|Если все условия, разделенные И, являются `TRUE`
|`ANY`|Если какое-либо из значений подзапроса соответствует `TRUE` условию
|`BETWEEN`|Если операнд находится в диапазоне сравнения
|`EXISTS`|Если подзапрос возвращает одну или несколько записей
|`IN`|Если операнд равен одному из списка выражений
|`LIKE`|Если операнд соответствует шаблону
|`NOT`|Отображает запись, если условие (И) НЕ `TRUE`
|`OR`|Если любое из условий, разделенных `OR`, является `TRUE`.
|`SOME`|Если какое-либо из значений подзапроса соответствует условию
|===

== Функции

.Функции
[options="header"]
|===
|Функция|Описание
|`ASCII`|Возвращает числовой код, который представляет конкретный символ
|`CHAR_LENGTH`|Возвращает длину указанной строки (в символах)
|`CHARACTER_LENGTH`|Возвращает длину указанной строки (в символах)
|`CONCAT`|Объединяет два или более выражения вместе
|`CONCAT_WS`|Объединяет два или более выражения вместе и добавляет разделитель между ними
|`FIELD`|Возвращает позицию значения в списке значений
|`FIND_IN_SET`|Возвращает позицию строки в списке строк
|`FORMAT`|Форматирует число как формат «#, ###. ##», округляя его до определенного количества знаков после запятой
|`INSERT`|Вставляет подстроку в строку в указанной позиции для определенного количества символов
|`INSTR`|Возвращает позицию первого вхождения строки в другую строку
|`LCASE`|Преобразует строку в нижний регистр
|`LEFT`|Извлекает подстроку из строки (начиная слева)
|`LENGTH`|Возвращает длину указанной строки (в байтах)
|`LOCATE`|Возвращает позицию первого вхождения подстроки в строку
|`LOWER`|Преобразует строку в нижний регистр
|`LPAD`|Возвращает строку, которая добавлена в левую сторону с указанной строкой до определенной длины
|`LTRIM`|Удаляет ведущие пробелы из строки
|`MID`|Извлекает подстроку из строки (начиная с любой позиции)
|`POSITION`|Возвращает позицию первого вхождения подстроки в строку
|`REPEAT`|Повторяет строку определенное количество раз
|`REPLACE`|Заменяет все вхождения указанной строки
|`REVERSE`|Отменяет строку и возвращает результат
|`RIGHT`|Извлекает подстроку из строки (начиная справа)
|`RPAD`|Возвращает строку с правой строкой с определенной строкой до определенной длины
|`RTRIM`|Удаляет конечные пробелы из строки
|`SPACE`|Возвращает строку с заданным количеством пробелов
|`STRCMP`|Проверяет, одинаковы ли две строки
|`SUBSTR`|Извлекает подстроку из строки (начиная с любой позиции)
|`SUBSTRING`|Извлекает подстроку из строки (начиная с любой позиции)
|`SUBSTRING_INDEX`|Возвращает подстроку  string и перед integer вхождений delimiter
|`TRIM`|Удаляет начальные и конечные пробелы из строки
|`UCASE`|Преобразует строку в верхний регистр
|`UPPER`|Преобразует строку в верхний регистр
|===

.Числовые функции
[options="header"]
|===
|Функция|Описание
|`ABS`|Возвращает абсолютное значение числа
|`ACOS`|Возвращает косинус дуги числа
|`ASIN`|Возвращает синус дуги числа
|`ATAN`|Возвращает тангенс дуги числа или дуги касательной n и m
|`ATAN2`|Возвращает тангенс дуги n и m
|`AVG`|Возвращает среднее значение выражения
|`CEIL`|Возвращает наименьшее целочисленное значение, которое больше или равно числу
|`CEILING`|Возвращает наименьшее целочисленное значение, которое больше или равно числу
|`COS`|Возвращает косинус числа
|`COT`|Возвращает котангенс числа
|`COUNT`|Возвращает количество записей в выбранном запросе
|`DEGREES`|Преобразует значение радиана в градусы
|`DIV`|Используется для целочисленного деления
|`EXP`|Возвращает e, поднятый до степени числа
|`FLOOR`|Возвращает наибольшее целочисленное значение, которое меньше или равно числу
|`GREATEST`|Возвращает наибольшее значение в списке выражений
|`LEAST`|Возвращает наименьшее значение в списке выражений
|`LN`|Возвращает натуральный логарифм числа
|`LOG`|Возвращает натуральный логарифм числа или логарифм числа к заданной базе
|`LOG10`|Возвращает логарифм базы-10 числа
|`LOG2`|Возвращает логарифм базы-2 числа
|`MAX`|Возвращает максимальное значение выражения
|`MIN`|Возвращает минимальное значение выражения
|`MOD`|Возвращает остаток n, деленный на m
|`PI`|Возвращает значение PI, отображаемое с шестью знаками после запятой
|`POW`|Возвращает m, поднятую до n-й степени
|`POWER`|Возвращает m, поднятую до n-й степени
|`RADIANS`|Преобразует значение в градусах в радианы
|`RAND`|Возвращает случайное число или случайное число в пределах диапазона
|`ROUND`|Возвращает число, округленное до определенного количества знаков после запятой
|`SIGN`|Возвращает значение, обозначающее знак числа
|`SIN`|Возвращает синус числа
|`SQRT`|Возвращает квадратный корень из числа
|`SUM`|Возвращает суммарное значение выражения
|`TAN`|Возвращает тангенс числа
|`TRUNCATE`|Возвращает число, усеченное до определенного количества знаков после запятой
|===

.Функции даты
[options="header"]
|===
|Функция|Описание
|`DATEDIFF`|Возвращает дату после добавления определенного интервала времени / даты
|`DATE_ADD`|Возвращает время / дату-время после добавления определенного временного интервала
|`DATE_FORMAT`|Возвращает текущую дату
|`DATE_SUB`|Возвращает текущую дату
|`DAY`|Возвращает текущее время
|`DAYNAME`|Возвращает текущую дату и время
|`DAYOFMONTH`|Возвращает текущее время
|`DAYOFWEEK`|Извлекает значение даты из выражения даты или даты и времени
|`DAYOFYEAR`|Возвращает разницу в днях между двумя значениями даты
|`EXTRACT`|Возвращает дату после добавления определенного интервала времени / даты
|`FROM_DAYS`|Форматирует дату, указанную маской формата
|`HOUR`|Возвращает дату после вычитания определенного интервала времени / даты
|`LAST_DAY`|Возвращает дневную часть значения даты
|`LOCALTIME`|Возвращает имя дня недели для даты
|`LOCALTIMESTAMP`|Возвращает дневную часть значения даты
|`MAKEDATE`|Возвращает индекс недели для значения даты
|`MAKETIME`|Возвращает день года для значения даты
|`MICROSECOND`|Извлекает части с даты
|`MINUTE`|Возвращает значение даты из числового представления дня
|`MONTH`|Возвращает часовую часть значения даты
|`MONTHNAME`|Возвращает последний день месяца на заданную дату
|`NOW`|Возвращает текущую дату и время
|`PERIOD_ADD`|Возвращает текущую дату и время
|`PERIOD_DIFF`|Возвращает дату определенного годового и дневного значения
|`QUARTER`|Возвращает время для определенного часа, минуты, второй комбинации
|`SECOND`|Возвращает микросекундную часть значения даты
|`SEC_TO_TIME`|Возвращает минутную часть значения даты
|`STR_TO_DATE`|Возвращает месячную часть значения даты
|`SUBDATE`|Возвращает полное название месяца для даты
|`SUBTIME`|Возвращает текущую дату и время
|`SYSDATE`|Принимает период и добавляет к нему определенное количество месяцев
|`TIME`|Возвращает разницу в месяцах между двумя периодами
|`TIME_FORMAT`|Возвращает четвертную часть значения даты
|`TIME_TO_SEC`|Возвращает вторую часть значения даты
|`TIMEDIFF`|Преобразует числовые секунды в значение времени
|`TIMESTAMP`|Принимает строку и возвращает дату, заданную маской формата
|`TO_DAYS`|Возвращает дату, после которой вычитается определенный интервал времени / даты
|`WEEK`|Возвращает значение time / datetime после вычитания определенного временного интервала
|`WEEKDAY`|Возвращает текущую дату и время
|`WEEKOFYEAR`|Извлекает значение времени из выражения time / datetime
|`YEAR`|Форматирует время, указанное маской формата
|`YEARWEEK`|Преобразует значение времени в числовые секунды
|===

.Расширенные функции
[options="header"]
|===
|Функция|Описание
|`BIN`|Преобразует десятичное число в двоичное число
|`BINARY`|Преобразует значение в двоичную строку
|`CASE`|Позволяет вам оценить условия и вернуть значение при выполнении первого условия
|`CAST`|Преобразует значение из одного типа данных в другой тип данных
|`COALESCE`|Возвращает первое ненулевое выражение в списке
|`CONNECTION_ID`|Возвращает уникальный идентификатор соединения для текущего соединения
|`CONV`|Преобразует число из одной базы чисел в другую
|`CONVERT`|Преобразует значение из одного типа данных в другой или один набор символов в другой
|`CURRENT_USER`|Возвращает имя пользователя и имя хоста для учетной записи MariaDB, используемой сервером, для проверки подлинности текущего клиента
|`DATABASE`|Возвращает имя базы данных по умолчанию
|`IF`|Возвращает одно значение, если условие `TRUE` или другое значение, если условие `FALSE`
|`IFNULL`|Позволяет вернуть альтернативное значение, если выражение равно `NULL`
|`ISNULL`|Проверяет, является ли выражение `NULL`
|`LAST_INSERT_ID`|Возвращает первое значение `AUTO_INCREMENT`, заданное последним оператором `INSERT` или `UPDATE`
|`NULLIF`|Сравнивает два выражения
|`SESSION_USER`|Возвращает имя пользователя и имя хоста для текущего пользователя MariaDB
|`SYSTEM_USER`|Возвращает имя пользователя и имя хоста для текущего пользователя MariaDB
|`USER`|Возвращает имя пользователя и имя хоста для текущего пользователя MariaDB
|`VERSION`|Возвращает версию базы данных MariaDB
|===

== Блокировки

*Блокировки* — это механизм поддержки требований об изолированности транзакций.

Одновременный конкурентный доступ может вызывать разные отрицательные эффекты, например *чтение несуществующих данных* или *потерю модифицированных данных*.

Рассмотрим следующий практический пример: Пользователь №1 из отдела кадров получает извещение, что сотрудник "Егор Егоров" поменял место жительства. Он вносит соответствующее изменение в базу данных для данного сотрудника, но при просмотре другой информации об этом сотруднике он понимает, что изменил адрес не того человека. Он нажимает кнопку отмены, уверенный в том, что данные после отмены операции изменения адреса уже не содержат никакой ошибки. В то же самое время пользователь №2 в отделе проектирования обращается к данным второго сотрудника с именем Егор Егоров, чтобы отправить ему домой последнюю техническую документацию, поскольку этот служащий редко бывает в офисе. Однако пользователь №2 обратился к базе данных после того, как адрес этого второго сотрудника с именем Егор Егоров был ошибочно изменен, но до того, как он был исправлен. В результате письмо отправляется не тому адресату. Чтобы предотвратить подобные проблемы, каждая система управления базами данных должна обладать механизмом для управления одновременным доступом к данным всеми пользователями. Для обеспечения согласованности данных в случае одновременного обращения к данным несколькими пользователями, применяют блокировки. Каждая прикладная программа блокирует требуемые ей данные, что гарантирует, что никакая другая программа не сможет модифицировать эти данные. Когда другая прикладная программа пытается получить доступ к заблокированным данным для их модификации, то система или завершает эту попытку ошибкой, или заставляет программу ожидать снятия блокировки.

Режимы блокировки определяют разные типы блокировок. Выбор определенного режима блокировки зависит от типа ресурса, который требуется заблокировать. Для блокировок ресурсов уровня строки и страницы применяются следующие три типа блокировок:

=== Разделяемая блокировка (shared lock)

Резервирует ресурс только для чтения. Другие процессы не могут изменять заблокированный таким образом ресурс, но несколько процессов могут одновременно считывать информацию или накладывать разделяемую блокировку на один и тот же ресурс. Иными словами, чтение ресурса с разделяемой блокировкой могут одновременно выполнять несколько процессов.

=== Монопольная блокировка (exclusive lock)

Резервирует страницу или строку для монопольного использования одной транзакции. Блокировка этого типа применяется такими инструкциями как `INSERT`, `UPDATE` и `DELETE`, которые модифицируют ресурс. Монопольную блокировку нельзя установить, если на ресурс уже установлена разделяемая или монопольная блокировка другим процессом, т.е. на ресурс может быть установлена только одна монопольная блокировка.

=== Блокировка обновления (update lock)

Является промежуточной между разделяемой и монопольной блокировкой. Блокировка обновления устанавливается при намерении транзакции изменить данные, но при этом само изменение не происходит. В этом случае другим транзакциям разрешается устанавливать разделяемые блокировки, но не позволяется устанавливать монопольные блокировки, до тех пор пока транзакция не завершится.

=== Блокировки намерения

Чтобы наложить монопольную блокировку на страницу данных, сервер должен убедиться, что ни на одну из записей, входящих в эту страницу, никакая блокировка не наложена. То есть необходимо перебрать все записи, входящие в страницу, и проверить их на наличие блокировок. То же самое, только в гораздо большем объеме, необходимо делать и для таблицы. Это было бы достаточно дорогостоящей операцией, но тут на помощь приходят блокировки намерения. Прежде чем ставить блокировку на конкретную запись, ставится соответствующая блокировка намерения на таблицу и страницу. Таким образом, отпадает необходимость проверять все записи, достаточно проверить, есть ли блокировка намерения на соответствующем уровне иерархии.

== SQL-транзакции

*Транзакция* представляет собой единицу работы, которая выполняется с базой данных.

Транзакцию можно рассматривать как внесение одного или нескольких изменений в базу данных. Например, если необходимо создать запись или выполнить обновление, удаление записи из таблицы, то выполняется транзакция в этой таблице.

=== Свойства транзакций

Транзакции имеют следующие четыре стандартных свойств, как правило, называют аббревиатурой *ACID*.

* *Atomicity* – гарантирует, что все операции в рамках единицы работы завершены успешно, иначе транзакция прерывается в точке выхода из строя, и все предыдущие операции откатываются в прежнее состояние.
* *Consistency* – гарантирует, что база данных правильно изменяет состояния на более успешное совершенные транзакции.
* *Isolation* – позволяет транзакции работать независимо и прозрачно друг с другом.
* *Durability* – гарантирует, что результат или эффект зафиксированной транзакции сохраняется в случае сбоя системы.

=== Управление транзакцией

Следующие команды используются для управления операциями.

* `COMMIT` – для сохранения изменений.
* `ROLLBACK` – откат изменений.
* `SAVEPOINT` – создает точки внутри групп операций, которые следует откатить.
* `SET TRANSACTION` – устанавливает характеристики транзакции.

=== Уровни изоляции

Чаще всего транзакции не должна зависеть от других транзакций, но применение жестких ограничений (блокировок) приводит к эффекту выстраивания в очередь транзакций на выполнение, что замедляет производительность системы.
Но бывают случаи, когда жесткие ограничения не нужны, поэтому существуют *уровни изоляции*, которые определяют степень параллелизма транзакций.
Существуют четыре вида изоляции:

* *Read uncommitted*;
* *Read committed*;
* *Repeatable read*;
* *Serializable*.

==== Read uncommitted (Dirty read)

Позволяет читать данные незафиксированных транзакций.
*Пример*: первая транзакция ввела данные, но не зафиксировала изменения, вторая прочитала, но первая отменила свои изменения данных.
В таком случае, получилась ситуация, в которой вторая транзакция прочитала несуществующие данные. Такой эффект называют *грязным чтением*.

==== Read Committed

При таком уровне изоляции транзакции не дадут прочитать данные, которые не зафиксировала другая транзакция после изменения.

Если первая транзакция один раз прочитала данные, а вторая транзакция сразу же их изменила и зафиксировала, то повторное чтение данных первой транзакции вернет измененные значения.
В таком случае может возникнуть ситуация, где: первая транзакция, к концу своего выполнения, обладает недостоверной информацией, которая может повлиять на вносимые данные.

==== Repeatable Read

Изменение данных, которые ранее прочитала первая транзакция, другими транзакциями до завершения первой невозможно.
Однако имеет место ситуация, когда другие транзакции будут не изменять, а добавлять новые данные, удовлетворяющие условию выборки первой транзакции по определенному условию.
В таком случае повторная выборка первой транзакции вернет новые значения.

==== Serializable

*Serializable* - уровень изоляции который бьет по производительности системы, но позволяет избежать проблем с чтением данных.
При таком уровне транзакции работают последовательно.