= Analytical functions

:imagesdir: ../assets/img/analytical-function

Аналитические функции вычисляют статистическое значение на основе группы строк.

*SQL Server* поддерживает указанные ниже аналитические функции:

* `RANK`
* `CUME_DIST`
* `FIRST_VALUE`
* `LAG`
* `LAST_VALUE`
* `LEAD`
* `PERCENT_RANK`
* `PERCENTILE_CONT`
* `PERCENTILE_DISC`

== Функции `RANK`, `CUME_DIST` and `PERCENT_RANK`

* `PERCENT_RANK` - возвращает процент значений, меньших чем текущая оценка.
* `CUME_DIST` - возвращает фактическое положение оценки.
* `RANK` - назначает одинаковое числовое значение строкам, претендующим на один ранг (например, `1`, `2`, `2`, `4`, `5`).

Синтаксис функций:

.Синтаксис `RANK()`
[source,java]
----
RANK() OVER ( [ partition_by_clause ] order_by_clause )
----

.Синтаксис `PERCENT_RANK()`
[source,java]
----
PERCENT_RANK() OVER (
 [PARTITION BY partition_expression, ... ]
ORDER BY sort_expression [ASC | DESC], ...)
----

.Синтаксис `PERCENT_RANK()`
[source,java]
----
CUME_DIST() OVER (
[PARTITION BY partition_expression, ... ]
ORDER BY sort_expression [ASC | DESC], ...)
----

где `PARTITION BY` распределяет строки по нескольким разделам, к которым применяется функции.

Допустим у нас есть таблица содержащая месяцы в отсортированном порядке по месяцу и значение температуры по Фаренгейту и по Цельсию.

|===
|*MNo*|*MName*|*AvgHighTempF*|*AvgHighTempC*
|1|Jan|40|4.44
|2|Feb|45|7.22
|3|Mar|55|12.78
|4|Apr|67|19.44
|5|May|77|25.00
|6|Jun|85|29.44
|7|Jul|89|31.67
|8|Aug|88|31.11
|9|Sep|81|27.22
|10|Oct|69|20.56
|11|Nov|56|13.33
|12|Dec|43|6.11
|===

Выполним запрос:

[source,java]
----
SELECT MName, AvgHighTempF, AvgHighTempC,

RANK() OVER(ORDER BY AvgHighTempf) AS Rnk,

PERCENT_RANK() OVER(ORDER BY AvgHighTempF) * 100.0 AS PR,

CUME_DIST() OVER(ORDER BY AvgHighTempF) * 100.0 AS CD  FROM MonthlyTempsStl;
----

Получим следующие значения:

image:Temperature.png[]

Январь является самым холодным месяцем.
Нет месяца, холоднее чем январь, поэтому его температура имеет `PERCENT_RANK = 0`.
`CUME_DIST` для нее равен `8.33%` (значения умножались на `100`, чтобы вернуть проценты), поскольку температура составляет `8,33%` (`1/12`) в списке.

Июль самый жаркий месяц и `PERCENT_RANK`, и `CUME_DIST` возвращают `100`, поскольку его температура жарче, чем во все другие месяцы, и находится на вершине списка.
Когда используются эти функции, всегда возвращаются `1` или `100%` для самого высокого элемента списка.

`RANK() OVER` в свою очередь возвращает ранг каждой строки в секции результирующего набора.
Ранг строки вычисляется как единица плюс количество рангов, находящихся до этой строки.

С принципом работы *необязательного* атрибута `PARTITION BY` можно ознакомиться по следующему запросу:

[source,java]
----
SELECT Name, Make, Model, Price, Type,
COME_DIST() over (PARTITION BY TYPE ORDER BY price) as CUME_DIST
FROM Bikes
----

Предложение `PARTITION BY` распределяет строки по нескольким разделам, к которым применяется функция `CUME_DIST()`.

image:partition-by.png[]

Каждый раздел(группа) рассматривается функцией `CUME_DIST` отдельно.

== Функции `FIRST_VALUE()` и `LAST_VALUE()`

* `FIRST_VALUE` возвращает первое значение в упорядоченном наборе значений из аналитического окна.
* `LAST_VALUE` возвращает последнее значение в упорядоченном наборе значений из аналитического окна.

.Синтаксис
[source,java]
----
FIRST_VALUE (expression [RESPECT NULLS | IGNORE NULLS])
OVER ([query_partition_clause] [order_by_clause [windowing_clause]])
----

где

* `expression` - столбец или выражение, для которого необходимо вернуть первое значение.
* `RESPECT NULLS` | `IGNORE NULLS` - необязательный параметр.
Он определяет, включены ли значения `NULL` или игнорируются в аналитическом окне. Если этот параметр опущен, значением по умолчанию является `RESPECT NULLS`, который включает значения `NULL`.
* `windowing_clause` - необязательный параметр.
Он определяет строки в аналитическом окне для оценки используя сортировку.

Варианты `windowing_clause`:

|===
|*windowing_clause*|*Description*
|`RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`|Последняя строка в окне изменяется с изменением текущей строки (по умолчанию)
|`RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING`|Первая строка в окне изменяется с изменением текущей строки
|`RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`|Все строки включены в окно независимо от текущей строки
|===

Допустим имеется таблица:

image:salary-table.png[]

Выполним следующий запрос:

[source,java]
----
SELECT DISTINCT FIRST_VALUE(salary)
 OVER (ORDER BY salary DESC
       RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
       AS HIGHEST
FROM salaryTable;
----

Отсортировав таблицу по полю `salary` получим первое наиболее значение `salary`:

|===
|*HIGHEST*
|5000
|===

[source,java]
----
SELECT DISTINCT department_id, FIRST_VALUE(salary)
 OVER (PARTITION BY department_id ORDER BY salary DESC
       RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
       AS HIGHEST
FROM salaryTable
WHERE department_id in (10,20)
ORDER BY department_id;
----

Выведем номер департамента и первое значение `salary`. Для этого разобьем таблицу на группы `department_id`  и отсортируем по полю `salary`. В выборке будут участвовать департаменты с номерами `10` и `20`.

|===
|*department_id*|*HIGHEST*
|10|3200
|20|4900
|===

Самую минимальную зарплату можно вывести изменив сортировку по `ASC`.

[source,java]
----
SELECT DISTINCT department_id, FIRST_VALUE(salary)
OVER (PARTITION BY department_id ORDER BY salary ASC
RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
AS LOWEST
FROM salaryTable
WHERE department_id in (10,20)
ORDER BY department_id;
----

Или воспользоваться функцией `LAST_VALUE()`.

[source,java]
----
SELECT DISTINCT department_id, LAST_VALUE(salary)
 OVER (PARTITION BY department_id ORDER BY salary DESC
       RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
       AS HIGHEST
FROM salaryTable
WHERE department_id in (10,20)
ORDER BY department_id;
----

Результат выполнения функций будет один:

|===
|*department_id*|*HIGHEST*
|10|2100
|20|2950
|===

== Функции `LAG()` и `LEAD()`

Функции `LAG` и `LEAD` позволяют возвращать выражение значения из строки в секции окна, которая находится на заданном смещении перед (`LAG` или `LEAD`).

image:sales-table.png[]

Выполним запрос, сдвинем на одну позицию с атрибутом `Selec_Amount`:

[source,java]
----
SELECT Sales_Customer_Id, Sales_Date, Sales_Amount,
LAG(Sales_Amount) OVER(PARTITION BY Sales_Customer_Id ORDER BY Sales_Date) AS PrevValue
FROM dbo.Sales
----

Благодаря такой возможности, можно увидеть тенденцию стоимости продаж между двумя датами:

image:sales-table-2.png[]

Благодаря функции `LEAD` сдвинем атрибут `Sales_Amount` вверх на одну позицию:

[source,java]
----
SELECT Sales_Customer_Id, Sales_Date,
LAG(Sales_Amount) OVER(PARTITION BY Sales_Customer_Id ORDER BY Sales_Date) AS PrevValue,
Sales_Amount,
LEAD(Sales_Amount) OVER(PARTITION BY Sales_Customer_Id ORDER BY Sales_Date) AS NextValue
FROM dbo.Sales
----

Результат:

image:sales-table-3.png[]

В функции можно указать шаг смещения, например на две позиции:

[source,java]
----
SELECT Sales_Customer_Id, Sales_Date,
LAG(Sales_Amount, 2) OVER(PARTITION BY Sales_Customer_Id ORDER BY Sales_Date) AS PrevValue,
Sales_Amount,
LEAD(Sales_Amount, 2) OVER(PARTITION BY Sales_Customer_Id ORDER BY Sales_Date) AS NextValue
FROM dbo.Sales
----

Результат:

image:sales-table-4.png[]

В функции можно указать значения по умолчанию, для избежания значений `null`:

[source,java]
----
SELECT Sales_Customer_Id, Sales_Date,
LAG(Sales_Amount, 2, 0) OVER(PARTITION BY Sales_Customer_Id ORDER BY Sales_Date) AS PrevValue,
Sales_Amount,
LEAD(Sales_Amount, 2, 0) OVER(PARTITION BY Sales_Customer_Id ORDER BY Sales_Date) AS NextValue
FROM dbo.Sales
----

Результат:

image:sales-table-5.png[]

== Функция `PERCENTILE_CONT`

`PERCENTILE_CONT` — вычисляет процентиль на основе постоянного распределения значения столбца. В качестве параметра принимает процентиль, который необходимо вычислить.

Синтаксис:

[source,java]
----
PERCENTILE_CONT ( numeric_literal )
WITHIN GROUP ( ORDER BY order_by_expression [ ASC | DESC ] )
OVER ( [ <partition_by_clause> ] )
----

где

* `numeric_literal` - процентиль, который необходимо вычислить. Значение должно находиться в диапазоне от `0.0` до `1,0`.
* `WITHIN GROUP` ( `ORDER BY order_by_expression` [ `ASC` | `DESC` ] ) - указывает список числовых значений, который следует отсортировать и по которому будет вычисляться процентиль. Разрешен только один аргумент `order_by_expression`. Результатом вычисления выражения должен быть точный или приблизительный числовой тип. Другие типы данных недопустимы.
* `OVER` ( `<partition_by_clause>` ) - делит результирующий набор, полученный с помощью предложения `FROM`.

Допустим есть таблица:

|===
|*a*|*b*|*c*
|NULL|NULL|3
|1|1|2
|2|1|1
|2|2|3
|3|1|2
|4|2|4
|5|1|1
|===

Вычислим значение процентиля по полю `a`:

[source,java]
----
SELECT PERCENTILE_CONT(0.5)
WITHIN GROUP (ORDER BY a)
FROM sets;
----

|===
|*PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY a)*
|2.500
|===

Вычислим значение процентиля по полю `a` разбив на группы по полю `c`:

[source,java]
----
SELECT c, PERCENTILE_CONT(0.5)
WITHIN GROUP (ORDER BY a) AS PERCENTILE
FROM sets
GROUP BY c ORDER BY c;
----

Результат:

|===
|*c*|*PERCENTILE*
|1|3.500
|2|2.000
|3|2.000
|4|4.000
|===

Вычислим значение процентиля по полю `a` используя параметр `PERCENTILE_CONT`(`0.25`):

[source,java]
----
SELECT PERCENTILE_CONT(0.25)
WITHIN GROUP (ORDER BY a) AS PERCENTILE
FROM sets;
----

|===
|*PERCENTILE*
|2.00
|===

Изменив параметр `ORDER BY` на `DESC`

[source,java]
----
SELECT PERCENTILE_CONT(0.25)
WITHIN GROUP (ORDER BY a DESC) AS PERCENTILE
FROM sets;
----

Получим следующий результат:

|===
|*PERCENTILE*
|3.750
|===

== Функция `PERCENTILE_DISC`

`PERCENTILE_DISC` — вычисляет определенный процентиль для отсортированных значений в наборе данных. В качестве параметра принимает процентиль, который необходимо вычислить.

Синтаксис:

[source,java]
----
PERCENTILE_DISC ( numeric_literal ) WITHIN GROUP ( ORDER BY order_by_expression [ ASC | DESC ] )
OVER ( [ <partition_by_clause> ] )
----

где

* `literal` - процентиль, который необходимо вычислить. Значение должно находиться в диапазоне от `0.0` до `1,0`.
* `WITHIN GROUP ( ORDER BY order_by_expression [ ASC | DESC)` - указывает список значений, который следует отсортировать и по которому будет вычисляться процентиль. Разрешен только один аргумент `order_by_expression`. По умолчанию задан порядок сортировки по возрастанию. Список значений может быть любого из типов данных, которые допустимы для операции сортировки.
* `OVER ( <partition_by_clause>)` - разделяет результирующий набор предложения `FROM` на секции, к которым применяется функция вычисления процентиля.

Создадим таблицу со следующими значениями:

|===
|*a*
|1
|2
|3
|5
|6
|100000
|===

Выполним запросы:

[source,java]
----
SELECT PERCENTILE_DISC(0.80)
WITHIN GROUP (ORDER BY a DESC) AS PERCENTILE
FROM table_name;
----

Результат:

|===
|*PERCENTILE*
|2
|===

[source,java]
----
SELECT PERCENTILE_DISC(0.10)
WITHIN GROUP (ORDER BY a DESC) AS PERCENTILE
FROM table_name;
----

Результат:

|===
|PERCENTILE
|100000
|===

Или для таблицы

|===
|*a*|*b*|*c*
|NULL|NULL|3
|1|1|2
|2|1|1
|2|2|3
|3|1|2
|4|2|4
|5|1|1
|===

Используем запрос:

[source,java]
----
SELECT c, PERCENTILE_DISC(0.5)
WITHIN GROUP (ORDER BY a) AS PERCENTILE
FROM sets
GROUP BY c ORDER BY c;
----

Результат:

|===
|*c*|*PERCENTILE*
|1|2
|2|1
|3|2
|4|4
|===
