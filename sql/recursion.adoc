=  Рекурсия (`RECURSIVE`)

Рекурсивная функция позволяет многократно выполнятся, чтобы возвращать подмножество данных до тех пор, пока не получится конечный результирующий набор.

.Синтаксис
[source,sql]
----
WITH [RECURSIVE]
    table_name(parameters) AS (select-stmt)
UNION [ALL]
    Recursive-select
    Cte-select;
----

Параметры:

* `table_name`(`parameters`) – таблица, данные в которой хранятся для использования в рекурсии, таблица не создаётся, она хранится в памяти компьютера и удаляется после завершения работы рекурсии. Ее не нужно создавать отдельно.
* `select-stmt` – выполняется один раз. Позволяет задать начальные значения полям таблицы до начала работы рекурсии.
* `UNION` [`ALL`] – позволяется соединить результаты запроса рекурсивной функции.
* `Recursive-select` – повторяющаяся часть. Будет выполняться пока условие не удовлетворено.
* `Cte-select` – значения полей, которые выведутся на экран.

Разберем принцип работы рекурсии на простом примере:

[source,sql]
----
WITH RECURSIVE
  table1(col1) AS (
      SELECT(1)
    UNION ALL
    SELECT col1+1 FROM table1
    WHERE col1<1000)

SELECT col1 FROM table1;
----

В таком запросе происходит создание таблицы `table1` с полем `col1`, после указания `AS` присваивается значение `сol1 = 1`. Этот блок в рекурсивной функции будет выполнен только один раз.

Важно понять, что не нужно создавать `table1` до создания рекурсии, она будет создана автоматически и не сохранится после завершения работы рекурсивной функции.

После указания `UNION ALL` описывается логика работы рекурсии — прибавление к значению `col1` единицы, до тех пор, пока функция не достигнет значения  `col1 = 1000`.

После отработки каждого цикла рекурсии, произойдет вывод значения `SELECT col1 FROM table1` на экран.

Таким образом получим следующую таблицу:

|===
|1
|2
|3
|...
|998
|999
|1000
|===

Другой пример, создадим таблицу содержащую имя сотрудника и его начальника:

[source,sql]
----
CREATE TABLE org(
  name varchar(100) PRIMARY KEY,
  boss varchar(100) REFERENCES org(name)
);
----

Внесем следующие имена:

[source,sql]
----
INSERT INTO org VALUES('Alice',NULL);
INSERT INTO org VALUES('Bob','Alice');
INSERT INTO org VALUES('Cindy','Alice');
INSERT INTO org VALUES('Dave','Bob');
INSERT INTO org VALUES('Emma','Bob');
INSERT INTO org VALUES('Fred','Cindy');
INSERT INTO org VALUES('Gail','Cindy');
----

Первый параметр — имя сотрудника, второй — ссылка на имя начальника. Например: у `Alice` нет начальник – значение `NULL`. Подчиненные `Alice` – `Bob`, `Cindy` и т.д.

Можно вывести одним рекурсивным запросом таблицу, содержащую иерархию сотрудников в компании. Используем следующий запрос:

[source,sql]
----
WITH RECURSIVE
  under_alice(name,level) AS (
    VALUES('Alice',0)

    UNION ALL

    SELECT org.name, under_alice.level+1
      FROM org JOIN under_alice ON org.boss=under_alice.name
  )

SELECT level, name FROM under_alice;
----

Вывод на экран:

[options="header"]
|===
|level|name
|0|Alice
|1|Bob
|1|Cindy
|2|Dave
|2|Emma
|2|Fred
|2|Gail
|===

Последовательность работы такого запроса:

1) Создание и инициализация таблицы `under_alice`(`name`, `level`) со значениями `Alice`,`0`.

2) Соединение инициализирующего блока с рекурсивным благодаря `UNION`, благодаря чему выведется первая строка.

[options="header"]
|===
|level|name
|0|Alice
|===

3) Выполнение рекурсивного блока:

[source,sql]
----
SELECT org.name, under_alice.level+1
    FROM org JOIN under_alice ON org.boss=under_alice.name
----

В результате которого в таблицу `under_alice()` попадут `Bob` и `Cindy`, поскольку они являются подчиненными Алисы. Значение `level = level(0) + 1 = 1`;

4) Соединение инициализирующего блока с рекурсивным благодаря `UNION`, благодаря чему выведется вторая и третья строка.

[options="header"]
|===
|level|name
|1|Bob
|1|Cindy
|===

5) Выполнение рекурсивного запроса, благодаря чему выведутся на экран имена `Dave`, `Emma`, `Fred`, `Fail` с `level = 2`.