<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<title>Объекты БД</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;-webkit-tap-highlight-color:transparent}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
<h1>Объекты БД</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_виды_объектов_бд">Виды объектов БД</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Объектами баз данных</strong> называют их структурные составляющие, такие, как <strong>схемы</strong> (<strong>schema</strong>), <strong>таблицы</strong> (<strong>table</strong>), <strong>представления</strong> (<strong>view</strong>), <strong>функции</strong> (<strong>function</strong>), <strong>процедуры</strong> (<strong>procedure</strong>), <strong>триггеры</strong> (<strong>trigger</strong>), <strong>последовательности</strong> (<strong>sequence</strong>), <strong>ограничения</strong> (<strong>constraints</strong>). Они выполняют различные функции по хранению и обработке информации.</p>
</div>
<div class="sect2">
<h3 id="_схемы">Схемы</h3>
<div class="paragraph">
<p><strong>Схема</strong> (<strong>schema</strong>) — это логический контейнер таблиц и других объектов внутри базы данных, причем каждая база данных может иметь одну или несколько схем.</p>
</div>
<div class="paragraph">
<p>Схемы применяются, чтобы объединить объекты базы данных в логические группы для облегчения управления ими и избежания конфликта имен различных приложений внутри схемы.</p>
</div>
<div class="paragraph">
<div class="title">Схемы</div>
<p><span class="image"><img src="../assets/img/bd-object/postgresql-schema.png" alt="postgresql schema"></span></p>
</div>
<div class="sect3">
<h4 id="_создание_схемы_сreate_schema">Создание схемы (<code>СREATE SCHEMA</code>)</h4>
<div class="paragraph">
<p>Для создания схемы необходимо использовать следующий запрос:</p>
</div>
<div class="listingblock">
<div class="title">Создание схемы</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE SCHEMA имя_схемы;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Таблица, при создании без указания схемы, автоматически помещается в схему <code>public</code>, для создания таблицы в определенной схеме, необходимо указать её имя:</p>
</div>
<div class="listingblock">
<div class="title">Cоздание таблицы в определенной схеме</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE имя_схемы.имя_таблицы ( ... );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Часто бывает нужно создать схему, владельцем которой будет другой пользователь (это один из способов ограничения пользователей пространствами имён). Сделать это можно следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE SCHEMA имя_схемы AUTHORIZATION имя_пользователя;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Возможно опустить имя схемы, в этом случае именем схемы станет имя пользователя. Схемы с именами, начинающимися с <code>pg_</code>, являются системными - пользователям не разрешено использовать такие имена.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE SCHEMA IF NOT EXISTS имя_схемы AUTHORIZATION имя_пользователя;</code></pre>
</div>
</div>
<div class="paragraph">
<p>где <code>IF NOT EXISTS</code> означает <strong>не делать ничего</strong>  (только выдать замечание), если схема с таким именем уже существует.</p>
</div>
<div class="paragraph">
<p><strong>Пример</strong>, создание схемы, в которой сразу создаются таблица и представление:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE SCHEMA hollywood
CREATE TABLE films (title text, release date, awards text[])
CREATE VIEW winners AS
SELECT title, release FROM films WHERE awards IS NOT NULL;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы создать объекты в схеме или обратиться к ним, необходимо указать полное имя, состоящее из имён схемы и объекта, разделённых точкой:</p>
</div>
<div class="listingblock">
<div class="title">Правило обращения к объекту внутри схемы</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">схема.объект</code></pre>
</div>
</div>
<div class="paragraph">
<p>Есть ещё более общий синтаксис</p>
</div>
<div class="listingblock">
<div class="title">Обращение к объекту через базу данных</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">база_данных.схема.объект</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_удаление_схемы_drop_schema">Удаление схемы (<code>DROP SCHEMA</code>)</h4>
<div class="paragraph">
<p>Удалить схему, которая не содержит внутри себя объектов, можно следующим способом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP SCHEMA имя_схемы;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Удалить схему со всеми содержащимися в ней объектами:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP SCHEMA имя_схемы CASCADE;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>RESTRICT</code> позволяет отказать в удалении схемы, если она содержит какие-либо объекты. Это поведение по умолчанию.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP SCHEMA имя_схемы RESTRICT;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_изменение_схемы_alter_schema">Изменение схемы (<code>ALTER SCHEMA</code>)</h4>
<div class="paragraph">
<p><code>ALTER SCHEMA</code> — позволяет изменить определение схемы.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER SCHEMA имя RENAME TO новое_имя

ALTER SCHEMA имя OWNER TO { новый_владелец | CURRENT_USER | SESSION_USER }</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>имя</code> - имя существующей схемы.</p>
</li>
<li>
<p><code>новое_имя</code> - новое имя схемы. Новое имя не может начинаться с <code>pg_</code>, так как такие имена зарезервированы для системных схем.</p>
</li>
<li>
<p><code>новый_владелец</code> - новый владелец схемы.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_схемы_и_права">Схемы и права</h4>
<div class="paragraph">
<p>По умолчанию пользователь не может обращаться к объектам в чужих схемах. Чтобы изменить это, владелец схемы должен дать пользователю право <code>USAGE</code> для данной схемы. Чтобы пользователи могли использовать объекты схемы, может понадобиться назначить дополнительные права на уровне объектов.</p>
</div>
<div class="paragraph">
<p>Пользователю также можно разрешить создавать объекты в схеме, не принадлежащей ему. Для этого ему нужно дать право <code>CREATE</code> в требуемой схеме. Требуется помнить, что по умолчанию все имеют права <code>CREATE</code> и <code>USAGE</code> в схеме <code>public</code>. Благодаря этому все пользователи могут подключаться к заданной базе данных и создавать объекты в её схеме <code>public</code>.</p>
</div>
<div class="paragraph">
<p>Некоторые шаблоны использования позволяют запретить это:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">REVOKE CREATE ON SCHEMA public FROM PUBLIC;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_таблицы">Таблицы</h3>
<div class="paragraph">
<p><strong>Таблицы</strong> используются для хранения данных, в базе данных может находиться несколько таблиц.</p>
</div>
<div class="paragraph">
<div class="title">Таблицы</div>
<p><span class="image"><img src="../assets/img/bd-object/postgresql-tables.png" alt="postgresql tables"></span></p>
</div>
<div class="sect3">
<h4 id="_создание_таблицы_create_table">Создание таблицы (<code>CREATE TABLE</code>)</h4>
<div class="paragraph">
<p>Для создания таблицы используется команда <code>CREATE TABLE</code>. В этой команде необходимо указать как минимум имя новой таблицы и имена, типы данных каждого столбца.</p>
</div>
<div class="paragraph">
<p><strong>Например</strong>:</p>
</div>
<div class="listingblock">
<div class="title">Создание таблицы</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE my_first_table (
    first_column text,
    second_column integer
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Число столбцов в таблице <strong>не может быть бесконечным</strong>. Это число ограничивается максимумом в пределах`от <code>250</code> до <code>1600</code>, в зависимости от типов столбцов. Однако, создавать таблицы с таким большим числом столбцов обычно не требуется, а если такая потребность возникает, это скорее признак сомнительного дизайна.</p>
</div>
</div>
<div class="sect3">
<h4 id="_удаление_таблицы_drop_table">Удаление таблицы (<code>DROP TABLE</code>)</h4>
<div class="paragraph">
<p>Если таблица больше не нужна, можно удалить её, выполнив следующую команду <code>DROP TABLE</code>:</p>
</div>
<div class="listingblock">
<div class="title">Удаление таблицы</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP TABLE my_first_table;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_изменение_таблицы_alter_table">Изменение таблицы (<code>ALTER TABLE</code>)</h4>
<div class="paragraph">
<p><code>ALTER TABLE</code> меняет определение существующей таблицы.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE [ IF EXISTS ] [ ONLY ] имя [ * ]
действие [, ... ]

ALTER TABLE [ IF EXISTS ] [ ONLY ] имя [ * ]
RENAME [ COLUMN ] имя_столбца TO новое_имя_столбца

ALTER TABLE [ IF EXISTS ] [ ONLY ] имя [ * ]
RENAME CONSTRAINT имя_ограничения TO имя_нового_ограничения

ALTER TABLE [ IF EXISTS ] имя
RENAME TO новое_имя

ALTER TABLE [ IF EXISTS ] имя
SET SCHEMA новая_схема</code></pre>
</div>
</div>
<div class="paragraph">
<p>Действия могут быть различными, приведем несколько примеров:</p>
</div>
<div class="listingblock">
<div class="title">Действия</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ADD [ COLUMN ] [ IF NOT EXISTS ] имя_столбца тип_данных
[ COLLATE правило_сортировки ] [ ограничение_столбца [ ... ] ]

DROP [ COLUMN ] [ IF EXISTS ] имя_столбца [ RESTRICT | CASCADE ]

ADD ограничение_таблицы [ NOT VALID ]

DROP CONSTRAINT [ IF EXISTS ] имя_ограничения [ RESTRICT | CASCADE ]

DISABLE TRIGGER [ имя_триггера | ALL | USER ]

ENABLE TRIGGER [ имя_триггера | ALL | USER ]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_представления_view">Представления (View)</h3>
<div class="paragraph">
<p><strong>Представления</strong> (<strong>View</strong>) - это именованные <strong>правила выборки данных</strong>.
Они предназначены для извлечения данных из одной или нескольких таблиц, на которые основываются.</p>
</div>
<div class="paragraph">
<p>Еще можно сказать, что <strong>представление это виртуальная таблица</strong>, которая используется для упрощения сложных запросов и обеспечения безопасности для набора записей.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../assets/img/bd-object/postgresql-views.png" alt="postgresql views"></span></p>
</div>
<div class="paragraph">
<p><strong>Преимущества представления</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Обеспечивают независимость пользовательских программ от изменения логической структуры базы данных.</p>
</li>
<li>
<p>Возможность различным пользователям по-разному видеть одни и те же данные.</p>
</li>
<li>
<p>Дополнительный механизм для управления санкционированным доступом.
Представления защищают данные, так как могут дать доступ к части таблицы, а не ко всей таблице.</p>
</li>
<li>
<p>Повторное использование написанного запроса.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_создание_представления_create_view">Создание представления (<code>CREATE VIEW</code>)</h4>
<div class="paragraph">
<p>Предположим, что появилась необходимость вывести список из названий городов, но нет потребности каждый раз вводить весь запрос.
Можно создать <strong>представление</strong> по данному запросу, фактически присвоить имя запросу, а затем обращаться к нему как к обычной таблице:</p>
</div>
<div class="listingblock">
<div class="title">Создание и использование представления:</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE VIEW myview AS
    SELECT name
    FROM cities;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь получить список названий (<code>name</code>) всех городов можно через представление используя следующий запрос:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT * FROM myview;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для изменения представления можно воспользоваться запросом:</p>
</div>
<div class="listingblock">
<div class="title">Изменение представления благодаря <code>OR REPLACE</code></div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE OR REPLACE VIEW myview AS
    SELECT name, id
    FROM cities;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Команда <code>CREATE OR REPLACE VIEW</code> действует подобным образом, но если представление с этим именем уже существует, оно заменяется.
Новый запрос должен выдавать те же столбцы, что выдавал запрос, ранее определённый для этого представления, (то есть, столбцы с такими же именами должны иметь те же типы данных и следовать в том же порядке), но может добавить несколько новых столбцов в конце списка.
Вычисления, в результате которых формируются столбцы представления, могут быть совершенно другими.</p>
</div>
<div class="paragraph">
<p>Это означает, что <strong>возникнет ошибка</strong>, если переопределить представление следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE OR REPLACE VIEW myview AS
    SELECT id, name
    FROM cities;

ERROR: ОШИБКА:  изменить имя столбца "name" на "id" в представлении нельзя</code></pre>
</div>
</div>
<div class="paragraph">
<p>Или при попытке исключить столбец:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE OR REPLACE VIEW myview AS
    SELECT id
    FROM cities;

ERROR: ОШИБКА:  удалять столбцы из представления нельзя</code></pre>
</div>
</div>
<div class="paragraph">
<p>Рассмотрим механизм создания представления поподробнее.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис создания представления</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] [ RECURSIVE ] VIEW имя [ ( имя_столбца
[, ...] ) ]
[ WITH ( имя_параметра_представления [= значение_параметра_представления]
[, ... ] ) ]
AS запрос
[ WITH [ CASCADED | LOCAL ] CHECK OPTION ]</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TEMPORARY</code> или <code>TEMP</code> - с такими параметрами представление создаётся как временное. Временные представления автоматически удаляются в конце сеанса. Существующее постоянное представление с тем же именем не будет видно в текущем сеансе, пока существует временное, однако к нему можно обратиться, дополнив имя указанием схемы. Если в определении представления задействованы временные таблицы, представление так же создаётся как временное (вне зависимости от присутствия явного указания <code>TEMPORARY</code>).</p>
</li>
<li>
<p><code>RECURSIVE</code> - создаёт рекурсивное представление.</p>
</li>
<li>
<p><code>запрос</code> - команда <code>SELECT</code> или <code>VALUES</code>, которая выдаёт столбцы и строки представления.</p>
</li>
<li>
<p><code>WITH [ CASCADED | LOCAL ] CHECK OPTION</code> - это указание управляет поведением автоматически изменяемых представлений. Если оно присутствует, при выполнении операций <code>INSERT</code> и <code>UPDATE</code> с этим представлением будет проверяться, удовлетворяют ли новые строки условию, определяющему представление (то есть, проверяется, будут ли новые строки видны через это представление). Если они не удовлетворяют условию, операция не будет выполнена. Если указание <code>CHECK OPTION</code> отсутствует, команды <code>INSERT</code> и <code>UPDATE</code> смогут создавать в этом представлении строки, которые не будут видны в нём.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Поддерживаются следующие варианты проверки:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>LOCAL</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Новые строки проверяются только по условиям, определённым непосредственно в самом представлении. Любые условия, определённые в нижележащих базовых представлениях, не проверяются (если только в них нет указания <code>CHECK OPTION</code>).</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CASCADED</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Новые строки проверяются по условиям данного представления и всех нижележащих базовых. Если указано <code>CHECK OPTION</code>, а <code>LOCAL</code> и <code>CASCADED</code> опущено, подразумевается указание <code>CASCADED</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_удаление_представления_drop_view">Удаление представления (<code>DROP VIEW</code>)</h4>
<div class="paragraph">
<p>Удалить представление можно следующим образом:</p>
</div>
<div class="listingblock">
<div class="title">Удаление представления</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP VIEW имя_представления;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Удаление представления с объектами, зависящие от данного представления</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP VIEW имя_представления CASCADE;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Отказать в удалении представления, если от него зависят какие-либо объекты. Это поведение по умолчанию</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP VIEW имя_представления RESTRICT;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_изменение_определения_представления_alter_view">Изменение определения представления (<code>ALTER VIEW</code>)</h4>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER VIEW [ IF EXISTS ] имя ALTER [ COLUMN ] имя_столбца SET DEFAULT выражение

ALTER VIEW [ IF EXISTS ] имя ALTER [ COLUMN ] имя_столбца DROP DEFAULT

ALTER VIEW [ IF EXISTS ] имя OWNER TO { новый_владелец | CURRENT_USER | SESSION_USER }

ALTER VIEW [ IF EXISTS ] имя RENAME TO новое_имя

ALTER VIEW [ IF EXISTS ] имя SET SCHEMA новая_схема

ALTER VIEW [ IF EXISTS ] имя SET ( имя_параметра_представления
[= значение_параметра_представления] [, ... ] )

ALTER VIEW [ IF EXISTS ] имя RESET ( имя_параметра_представления [, ... ] )</code></pre>
</div>
</div>
<div class="paragraph">
<p>Выполнить <code>ALTER VIEW</code> может только владелец представления. Чтобы сменить схему представления, необходимо также иметь право <code>CREATE</code> в новой схеме. Чтобы сменить владельца, требуется также быть непосредственным или опосредованным членом новой роли, а эта роль должна иметь право <code>CREATE</code> в схеме представления.</p>
</div>
<div class="paragraph">
<p><strong>Параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>имя</code> - имя существующего представления (возможно, дополненное схемой).</p>
</li>
<li>
<p><code>IF EXISTS</code> - не считать ошибкой, если представление не существует.
В этом случае будет выдано замечание.</p>
</li>
<li>
<p><code>SET/DROP DEFAULT</code> - эти формы устанавливают или удаляют значение по умолчанию в заданном столбце.
Значение по умолчанию подставляется в команды <code>INSERT</code> и <code>UPDATE</code>, вносящие данные в представление, до применения каких-либо правил или триггеров в этом представлении.
Таким образом, значения по умолчанию в представлении имеют приоритет перед значениями по умолчанию в нижележащих отношениях.</p>
</li>
<li>
<p><code>новый_владелец</code> - имя пользователя, назначаемого новым владельцем представления.</p>
</li>
<li>
<p><code>новое_имя</code> - новое имя представления.</p>
</li>
<li>
<p><code>новая_схема</code> - новая схема представления.</p>
</li>
<li>
<p><code>SET</code> и <code>RESET</code> - устанавливает или сбрасывает параметры представления.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_материализованное_представление_matview">Материализованное представление (matview)</h3>
<div class="paragraph">
<p><strong>Материализованное представление</strong> — это объект базы данных, который содержит результаты запроса.</p>
</div>
<div class="paragraph">
<p>Материализованное представление похоже на представление базы данных, за исключением того, что оно физически хранится на диске и обновляется вручную.
<strong>Matview</strong> хранит результаты запроса в собственной табличной структуре, из которой можно запрашивать данные.
<strong>Невозможно добавлять или удалять строки</strong>, но в остальное время он ведет себя как настоящая таблица.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Разница <strong>vies</strong> и <strong>matview</strong></caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Что сравниваем</th>
<th class="tableblock halign-left valign-top">VIEW</th>
<th class="tableblock halign-left valign-top">MATVIEW</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Способ хранения</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VIEW никогда не сохраняется, он только отображается.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Материализованное представление хранится на диске.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Способ обновления</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Представление обновляется каждый раз, когда используется виртуальная таблица (представление).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Материализованное представление должно обновляться вручную или с использованием триггеров.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Скорость</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Медленная обработка.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Быстрая обработка.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Использованием памяти</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Просмотр не требует места в памяти.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Материализованный вид использует пространство памяти.</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="title">Создание материализованного представления</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE MATERIALIZED VIEW [ IF NOT EXISTS ] имя_таблицы
    [ (имя_столбца [, ...] ) ]
    [ WITH ( параметр_хранения [= значение] [, ... ] ) ]
    [ TABLESPACE табл_пространство ]
AS запрос
    [ WITH [ NO ] DATA ]</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IF NOT EXISTS</code> - не считать ошибкой, если материализованное представление с таким именем уже существует. В этом случае будет выдано замечание. Заметьте, что нет никакой гарантии, что существующее материализованное представление как-то соотносится с тем, которое могло бы быть создано.</p>
</li>
<li>
<p><code>имя_таблицы</code> - имя создаваемого материализованного представления (возможно, дополненное схемой).</p>
</li>
<li>
<p><code>имя_столбца</code> - имя столбца в создаваемом материализованном представлении. Если имена столбцов не заданы явно, они определяются по именам столбцов результата запроса.</p>
</li>
<li>
<p><code>WITH ( параметр_хранения [= значение] [, &#8230;&#8203; ] )</code>
Это предложение задаёт дополнительные параметры хранения для создаваемого материализованного представления. Все параметры, которые поддерживает <code>CREATE TABLE</code>, поддерживает и <code>CREATE MATERIALIZED VIEW</code>.</p>
</li>
<li>
<p><code>TABLESPACE (табл_пространство)</code> — имя табличного пространства, в котором будет создано материализованное представление.</p>
</li>
<li>
<p><code>запрос</code> - команды <code>SELECT</code> или <code>VALUES</code>. Эти команды будут выполняться с ограничениями по безопасности. В частности, будут запрещены вызовы функций, которые сами создают временные таблицы.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_удаление_материализованного_представления_drop_materialized_view">Удаление материализованного представления (<code>DROP MATERIALIZED VIEW</code>)</h4>
<div class="listingblock">
<div class="title">Удаление материализованного представления</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP MATERIALIZED VIEW [ IF EXISTS ] имя [, ...] [ CASCADE | RESTRICT ]</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>где</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CASCADE</code> - автоматически удалять объекты, зависящие от данного материализованного представления (например, другие материализованные или обычные представления), и, в свою очередь, все зависящие от них объекты.</p>
</li>
<li>
<p><code>RESTRICT</code> - отказать в удалении материализованного представления, если от него зависят какие-либо объекты. Это поведение по умолчанию.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_изменение_материализованного_представления_alter_materialized_view">Изменение материализованного представления (<code>ALTER MATERIALIZED VIEW</code>)</h4>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER MATERIALIZED VIEW [ IF EXISTS ] имя
действие [, ... ]

ALTER MATERIALIZED VIEW имя
DEPENDS ON EXTENSION имя_расширения

ALTER MATERIALIZED VIEW [ IF EXISTS ] имя
RENAME [ COLUMN ] имя_столбца TO новое_имя_столбца

ALTER MATERIALIZED VIEW [ IF EXISTS ] имя
RENAME TO новое_имя

ALTER MATERIALIZED VIEW [ IF EXISTS ] имя
SET SCHEMA новая_схема</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Возможные действия</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER [ COLUMN ] имя_столбца SET STATISTICS integer

ALTER [ COLUMN ] имя_столбца SET ( атрибут = значение [, ... ] )

ALTER [ COLUMN ] имя_столбца RESET ( атрибут [, ... ] )

SET ( параметр_хранения [= значение] [, ... ] )

RESET ( параметр_хранения [, ... ] )

OWNER TO { новый_владелец | CURRENT_USER | SESSION_USER }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ALTER MATERIALIZED VIEW</code> изменяет различные расширенные свойства существующего материализованного представления.</p>
</div>
<div class="paragraph">
<p>Выполнить <code>ALTER MATERIALIZED VIEW</code> может только владелец материализованного представления. Чтобы сменить схему материализованного представления, необходимо также иметь право <code>CREATE</code> в новой схеме. Чтобы сменить владельца, требуется также быть непосредственным или опосредованным членом новой роли, а эта роль должна иметь право <code>CREATE</code> в схеме материализованного представления.</p>
</div>
<div class="paragraph">
<p><strong>Параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>имя</code> - имя существующего материализованного представления (возможно, дополненное схемой).</p>
</li>
<li>
<p><code>имя_столбца</code> - имя нового или существующего столбца.</p>
</li>
<li>
<p><code>имя_расширения</code> - имя расширения, от которого будет зависеть материализованное представление.</p>
</li>
<li>
<p><code>новое_имя_столбца</code> - новое имя существующего столбца.</p>
</li>
<li>
<p><code>новый_владелец</code> - имя пользователя, назначаемого новым владельцем материализованного представления.</p>
</li>
<li>
<p><code>новое_имя</code> - новое имя материализованного представления.</p>
</li>
<li>
<p><code>новая_схема</code> - новая схема материализованного представления.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_замена_содержимого_материализованного_представления_refresh_materialized_view">Замена содержимого материализованного представления (<code>REFRESH MATERIALIZED VIEW</code>)</h4>
<div class="listingblock">
<div class="title">Cинтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">REFRESH MATERIALIZED VIEW [ CONCURRENTLY ] имя
[ WITH [ NO ] DATA ]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>REFRESH MATERIALIZED VIEW</code> полностью заменяет содержимое материализованного представления. Эту команду разрешено выполнять только владельцам материализованного представления. Старое его содержимое при этом аннулируется. Если добавлено указание <code>WITH DATA</code> (или нет никакого), нижележащий запрос выполняется и выдаёт новые данные, так что материализованное представление остаётся в сканируемом состоянии. Если указано <code>WITH NO DATA</code>, новые данные не выдаются, и оно оказывается в несканируемом состоянии. Указать <code>CONCURRENTLY</code> вместе с <code>WITH NO DATA</code> нельзя.</p>
</div>
<div class="paragraph">
<p><strong>Параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CONCURRENTLY</code> - обновить материализованное представление, не блокируя параллельные выборки из него. Без данного параметра обновление, затрагивающее много строк, обычно задействует меньше ресурсов и выполнится быстрее, но может препятствовать чтению этого материализованного представления другими сеансами. При этом данный режим может быть быстрее при небольшом количестве строк. Данный параметр допускается, только если в материализованном представлении есть хотя бы один индекс <code>UNIQUE</code>, построенный только по именам столбцов и включающий все строки (то есть это не должен быть индекс по выражению или индекс, содержащий <code>WHERE</code>). Этот параметр нельзя использовать, когда материализованное представление ещё не наполнено. Даже с этим параметром в один момент времени допускается только одно обновление (<code>REFRESH</code>) материализованного представления.</p>
</li>
<li>
<p><code>имя</code> - имя (возможно, дополненное схемой) материализованного представления, подлежащего обновлению.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_функции">Функции</h3>
<div class="paragraph">
<p><strong>Функция</strong> — это многократно используемый блок кода SQL, который возвращает скалярное значение списка записей.</p>
</div>
<div class="paragraph">
<div class="title">Функции</div>
<p><span class="image"><img src="../assets/img/bd-object/postgresql-functions.png" alt="postgresql functions"></span></p>
</div>
<div class="sect3">
<h4 id="_создание_функции_create_function">Создание функции (<code>CREATE FUNCTION</code>)</h4>
<div class="paragraph">
<p>Чтобы заменить текущее определение существующей функции, используется команда <code>CREATE OR REPLACE FUNCTION</code>. Но следует учесть, что она не позволяет изменить имя или аргументы функции (если попытаться сделать это, на самом деле будет создана новая, независимая функция). Кроме того, <code>CREATE OR REPLACE FUNCTION</code> не позволит изменить тип результата существующей функции. Чтобы сделать это, придётся удалить функцию и создать её заново. Если удалить и затем вновь создадать функцию, новая функция станет другой сущностью, отличной от старой - потребуется так же удалить существующие правила, представления, триггеры, ссылающиеся на старую функцию. Поэтому, чтобы изменить определение функции, сохраняя ссылающиеся на неё объекты, следует использовать <code>CREATE OR REPLACE FUNCTION</code>.</p>
</div>
<div class="paragraph">
<p>Владельцем функции становится создавший её пользователь. Чтобы создать функцию, необходимо иметь право <code>USAGE</code> для типов её аргументов и возвращаемого типа.</p>
</div>
<div class="listingblock">
<div class="title">Cинтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE [ OR REPLACE ] FUNCTION
    имя ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента [ { DEFAULT |
= } выражение_по_умолчанию ] [, ...] ] )
    [ RETURNS тип_результата
    | RETURNS TABLE ( имя_столбца тип_столбца [, ...] ) ]
{ LANGUAGE имя_языка
    | TRANSFORM { FOR TYPE имя_типа } [, ... ]
    | WINDOW
    | { IMMUTABLE | STABLE | VOLATILE }
    | [ NOT ] LEAKPROOF
    | { CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT }
    | { [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER }
    | PARALLEL { UNSAFE | RESTRICTED | SAFE }
    | COST стоимость_выполнения
    | ROWS строк_в_результате
    | SUPPORT вспомогательная_функция
    | SET параметр_конфигурации { TO значение | = значение | FROM CURRENT }
    | AS 'определение'
    | AS 'объектный_файл', 'объектный_символ'
} ...</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Основные параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>имя</code> - имя создаваемой функции (возможно, дополненное схемой).</p>
</li>
<li>
<p><code>режим_аргумента</code> - режим аргумента: <code>IN</code> (входной), <code>OUT</code> (выходной), <code>INOUT</code> (входной и выходной) или <code>VARIADIC</code> (переменный). По умолчанию подразумевается <code>IN</code>. За единственным аргументом <code>VARIADIC</code> могут следовать только аргументы <code>OUT</code>. Кроме того, аргументы <code>OUT</code> и <code>INOUT</code> нельзя использовать с предложением <code>RETURNS TABLE</code>.</p>
</li>
<li>
<p><code>имя_аргумента</code> - имя аргумента.</p>
</li>
<li>
<p><code>тип_аргумента</code> - тип данных аргумента функции (возможно, дополненный схемой), при наличии аргументов. Тип аргументов может быть базовым, составным или доменным, либо это может быть ссылка на столбец таблицы.</p>
</li>
<li>
<p><code>выражение_по_умолчанию</code> - выражение, используемое для вычисления значения по умолчанию, если параметр не задан явно. Результат выражения должен сводиться к типу соответствующего параметра.</p>
</li>
<li>
<p><code>тип_результата</code> - тип возвращаемых данных (возможно, дополненный схемой). Это может быть базовый, составной или доменный тип, либо ссылка на тип столбца таблицы.</p>
</li>
<li>
<p><code>имя_столбца</code> - имя выходного столбца в записи <code>RETURNS TABLE</code>.</p>
</li>
<li>
<p><code>тип_столбца</code> - тип данных выходного столбца в записи <code>RETURNS TABLE</code>.</p>
</li>
<li>
<p><code>имя_языка</code> - имя языка, на котором реализована функция.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Пример</strong>:</p>
</div>
<div class="listingblock">
<div class="title">Пример создания функции на языке <code>SQL</code></div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE FUNCTION add(integer, integer) RETURNS integer
    AS 'select $1 + $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Пример создания функции на языке <code>PL/pgSQL</code></div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE FUNCTION add(integer, integer) RETURNS integer AS $$
    BEGIN
    RETURN $1 + $2;
    END; $$
    LANGUAGE plpgsql
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Вызов функции <code>add</code></div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT * FROM add(100,12);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ответом функции будет значение <code>112</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_удаление_функции_drop_function">Удаление функции (<code>DROP FUNCTION</code>)</h4>
<div class="paragraph">
<p><code>DROP FUNCTION</code> удаляет определение существующей функции. Пользователь, выполняющий эту команду, должен быть владельцем функции. Помимо имени функции требуется указать типы её аргументов, так как в базе данных могут существовать несколько функций с одним именем, но с разными списками аргументов.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP FUNCTION [ IF EXISTS ] имя [ ( [ [ режим_аргумента ] [ имя_аргумента
] тип_аргумента [, ...] ] ) ] [, ...]
[ CASCADE | RESTRICT ]</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>имя</code> - имя существующей функции (возможно, дополненное схемой). Если список аргументов не указан, имя функции должно быть уникальным в её схеме.</p>
</li>
<li>
<p><code>режим_аргумента</code> - режим аргумента: <code>IN</code>, <code>OUT</code>, <code>INOUT</code> или <code>VARIADIC</code>. По умолчанию подразумевается <code>IN</code>. Заметьте, что <code>DROP FUNCTION</code> не учитывает аргументы <code>OUT</code>, так как для идентификации функции нужны только типы входных аргументов.
Поэтому достаточно перечислить только аргументы <code>IN</code>, <code>INOUT</code> и <code>VARIADIC</code>.</p>
</li>
<li>
<p><code>имя_аргумента</code> - имя аргумента.</p>
</li>
<li>
<p><code>тип_аргумента</code> - тип данных аргументов функции (возможно, дополненный именем схемы), если таковые имеются.</p>
</li>
<li>
<p><code>CASCADE</code> - автоматически удалять объекты, зависящие от данной функции (например, операторы или триггеры), и, в свою очередь, все зависящие от них объекты.</p>
</li>
<li>
<p><code>RESTRICT</code> - отказать в удалении функции, если от неё зависят какие-либо объекты. Это поведение по умолчанию.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_изменить_определение_функции_alter_function">Изменить определение функции (<code>ALTER FUNCTION</code>)</h4>
<div class="paragraph">
<p><code>ALTER FUNCTION</code> позволяет изменить определение функции</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER FUNCTION имя [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, ...] ] ) ]
действие [ ... ] [ RESTRICT ]

ALTER FUNCTION имя [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, ...] ] ) ]
RENAME TO новое_имя

ALTER FUNCTION имя [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, ...] ] ) ]
OWNER TO { новый_владелец | CURRENT_USER | SESSION_USER }

ALTER FUNCTION имя [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, ...] ] ) ]
SET SCHEMA новая_схема

ALTER FUNCTION имя [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, ...] ] ) ]
[ NO ] DEPENDS ON EXTENSION имя_расширения</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Примеры</strong>:</p>
</div>
<div class="listingblock">
<div class="title">Переименование функции</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER FUNCTION sqrt(integer) RENAME TO square_root;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Смена владельца функции</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER FUNCTION sqrt(integer) OWNER TO joe;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_хранимые_процедуры">Хранимые процедуры</h3>
<div class="paragraph">
<p>Когда с данными нужно делать одни и те же действия очень часто на помощь приходят процедуры.</p>
</div>
<div class="paragraph">
<p><strong>Процедуры</strong> (<strong>procedure</strong>) - это блок операторов написанных на процедурном расширении языка <code>SQL</code> в контексте конкретной <strong>СУБД</strong>. Процедуры хранятся в базе данных в специально приспособленных для этого системных таблицах. Процедуры и функции могут быть вызваны на использование внутри базы данных или из клиентского приложения, но не возвращают результат, а функции возвращают.</p>
</div>
<div class="paragraph">
<p>Процедура является объектом базы данных, подобный функции, но имеющий следующие отличия:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Процедуры определяются командой <code>CREATE PROCEDURE</code>.</p>
</li>
<li>
<p>Процедуры, в отличие от функций, не возвращают значение; поэтому в <code>CREATE PROCEDURE</code> отсутствует предложение <code>RETURNS</code>. Однако процедуры могут выдавать данные в вызывающий код через выходные параметры.</p>
</li>
<li>
<p>Процедуры вызываются отдельно командой <code>CALL</code>.</p>
</li>
<li>
<p>Процедура, в отличие от функции, может фиксировать или откатывать транзакции во время её выполнения (а затем автоматически начинать новую транзакцию), если вызывающая команда <code>CALL</code> находится не в явном блоке транзакции.</p>
</li>
<li>
<p>Некоторые атрибуты функций (например, <code>STRICT</code>) неприменимы к процедурам.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_создание_процедуры_create_procedure">Создание процедуры (<code>CREATE PROCEDURE</code>)</h4>
<div class="listingblock">
<div class="title">Cинтаксис создания процедуры</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE [ OR REPLACE ] PROCEDURE
    имя ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента [   { DEFAULT |
    = } выражение_по_умолчанию ] [, ...] ] )
 { LANGUAGE имя_языка
    | TRANSFORM { FOR TYPE имя_типа } [, ... ]
    | [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER
    | SET параметр_конфигурации { TO значение | = значение | FROM   CURRENT }
    | AS 'определение'
    | AS 'объектный_файл', 'объектный_символ'
 } ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Команда <code>CREATE PROCEDURE</code> определяет новую процедуру, в тоже время <code>CREATE OR REPLACE PROCEDURE</code> создаёт новую процедуру либо заменяет определение уже существующей.</p>
</div>
<div class="paragraph">
<p>Чтобы определить процедуру, необходимо иметь право <code>USAGE</code> для соответствующего языка. Если указано имя схемы, процедура создаётся в заданной схеме, в противном случае — в текущей. Имя новой процедуры должно отличаться от имён существующих процедур и функций с такими же типами аргументов в этой схеме. Однако процедуры и функции с аргументами разных типов могут иметь одно имя (это называется перегрузкой).</p>
</div>
<div class="paragraph">
<p>Команда <code>CREATE OR REPLACE PROCEDURE</code> предназначена для изменения текущего определения существующей процедуры. С её помощью нельзя изменить имя или типы аргументов (если попытаться сделать это, будет создана новая отдельная процедура). Когда команда <code>CREATE OR REPLACE PROCEDURE</code> заменяет существующую процедуру, владелец и права доступа к этой процедуре не меняются. Все другие свойства процедуры получают значения, задаваемые командой явно или по умолчанию. Чтобы заменить процедуру, необходимо быть её владельцем (или быть членом роли-владельца). Владельцем процедуры становится создавший её пользователь. Чтобы создать процедуру, необходимо иметь право <code>USAGE</code> для типов её аргументов.</p>
</div>
<div class="paragraph">
<p><strong>Параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>имя</code> - имя создаваемой процедуры.</p>
</li>
<li>
<p><code>режим_аргумента</code> - режим аргумента: <code>IN</code>, <code>INOUT</code> или <code>VARIADIC</code>. По умолчанию подразумевается <code>IN</code>. (Режим <code>OUT</code> для процедур в настоящее время не поддерживается. Используйте вместо него <code>INOUT</code>).</p>
</li>
<li>
<p><code>имя_аргумента</code> - имя аргумента.</p>
</li>
<li>
<p><code>тип_аргумента</code> - тип данных аргумента процедуры (возможно, дополненный схемой), при наличии аргументов. Тип аргументов может быть базовым, составным или доменным, либо это может быть ссылка на столбец таблицы.</p>
</li>
<li>
<p><code>выражение_по_умолчанию</code> - выражение, используемое для вычисления значения по умолчанию, если параметр не задан явно. Результат выражения должен сводиться к типу соответствующего параметра. Для всех входных параметров, следующих за параметром с определённым значением по умолчанию, также должны быть определены значения по умолчанию.</p>
</li>
<li>
<p><code>имя_языка</code> - имя языка, на котором реализована функция.</p>
</li>
<li>
<p><code>TRANSFORM { FOR TYPE имя_типа } [, &#8230;&#8203; ] }</code> - устанавливает список трансформаций, которые должны применяться при вызове процедуры. Трансформации выполняют преобразования между типами <code>SQL</code> и типами данных, специфичными для языков. Преобразования встроенных типов обычно жёстко предопределены в реализациях процедурных языков, так что их здесь указывать не нужно. Если реализация процедурного языка не может обработать тип и трансформация для него отсутствует, будет выполнено преобразование типов по умолчанию, но это зависит от реализации.</p>
</li>
<li>
<p><code>[EXTERNAL] SECURITY INVOKER</code> / <code>[EXTERNAL] SECURITY DEFINER</code> - характеристика <code>SECURITY INVOKER</code> (безопасность вызывающего) показывает, что процедура будет выполняться с правами пользователя, вызвавшего её. Этот вариант подразумевается по умолчанию. Вариант <code>SECURITY DEFINER</code> (безопасность определившего) обозначает, что процедура выполняется с правами пользователя, владеющего ей. Ключевое слово <code>EXTERNAL</code> допускается для соответствия стандарту <code>SQL</code>, но является необязательным, так как, в отличие от <code>SQL</code>, эта характеристика распространяется на все процедуры, а не только внешние. В процедуре с характеристикой <code>SECURITY DEFINER</code> не могут выполняться операторы управления транзакциями (например, <code>COMMIT</code> и <code>ROLLBACK</code> в некоторых языках).</p>
</li>
<li>
<p><code>параметр_конфигурации</code> \ <code>значение</code> - предложение <code>SET</code> определяет, что при вызове процедуры указанный параметр конфигурации должен принять заданное значение, а затем восстановить своё предыдущее значение при завершении процедуры. Предложение <code>SET FROM CURRENT</code> сохраняет в качестве значения, которое будет применено при входе в процедуру, значение, действующее в момент выполнения <code>CREATE PROCEDURE</code>. Если в определение процедуры добавлено <code>SET</code>, то действие команды <code>SET LOCAL</code>, выполняемой внутри процедуры для того же параметра, ограничивается телом процедуры: предыдущее значение параметра так же будет восстановлено при завершении процедуры. Однако обычная команда <code>SET</code> (без <code>LOCAL</code>) переопределяет предложение <code>SET</code>, как и предыдущую команду <code>SET LOCAL</code>: действие такой команды будет сохранено и после завершения процедуры, если только не произойдёт откат транзакции. Если к определению процедуры добавлено <code>SET</code>, то в этой процедуре не могут выполняться операторы управления транзакциями (например, <code>COMMIT</code> и <code>ROLLBACK</code> в некоторых языках).</p>
</li>
<li>
<p><code>определение</code> - строковая константа, определяющая реализацию процедуры; её значение зависит от языка. Это может быть имя внутренней процедуры, путь к объектному файлу, команда <code>SQL</code> или код на процедурном языке. Часто бывает полезно заключать определение процедуры в доллары, а не в традиционные апострофы. Если не использовать доллары, все апострофы и обратные косые черты в определении процедуры придётся экранировать, дублируя их.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Пример</strong></p>
</div>
<div class="listingblock">
<div class="title">Пример создания процедуры</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE PROCEDURE insert_data(a integer, b varchar)
    LANGUAGE SQL
    AS $$
    insert into table_name VALUES (a,b);
    $$;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Процедура <code>insert_data</code> после вызова, занесет в таблицу значения <code>a</code> и <code>b</code>.</p>
</div>
<div class="paragraph">
<p>Чтобы вызвать процедуру воспользуйтесь командой <code>CALL</code>:</p>
</div>
<div class="listingblock">
<div class="title">Вызов процедуры</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CALL insert_data(1, 'data');</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_удаление_процедуры_drop_procedure">Удаление процедуры (<code>DROP PROCEDURE</code>)</h4>
<div class="paragraph">
<p>Чтобы удалить процедуры, необходимо воспользоваться командой <code>DROP PROCEDURE</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP PROCEDURE [ IF EXISTS ] имя [ ( [ [ режим_аргумента ] [ имя_аргумента
 ] тип_аргумента [, ...] ] ) ] [, ...]
 [ CASCADE | RESTRICT ]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DROP PROCEDURE</code> удаляет определение существующей процедуры. Пользователь, выполняющий эту команду, должен быть владельцем процедуры. Помимо имени процедуры требуется указать типы её аргументов, так как в базе данных могут существовать несколько процедур с одним именем, но с разными списками аргументов.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Параметры</strong>:</p>
</li>
<li>
<p><code>IF EXISTS</code> - не считать ошибкой, если процедура не существует. В этом случае будет выдано замечание.</p>
</li>
<li>
<p><code>имя</code> - имя существующей процедуры (возможно, дополненное схемой). Если список аргументов не указан, имя процедуры должно быть уникальным в её схеме.</p>
</li>
<li>
<p><code>режим_аргумента</code> - режим аргумента: <code>IN</code> или <code>VARIADIC</code>. По умолчанию подразумевается <code>IN</code>.</p>
</li>
<li>
<p><code>имя_аргумента</code> - имя аргумента.</p>
</li>
<li>
<p><code>тип_аргумента</code> - тип данных аргументов процедуры (возможно, дополненный именем схемы), если таковые имеются.</p>
</li>
<li>
<p><code>CASCADE</code> - автоматически удалять объекты, зависящие от данной процедуры, и, в свою очередь, все зависящие от них объекты.</p>
</li>
<li>
<p><code>RESTRICT</code> - отказать в удалении процедуры, если от неё зависят какие-либо объекты. Это поведение по умолчанию.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_изменение_процедуры_alter_procedure">Изменение процедуры (<code>ALTER PROCEDURE</code>)</h4>
<div class="paragraph">
<p><code>ALTER PROCEDURE</code> позволяет изменить определение процедуры. Выполнить <code>ALTER PROCEDURE</code> может только владелец процедуры. Чтобы сменить схему процедуры, необходимо также иметь право <code>CREATE</code> в новой схеме. Чтобы сменить владельца, требуется также быть непосредственным или опосредованным членом новой роли, а эта роль должна иметь право <code>CREATE</code> в схеме представления.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER PROCEDURE имя [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, ...] ] ) ]
действие [ ... ] [ RESTRICT ]

ALTER PROCEDURE имя [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, ...] ] ) ]
RENAME TO новое_имя

ALTER PROCEDURE имя [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, ...] ] ) ]
OWNER TO { новый_владелец | CURRENT_USER | SESSION_USER }

ALTER PROCEDURE имя [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, ...] ] ) ]
SET SCHEMA новая_схема</code></pre>
</div>
</div>
<div class="paragraph">
<p>Где действие может быть следующим:</p>
</div>
<div class="listingblock">
<div class="title">Возможные действия</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SET параметр_конфигурации { TO | = } { значение | DEFAULT }

SET параметр_конфигурации FROM CURRENT

RESET параметр_конфигурации

RESET ALL</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>новое_имя</code> - новое имя процедуры.</p>
</li>
<li>
<p><code>новый_владелец</code> - новый владелец процедуры. Заметьте, что если процедура помечена как <code>SECURITY DEFINER</code>, в дальнейшем она будет выполняться от имени нового владельца.</p>
</li>
<li>
<p><code>новая_схема</code> - новая схема процедуры.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Переименование процедуры <code>procedure_name</code> с двумя аргументами типа <code>integer</code> в <code>new_procedure_name</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER PROCEDURE procedure_name(integer, integer) RENAME TO new_procedure_name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Смена владельца процедуры <code>procedure_name</code> с двумя аргументами типа <code>integer</code> на <code>user_name</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER PROCEDURE procedure_name(integer, integer) OWNER TO user_name;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_триггеры">Триггеры</h3>
<div class="paragraph">
<p><strong>Триггер</strong> (<strong>trigger)</strong> - процедура, отличается от обычной тем, что она вызывается автоматически, при некотором событии в базе данных. Триггеры применяются для гарантированного выполнения определенных действий при возникновении событий. Триггеры носят глобальный характер и не зависят от причин и способов появления событий, на который они срабатывают.</p>
</div>
<div class="paragraph">
<p>Триггерные функции могут быть написаны на большинстве доступных процедурных языков,  включая <strong>PL/pgSQL</strong>, <strong>PL/Tcl</strong>, <strong>PL/Perl</strong> и <strong>PL/Python</strong>. В настоящее время невозможно написать  триггерную функцию на чистом <strong>SQL</strong>.</p>
</div>
<div class="paragraph">
<div class="title">Триггеры</div>
<p><span class="image"><img src="../assets/img/bd-object/postgresql-triggers.png" alt="postgresql triggers"></span></p>
</div>
<div class="paragraph">
<p>В <strong>PostgreSQL</strong> триггеры создаются на основе существующих функции, т.е. сначала командой <code>CREATE FUNCTION</code> определяется триггерная функция, затем на ее основе командой <code>CREATE TRIGGER</code> определяется собственно триггер.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис определения триггера</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TRIGGER триггер
    { BEFORE | AFTER } { событие [ OR событие ] } ON таблица
    FOR EACH { ROW |  STATEMENT }
    WHEN(условие)
    EXECUTE PROCEDURE функция ( аргументы );</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Параметры</strong>:</p>
</li>
<li>
<p><code>{ BEFORE | AFTER }</code> - ключевое слово <code>BEFORE</code> означает, что функция должна выполняться перед попыткой выполнения операции, включая все встроенные проверки ограничений данных, реализуемые при выполнении команд <code>INSERT</code> и <code>DELETE</code>. Ключевое слово <code>AFTER</code> означает, что функция вызывается после завершения операции, приводящей в действие триггер.</p>
</li>
<li>
<p><code>{ событие [ OR событие &#8230;&#8203; ] }</code> - события, поддерживаемые в <strong>PostgreSQL</strong>: <code>INSERT</code>, <code>UPDATE</code> или <code>DELETE</code>. При перечислении нескольких событий в качестве разделителя используется ключевое слово <code>OR</code>.</p>
</li>
<li>
<p><code>FOR EACH { ROW | STATEMENT }</code> - ключевое слово, следующее за конструкцией <code>FOR EACH</code> и определяющее количество вызовов функции при наступлении указанного события. Ключевое слово <code>ROW</code> означает, что функция вызывается для каждой модифицируемой записи. Если функция должна вызываться всего один раз для всей команды, используется ключевое слово <code>STATEMENT</code>.</p>
</li>
<li>
<p><code>WHEN</code> - необязательный параметр. В определении триггера можно указать логическое условие <code>WHEN</code>, которое определит, вызывать триггер или нет. В триггерах на уровне строк условия <code>WHEN</code> могут проверять старые и/или новые значения столбцов в строке. Триггеры на уровне оператора так же могут содержать условие <code>WHEN</code>, хотя для них это не столь полезно, так как в этом условии нельзя ссылаться на какие-либо значения в таблице.</p>
</li>
<li>
<p><code>EXECUTE PROCEDURE функция ( аргументы )</code>- имя вызываемой функции с аргументами. На практике аргументы при вызове триггерных функций не используются.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Синтаксис определения триггерной функции</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE FUNCTION функция () RETURNS trigger AS '
    BEGIN
    команды;
    return NEW | OLD;
    END;'
LANGUAGE  plpgsql;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cпециальные переменные, доступные в триггерных функциях:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>NEW</code> - Новые значения полей записи базы данных, созданной командой <code>INSERT</code> или обновленной командой <code>UPDATE</code>, при срабатывании триггера уровня записи <code>ROW</code>. В триггерах уровня оператора и для команды <code>DELETE</code> эта переменная имеет значение <code>null</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Внимание !!!</strong> Переменная <code>NEW</code> доступна только при операциях <code>INSERT</code> и <code>UPDATE</code>. Поля записи <code>NEW</code> могут быть изменены триггером. В триггерах уровня оператора и для команды <code>INSERT</code> эта  переменная имеет значение <code>null</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>OLD</code> - Старые значения полей записи базы данных, содержавшиеся в записи перед выполнением команды <code>DELETE</code> или <code>UPDATE</code> при срабатывании триггера уровня записи <code>ROW</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Внимание !!!</strong> Переменная <code>OLD</code> доступна только при операциях <code>DELETE</code> и <code>UPDATE</code>. Поля записи <code>OLD</code> можно использовать только для чтения, изменять нельзя.</p>
</div>
<div class="paragraph">
<p>К отдельным полям записей <code>NEW</code> и <code>OLD</code> в триггерных процедурах обращаются следующим образом: <code>NEW.names</code>, <code>OLD.rg</code>.</p>
</div>
<div class="paragraph">
<p><strong>Указания по возврату из тригеров:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Триггерная функция должна возвращать <code>NULL</code> или запись, соответствующую структуре таблицы, на которую будет вешаться триггер!</p>
</li>
<li>
<p>Если <code>BEFORE</code>-триггер возвращает <code>NULL</code>, то сама операция и <code>AFTER</code>-триггер будут отменены.</p>
</li>
<li>
<p><code>BEFORE</code>-триггер может изменить строку (<code>INSERT</code> \ <code>UPDATE</code>) через <code>NEW</code> и тогда операция и <code>AFTER</code>-триггеры` будут работать с заменённой строкой.</p>
</li>
<li>
<p>Если <code>BEFORE</code>-триггер` не "хочет" изменять строку, то надо просто вернуть <code>OLD</code>.</p>
</li>
<li>
<p><code>NEW</code> = <code>null</code> при <code>DELETE</code>, так что если <code>BEFORE</code>-триггер хочет дать ход <code>DELETE</code>, надо вернуть <code>OLD</code>.</p>
</li>
<li>
<p>Возвращаемое значение из построчного <code>AFTER</code>-триггера (или из <code>BEFORE</code> и из <code>AFTER</code>-триггеров на утверждения) игнорируется &#8658; можно возвращать <code>NULL</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Пример</strong>:</p>
</div>
<div class="listingblock">
<div class="title">Создаем триггер</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TRIGGER tr
    AFTER
    INSERT ON table_name
    FOR EACH ROW
    EXECUTE PROCEDURE func();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Создаем функцию</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE OR REPLACE FUNCTION func() RETURNS trigger AS '
    BEGIN
    delete from table_name where age = 1;
    return NEW;
    END;'
LANGUAGE plpgsql;</code></pre>
</div>
</div>
<div class="paragraph">
<p>После внесения данных в таблицу <code>table_name</code> вызывается функция <code>func()</code>, которая удалит из таблицы значения <code>age = 1</code>;</p>
</div>
<div class="paragraph">
<p>Если есть несколько триггеров на одно и то же событие для одной и той же таблицы, то они  будут вызываться в алфавитном порядке по имени триггера.</p>
</div>
<div class="sect3">
<h4 id="_удаление_триггера_drop_trigger">Удаление триггера (<code>DROP TRIGGER</code>)</h4>
<div class="paragraph">
<p><code>DROP TRIGGER</code> удаляет существующее определение триггера. Пользователь, выполняющий эту команду, должен быть владельцем таблицы, для которой определён данный триггер.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP TRIGGER [ IF EXISTS ] имя ON имя_таблицы [ CASCADE | RESTRICT ]</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IF EXISTS</code> - не считать ошибкой, если триггер не существует. В этом случае будет выдано замечание.</p>
</li>
<li>
<p><code>имя</code> - имя триггера, подлежащего удалению.</p>
</li>
<li>
<p><code>имя_таблицы</code> - имя (возможно, дополненное схемой) таблицы, для которой определён триггер.</p>
</li>
<li>
<p><code>CASCADE</code> - автоматически удалять объекты, зависящие от данного триггера, и, в свою очередь, все зависящие от них объекты .</p>
</li>
<li>
<p><code>RESTRICT</code> - Отказать в удалении триггера, если от него зависят какие-либо объекты. Это поведение по умолчанию.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_изменение_определения_триггера_alter_trigger">Изменение определения триггера (<code>ALTER TRIGGER</code>)</h4>
<div class="paragraph">
<p>Изменять свойства триггера может только владелец таблицы, с которой работает триггер следующим запросом:</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TRIGGER имя ON имя_таблицы RENAME TO новое_имя

ALTER TRIGGER имя ON имя_таблицы [ NO ] DEPENDS ON EXTENSION имя_расширения</code></pre>
</div>
</div>
<div class="paragraph">
<p>Предложение <code>RENAME</code> переименовывает данный триггер, не затрагивая его определение. Предложение <code>DEPENDS ON EXTENSION</code> помечает триггер как зависимый от расширения, так что при удалении расширения будет автоматически удаляться и триггер.</p>
</div>
<div class="paragraph">
<p><strong>Параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Имя</code> - имя существующего триггера, подлежащего изменению.</p>
</li>
<li>
<p><code>Имя_таблицы</code> - имя таблицы, с которой работает триггер.</p>
</li>
<li>
<p><code>Новое_имя</code> - новое имя триггера.</p>
</li>
<li>
<p><code>Имя_расширения</code> - имя расширения, от которого будет зависеть триггер (или не будет, если указано <code>NO</code>).
Триггер, помеченный как зависимый от расширения, автоматически удаляется при удалении расширения.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_последовательности_sequence">Последовательности (<code>Sequence</code>)</h3>
<div class="paragraph">
<p>Последовательности используются для управления столбцами с автоинкрементом, которые определены в таблице, как <code>SERIAL</code>.</p>
</div>
<div class="paragraph">
<div class="title">Последовательности (<code>Sequence</code>)</div>
<p><span class="image"><img src="../assets/img/bd-object/postgresql-sequence.png" alt="postgresql sequence"></span>]</p>
</div>
<div class="sect3">
<h4 id="_создание_последовательности_create_sequence">Создание последовательности (<code>CREATE SEQUENCE</code>)</h4>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE [ TEMPORARY | TEMP ] SEQUENCE [ IF NOT EXISTS ] имя
    [ AS тип_данных ]
    [ INCREMENT [ BY ] шаг ]
    [ MINVALUE мин_значение | NO MINVALUE ] [ MAXVALUE макс_значение | NO MAXVALUE ]
    [ START [ WITH ] начало ] [ CACHE кеш ] [ [ NO ] CYCLE ]
    [ OWNED BY { имя_таблицы.имя_столбца | NONE } ]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Такой запрос создаёт генератор последовательности. Эта операция включает создание и инициализацию специальной таблицы имя, содержащей одну строку. Владельцем генератора будет пользователь, выполняющий эту команду. Если указано имя схемы, последовательность создаётся в заданной схеме, в противном случае — в текущей. Временные последовательности существуют в специальной схеме, так что при создании таких последовательностей имя схемы задать нельзя. Имя последовательности должно отличаться от имён других последовательностей, таблиц, индексов, представлений или сторонних таблиц, уже существующих в этой схеме.</p>
</div>
<div class="paragraph">
<p>Хотя непосредственно изменить значение последовательности нельзя, получить её параметры и текущее состояние можно таким запросом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT * FROM name;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TEMPORARY</code> или <code>TEMP</code> - если указано, объект последовательности создаётся только для данного сеанса и автоматически удаляется при завершении сеанса. Существующая постоянная последовательность с тем же именем не будут видна (в этом сеансе), пока существует временная, однако к ней можно обратиться, дополнив имя указанием схемы.</p>
</li>
<li>
<p><code>IF NOT EXISTS</code> - не считать ошибкой, если отношение с таким именем уже существует. В этом случае будет выдано замечание. Заметьте, что нет никакой гарантии, что существующее отношение как-то соотносится с последовательностью, которая могла бы быть создана — это может быть даже не последовательность.</p>
</li>
<li>
<p><code>тип_данных</code> - необязательное предложение <code>AS</code> тип_данных задаёт тип данных для последовательности. Допустимые типы: <em>smallint</em>, <em>integer</em> и <em>bigint</em>. По умолчанию устанавливается тип <em>bigint</em>. От типа данных зависят принимаемые по умолчанию минимальное и максимальное значения последовательности.</p>
</li>
<li>
<p><code>шаг</code> - необязательное предложение <code>INCREMENT BY</code> шаг определяет, какое число будет добавляться к текущему значению последовательности для получения нового значения. С положительным шагом последовательность будет возрастающей, а с отрицательным — убывающей. Значение по умолчанию: <code>1</code>.</p>
</li>
<li>
<p><code>мин_значение</code> - Необязательное предложение <code>MINVALUE</code> определяет наименьшее число, которое будет генерировать последовательность. Если это предложение опущено либо указано <code>NO MINVALUE</code>, используется значение по умолчанию: <code>1</code> для возвращающей последовательности или минимальное значение типа данных — для убывающей.</p>
</li>
<li>
<p><code>макс_значения</code> - Необязательное предложение <code>MAXVALUE</code> определяет наибольшее число, которое будет генерировать последовательность. Если это предложение опущено либо указано <code>NO MAXVALUE</code>, используется значение по умолчанию: максимальное значение типа данных для возрастающей последовательности или <code>-1</code> — для убывающей</p>
</li>
<li>
<p><code>начало</code> - необязательное предложение <code>START WITH</code> начало позволяет запустить последовательность с любого значения. По умолчанию началом считается мин_значение для возрастающих последовательностей и максимальное значение для убывающих.</p>
</li>
<li>
<p><code>кеш</code> - необязательное предложение <code>CACHE</code> кеш определяет, сколько чисел последовательности будет выделяться и сохраняться в памяти для ускорения доступа к ним. Минимальное значение равно 1 (за один раз генерируется только одно значение, т. е. кеширования нет), и оно же предполагается по умолчанию.</p>
</li>
<li>
<p><code>CYCLE / NO CYCLE</code> - параметр <code>CYCLE</code> позволяет зациклить последовательность при достижении макс_значения или мин_значения для возрастающей или убывающей последовательности, соответственно. Когда этот предел достигается, следующим числом этих последовательностей будет соответственно мин_значение или макс_значение. Если указывается <code>NO CYCLE</code>, при каждом вызове <code>nextval</code> после достижения предельного значения будет возникать о</p>
</li>
<li>
<p><code>OWNED BY имя_таблицы.имя_столбца / OWNED BY NONE</code> - предложение <code>OWNED BY</code> позволяет связать последовательность с определённым столбцом таблицы так, чтобы при удалении этого столбца (или всей таблицы) последовательность удалялась автоматически.Указанная таблица должна иметь того же владельца и находиться в той же схеме, что и последовательность. Подразумеваемое по умолчанию предложение <code>OWNED BY NONE</code> указывает, что такая связь не устанавливается.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Примеры</strong>:</p>
</div>
<div class="paragraph">
<p>Создание возрастающей последовательности с именем <code>serial</code>, с начальным значением <code>101</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE SEQUENCE serial START 101;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Использование этой последовательности в команде <code>INSERT</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">INSERT INTO table_name VALUES (nextval('serial'), 'nothing');</code></pre>
</div>
</div>
<div class="paragraph">
<p>Добавив через такой запрос в таблицу значения, последовательность увеличится на единицу и <code>nextval('serial') = 102</code>;</p>
</div>
<div class="paragraph">
<p>Чтобы узнать следующий номер этой последовательности выполните запрос:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT * FROM serial;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_удаление_последовательности_drop_sequence">Удаление последовательности (<code>DROP SEQUENCE</code>)</h4>
<div class="paragraph">
<p>Удалить последовательность может только её владелец или суперпользователь, для этого воспользуйтесь запросом:</p>
</div>
<div class="listingblock">
<div class="title">Для удаления последовательности</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP SEQUENCE [ IF EXISTS ] имя [, ...] [ CASCADE | RESTRICT ]</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IF EXISTS</code> - не считать ошибкой, если последовательность не существует. В этом случае будет выдано замечание.</p>
</li>
<li>
<p><code>имя</code> - имя последовательности (возможно, дополненное схемой).</p>
</li>
<li>
<p><code>CASCADE</code> - автоматически удалять объекты, зависящие от данной последовательности, и, в свою очередь, все зависящие от них объекты.</p>
</li>
<li>
<p><code>RESTRICT</code> - отказать в удалении последовательности, если от неё зависят какие-либо объекты. Это поведение по умолчанию</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_изменение_определение_генератора_последовательности_alter_sequence">Изменение определение генератора последовательности (<code>ALTER SEQUENCE</code>)</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER SEQUENCE [ IF EXISTS ] имя
    [ AS тип_данных ]
    [ INCREMENT [ BY ] шаг ]
    [ MINVALUE мин_значение | NO MINVALUE ] [ MAXVALUE макс_значение | NO MAXVALUE ]
    [ START [ WITH ] начало ]
    [ RESTART [ [ WITH ] перезапуск ] ]
    [ CACHE кеш ] [ [ NO ] CYCLE ]
    [ OWNED BY { имя_таблицы.имя_столбца | NONE } ]

    ALTER SEQUENCE [ IF EXISTS ] имя OWNER TO { новый_владелец | CURRENT_USER |
    SESSION_USER }

    ALTER SEQUENCE [ IF EXISTS ] имя RENAME TO новое_имя

    ALTER SEQUENCE [ IF EXISTS ] имя SET SCHEMA новая_схема</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ALTER SEQUENCE</code> меняет параметры существующего генератора последовательности. Параметры, не определяемые явно в команде <code>ALTER SEQUENCE</code>, сохраняют свои предыдущие значения. Выполнить <code>ALTER SEQUENCE</code> может только владелец соответствующей последовательности. Чтобы сменить схему последовательности, необходимо также иметь право <code>CREATE</code> в новой схеме. Чтобы сменить владельца, необходимо быть непосредственным или опосредованным членом новой роли-владельца, а эта роль должна иметь право <code>CREATE</code> в схеме последовательности.</p>
</div>
<div class="paragraph">
<p>Дополнительные параметры, отсутствующие в запросе создания <code>sequence</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>новый_владелец</code> - имя пользователя, назначаемого новым владельцем последовательности.</p>
</li>
<li>
<p><code>новое_имя</code> - новое имя последовательности.</p>
</li>
<li>
<p><code>новая_схема</code> - новая схема последовательности.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ограничения_constraints">Ограничения (<code>Constraints</code>)</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="image"><img src="../assets/img/bd-object/postgresql-constraints.png" alt="postgresql constraints"></span></p>
</div>
<div class="paragraph">
<p>С помощью ключевого слова <code>CONSTRAINT</code> можно задать имя для ограничений. В качестве ограничений могут использоваться <code>PRIMARY KEY</code>, <code>UNIQUE</code>, <code>CHECK</code>.</p>
</div>
<div class="sect2">
<h3 id="_ограничения_проверки">Ограничения-проверки</h3>
<div class="paragraph">
<p><strong>Ограничение-проверка</strong> — наиболее общий тип ограничений. В его определении можно указать, что значение данного столбца должно удовлетворять логическому выражению (проверке истинности). Например, цену товара можно ограничить положительными значениями так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ограничение определяется после типа данных, как и значение по умолчанию. Значения по умолчанию и ограничения могут указываться в любом порядке. Ограничение-проверка состоит из ключевого слова <code>CHECK</code>, за которым идёт выражение в скобках. Это выражение должно включать столбец, для которого задаётся ограничение, иначе оно не имеет большого смысла.</p>
</div>
<div class="paragraph">
<p>Можно также присвоить ограничению отдельное имя. Это улучшит сообщения об ошибках и позволит ссылаться на это ограничение, когда понадобится изменить его. Имена ограничений можно задать на уровне столбцов. Они указываются после <code>CONSTRAINT</code> перед атрибутами:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CONSTRAINT positive_price CHECK (price &gt; 0)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>То есть, чтобы создать именованное ограничение, напишите ключевое слово <code>CONSTRAINT</code>, а за ним идентификатор и собственно определение ограничения.</p>
</div>
<div class="paragraph">
<p>Ограничение-проверка может также ссылаться на несколько столбцов. Например, если необходимо хранить обычную цену и цену со скидкой, так можете гарантировать, что цена со скидкой будет всегда меньше обычной.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE table_name (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric CHECK (discounted_price &gt; 0),
    CHECK (price &gt; discounted_price)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Этот пример можно переписать иначе:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE table_name (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    CHECK (price &gt; discounted_price)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>или так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE table_name (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0 AND price &gt; discounted_price)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ограничениям таблицы можно присваивать имена так же, как и ограничениям столбцов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE table_name (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    CONSTRAINT valid_discount CHECK (price &gt; discounted_price)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следует заметить, что ограничение-проверка удовлетворяется, если выражение принимает значение <code>true</code> или <code>NULL</code>. Так как результатом многих выражений с операндами <code>NULL</code> будет значение <code>NULL</code>, такие ограничения не будут препятствовать записи <code>NULL</code> в связанные столбцы. Чтобы гарантировать, что столбец не содержит значения <code>NULL</code>, можно использовать ограничение <code>NOT NULL</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ограничение_not_null">Ограничение <code>NOT NULL</code></h3>
<div class="paragraph">
<p>Ограничение <code>NOT NULL</code> просто указывает, что столбцу нельзя присваивать значение <code>NULL</code>.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ограничение <code>NOT NULL</code> всегда записывается как ограничение столбца и функционально эквивалентно ограничению <code>CHECK (имя_столбца IS NOT NULL)</code>, но в <strong>Postgres Pro</strong> явное ограничение <code>NOT NULL</code> работает более эффективно. Хотя у такой записи есть недостаток — назначить имя таким ограничениям нельзя.</p>
</div>
<div class="paragraph">
<p>Для столбца можно определить больше одного ограничения. Для этого их нужно просто указать одно за другим:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric NOT NULL CHECK (price &gt; 0)
);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ограничения_уникальности">Ограничения уникальности</h3>
<div class="paragraph">
<p>Ограничения уникальности гарантируют, что данные в определённом столбце или группе столбцов уникальны среди всех строк таблицы. Ограничение записывается так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE products (
    product_no integer UNIQUE,
    name text,
    price numeric
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>или:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    UNIQUE (product_no)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы определить ограничение уникальности для группы столбцов, запишите его в виде ограничения таблицы, перечислив имена столбцов через запятую:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    UNIQUE (a, c)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Такое ограничение указывает, что сочетание значений перечисленных столбцов должно быть уникально во всей таблице, тогда как значения каждого столбца по отдельности не должны быть (и обычно не будут) уникальными.</p>
</div>
<div class="paragraph">
<p>Можно назначить уникальному ограничению имя обычным образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE products (
    product_no integer CONSTRAINT must_be_different UNIQUE,
    name text,
    price numeric
);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_первичный_ключ_primary_key">Первичный ключ (<code>PRIMARY KEY</code>)</h3>
<div class="paragraph">
<p>Ограничение первичного ключа означает, что образующий его столбец или группа столбцов может быть уникальным идентификатором строк в таблице. Для этого требуется, чтобы значения были одновременно уникальными и отличными от <code>NULL</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Первичные ключи могут включать несколько столбцов; синтаксис похож на запись ограничений уникальности:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    PRIMARY KEY (a, c)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>При добавлении первичного ключа автоматически создаётся уникальный индекс-B-дерево для столбца или группы столбцов, перечисленных в первичном ключе, и данные столбцы помечаются как <code>NOT NULL</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ограничение_внешнего_ключа_references">Ограничение внешнего ключа (<code>REFERENCES</code>)</h3>
<div class="paragraph">
<p>Ограничение внешнего ключа указывает, что значения столбца (или группы столбцов) должны соответствовать значениям в некоторой строке другой таблицы. Это называется ссылочной целостностью двух связанных таблиц.</p>
</div>
<div class="paragraph">
<p>Пусть у вас уже есть таблица продуктов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Предположим, что есть таблица с заказами этих продуктов. Чтобы в таблице заказов содержались только заказы действительно существующих продуктов, определим в ней ограничение внешнего ключа, ссылающееся на таблицу продуктов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer REFERENCES products (product_no),
    quantity integer
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>С таким ограничением создать заказ отсутствующим в таблице <code>products</code> (и не равным <code>NULL</code>), будет невозможно.</p>
</div>
<div class="paragraph">
<p>В такой схеме таблицу <code>orders</code> называют подчинённой таблицей, а <code>products</code> — главной. Соответственно, столбцы называют так же <code>подчинённым</code> и <code>главным</code> (или ссылающимся и целевым).</p>
</div>
<div class="paragraph">
<p>Предыдущую команду можно сократить так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer REFERENCES products,
    quantity integer
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если опустить список столбцов, внешний ключ будет неявно связан с первичным ключом главной таблицы.</p>
</div>
<div class="paragraph">
<p>Внешний ключ также может ссылаться на группу столбцов. В этом случае его нужно записать в виде обычного ограничения таблицы.</p>
</div>
<div class="paragraph">
<p><strong>Например</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE t1 (
  a integer PRIMARY KEY,
  b integer,
  c integer,
  FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Естественно, число и типы столбцов в ограничении должны соответствовать числу и типам целевых столбцов.</p>
</div>
<div class="sect3">
<h4 id="_добавление_ограничения_alter_table">Добавление ограничения (<code>ALTER TABLE</code>)</h4>
<div class="paragraph">
<p>Для добавления ограничения используется синтаксис ограничения таблицы. <strong>Например:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE products ADD CHECK (name &lt;&gt; '');

ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);

ALTER TABLE products ADD FOREIGN KEY (product_group_id)
REFERENCES product_groups;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы добавить ограничение <code>NOT NULL</code>, которое нельзя записать в виде ограничения таблицы,  используется такой синтаксис:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ограничение проходит проверку автоматически и будет добавлено, только если ему  удовлетворяют данные таблицы.</p>
</div>
</div>
<div class="sect3">
<h4 id="_удаление_ограничения_drop_constraint">Удаление ограничения (<code>DROP CONSTRAINT</code>)</h4>
<div class="paragraph">
<p>Для удаления ограничения необходимо знать его имя. Если ранее ограничению не присваивали имя, это  неявно сделала система, и необходимо выяснить его. Здесь может быть полезна команда <code>psql \d имя_таблицы</code> (или другие программы, показывающие подробную информацию о таблицах). Зная
имя, можно использовать команду:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE products DROP CONSTRAINT some_name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Как и при удалении столбца необходимо удалить ограничение с зависимыми объектами,  добавьте указание <code>CASCADE</code>. Примером такой зависимости может быть ограничение внешнего  ключа, связанное со столбцами ограничения первичного ключа. Так можно удалить ограничения любых типов, кроме <code>NOT NULL</code>.</p>
</div>
<div class="paragraph">
<p>Чтобы удалить ограничение <code>NOT NULL</code>, используйте команду:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_права_доступа">Права доступа</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Когда в базе данных создаётся объект, ему назначается владелец. Владельцем обычно становится роль, с которой был выполнен оператор создания. Для большинства типов объектов в исходном состоянии только владелец (или суперпользователь) может делать с объектом всё что угодно. Чтобы разрешить использовать его другим ролям, нужно дать им права.</p>
</div>
<div class="sect2">
<h3 id="_добавление_нового_пользователя">Добавление нового пользователя</h3>
<div class="paragraph">
<p>Если в базе данных не существует пользователя, его можно создать следующим образом:</p>
</div>
<div class="listingblock">
<div class="title">Создание пользователя</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE USER user-name WITH PASSWORD 'password';</code></pre>
</div>
</div>
<div class="paragraph">
<p>где в таблице</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>user-name</code> - логин пользователя базы данных.</p>
</li>
<li>
<p><code>password</code> - пароль нового пользователя.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>На этом этапе новый пользователь не имеет никаких разрешений на работу с базами данных. Он не может войти в систему, поэтому нужно предоставить ему неограниченные права доступа, выполнить это можно через следующий запрос.</p>
</div>
<div class="sect3">
<h4 id="_присвоение_прав_доступа_grant">Присвоение прав доступа (<code>GRANT</code>)</h4>
<div class="listingblock">
<div class="title">Предоставление пользователю неограниченные права доступа</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">GRANT ALL PRIVILEGES ON table_name TO user-name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь пользователь получил новые права и может работать с базой данных.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_настройка_прав_доступа_для_пользователей">Настройка прав доступа для пользователей</h3>
<div class="paragraph">
<p>Предоставить другой уровень доступа к базам данных для пользователя возможно через следующую команду:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">GRANT [тип прав] ON [имя базы данных].[имя таблицы] TO user-name [ WITH GRANT OPTION ];</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если указано <code>WITH GRANT OPTION</code>, получатель права, в свою очередь, может давать его другим. Без  этого указания распоряжаться своим правом он не сможет. Группе <code>PUBLIC</code> право передачи права  дать нельзя.</p>
</div>
<div class="paragraph">
<p>В <strong>PostgreSQL</strong> права доступа бывают несколько типов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ALL PRIVILEGES</code> – даёт пользователю полный доступ к заданной базе данных (если база данных не указана, то ко всем);</p>
</li>
<li>
<p><code>CREATE</code> – позволяет пользователю создавать базы данных/таблицы;</p>
</li>
<li>
<p><code>SELECT</code> – позволяет пользователю делать выборку данных;</p>
</li>
<li>
<p><code>INSERT</code> – позволяет пользователю добавлять новые записи в таблицы;</p>
</li>
<li>
<p><code>UPDATE</code> – позволяет пользователю изменять существующие записи в таблицах;</p>
</li>
<li>
<p><code>DELETE</code> – позволяет пользователю удалять записи из таблиц;</p>
</li>
<li>
<p><code>DROP</code> – позволяет пользователю удалять записи в базе данных/таблицах;</p>
</li>
<li>
<p><code>TRIGGER</code> - создание триггеров;</p>
</li>
<li>
<p><code>TRUNCATE</code> - очистка таблицы;</p>
</li>
<li>
<p><code>USAGE</code> - право на использование последовательностей и использовать объекты в конкретной схеме;</p>
</li>
<li>
<p><code>REFERENCES</code> - право ссылаться на таблицу;</p>
</li>
<li>
<p><code>CONNECT</code> - право на подключение к базе данных</p>
</li>
<li>
<p><code>TEMPORARY</code> - разрешает создавать в базе данных временные таблицы;</p>
</li>
<li>
<p><code>EXECUTE</code> - право на использование функции.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Право удалять объект или изменять его определение произвольным образом не считается назначаемым, оно неотъемлемо связано с владельцем, так что отозвать это право или дать его кому-то другому нельзя.</strong></p>
</div>
<div class="paragraph">
<p>Если необходимо назначить несколько видов прав доступа, можно разделить их запятыми, как в команде:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">GRANT UPDATE, DELETE ON table_name TO user-name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если необходимо забрать у пользователя права доступа:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">REVOKE [тип прав] ON [имя базы данных].[имя таблицы] FROM user-name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если необходимо отменить все привилегии у пользователя, введите команду:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">REVOKE ALL PRIVILEGES ON table_name FROM user-name;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_удаление_пользователей">Удаление пользователей</h4>
<div class="paragraph">
<p>Если на роль есть ссылки в какой-либо базе данных в кластере, возникнет ошибка и роль не будет удалена. Прежде чем удалять роль, необходимо удалить все принадлежащие ей объекты, а также лишить её данных ей прав для других объектов.</p>
</div>
<div class="paragraph">
<p>Удалить пользователя можно следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP ROLE user-name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>или</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP USER user-name;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DROP USER</code> — просто альтернативное написание команды <code>DROP ROLE</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_изменение_роли_в_базе_alter_role">Изменение роли в базе (<code>ALTER ROLE</code>)</h4>
<div class="paragraph">
<p>Изменение пароля пользователя:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER ROLE user_name WITH PASSWORD 'hu8jmn3';</code></pre>
</div>
</div>
<div class="paragraph">
<p>Удаление пароля пользователя:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER ROLE user_name WITH PASSWORD NULL;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Переименовать пользователя:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER ROLE user1 RENAME TO user2;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_виды_ролей">Виды ролей</h3>
<div class="sect3">
<h4 id="_суперпользователи">Суперпользователи</h4>
<div class="paragraph">
<p><strong>Суперпользователи</strong> –  имеют полный доступ ко всем объектам (проверки не выполняются).</p>
</div>
</div>
<div class="sect3">
<h4 id="_владельцы">Владельцы</h4>
<div class="paragraph">
<p><strong>Владельцы</strong> – владельцем становиться тот, кто создал объект. Но право владения можно передать. Владелец имеет все привилегии на принадлежащий ему объект. Также создатель объекта обладает правом удалять его, и это право у него нельзя отнять.</p>
</div>
</div>
<div class="sect3">
<h4 id="_псевдо_роль_public">Псевдо роль public</h4>
<div class="paragraph">
<p>Псевдороль <code>public</code> не видна, но про неё следует знать. Это групповая роль, в которую включены все остальные  роли. Это означает, что все роли по умолчанию будут иметь привилегии наследуемые от <code>public</code>. Поэтому иногда у <code>public</code> отбирают некоторые привилегии, чтобы отнять их у всех пользователей.</p>
</div>
<div class="paragraph">
<p>Роль <code>public</code> по умолчанию имеет следующие привилегии для всех баз данных:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CONNECT</code> – это означает что любая созданная роль сможет подключаться к базам данных;</p>
</li>
<li>
<p><code>TEMPORARY</code> – любая созданная роль сможет создавать временные объекты во всех база данных и объекты эти могут быть любого размера;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>для схемы <code>public</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CREATE</code> (создание объектов) – любая роль может создавать объекты в этой схеме;</p>
</li>
<li>
<p><code>USAGE</code> (доступ к объектам) – любая роль может использовать объекты в этой схеме;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>для всех функций:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>EXECUTE</code> (выполнение) – любая роль может выполнять любую функцию. Ещё нужны ещё права <code>USAGE</code> на ту схему, в которой функция находится, и права к объектам к которым обращается функция. Это сделано для удобства, но снижает безопасность сервера баз данных.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-10-23 04:30:52 UTC
</div>
</div>
</body>
</html>