<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<title>SQL</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;-webkit-tap-highlight-color:transparent}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
<h1>SQL</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_основные_понятия_sql">Основные понятия SQL</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>SQL</strong> - это язык структурированных запросов, с помощью которого можно обрабатывать и извлекать данные из реляционных баз данных.</p>
</div>
<div class="paragraph">
<p><strong>SQL</strong> (<strong>Structured Query Language</strong> — <strong>язык структурированных запросов</strong>) - это непроцедурный язык программирования, используемый для работы с информацией реляционной базы данных, которая управляется соответствующей <strong>системой управления базами данных</strong> (<strong>СУБД</strong>).</p>
</div>
<div class="paragraph">
<p>Первоначально SQL был основным средством доступа пользователя к информации базы данных и позволял выполнять следующие операции с таблицами <strong>БД</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>создание новой таблицы;</p>
</li>
<li>
<p>добавление записей в таблицу;</p>
</li>
<li>
<p>изменение содержимого записей;</p>
</li>
<li>
<p>удаление записей из таблицы;</p>
</li>
<li>
<p>чтение записей из одной или нескольких таблиц;</p>
</li>
<li>
<p>изменение структур таблиц.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>По мере развития <strong>СУБД</strong> <strong>SQL</strong> усложнился и обогатился новыми конструкциями типа индексы, представления, триггеры, хранимые процедуры — и стал приобретать черты, свойственные языкам программирования.
Изначально <strong>SQL</strong> создавался как простой стандартизированный язык извлечения и управления данными, содержащимися в реляционной <strong>СУБД</strong>.
Но со временем он усложнился настолько, что превратился в инструмент разработчика, а не конечного пользователя.</p>
</div>
<div class="paragraph">
<p>Таким образом использование <strong>SQL</strong> сводится, по сути, к формированию всевозможных выборок строк и совершению операций над всеми записями, входящими в набор.</p>
</div>
<div class="paragraph">
<p><strong>SQL</strong> состоит из четырех отдельных частей (иногда разделяют на 5 частей):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>DDL</strong> (<strong>Data Definition Language</strong>) - язык определения данных; используется для определения структур хранящихся в <strong>БД</strong> данных.
Операторы <strong>DDL</strong> позволяют создавать, изменять и удалять объекты в <strong>БД</strong>.
Допустимые типы объектов зависят от используемой <strong>СУБД</strong> и обычно включают базы данных, пользователей, таблицы, представления, хранимые процедуры и ряд более вспомогательных объектов типа роли и индексы. <strong>Операторы DDL</strong>:</p>
<div class="ulist">
<ul>
<li>
<p><code>CREATE SCHEMA</code> - создать схему БД</p>
</li>
<li>
<p><code>DROP SHEMA</code> - удалить схему БД;</p>
</li>
<li>
<p><code>CREATE TABLE</code> - создать таблицу;</p>
</li>
<li>
<p><code>ALTER TABLE</code> - изменить структуру таблицы;</p>
</li>
<li>
<p><code>DROP TABLE</code> - удалить таблицу;</p>
</li>
<li>
<p><code>CREATE DATABASE</code> - создать базу данных;</p>
</li>
<li>
<p><code>DROP DATABASE</code> - удалить базу данных;</p>
</li>
<li>
<p><code>CREATE SEQUENCE</code> - создать последовательность;</p>
</li>
<li>
<p><code>DROP SEQUENCE</code> - удалить последовательность;</p>
</li>
<li>
<p><code>CREATE VIEW</code> - создать представление;</p>
</li>
<li>
<p><code>DROP VIEW</code> - удалить представление;</p>
</li>
<li>
<p><code>CREATE INDEX</code> - создать индекс;</p>
</li>
<li>
<p><code>DROP INDEX</code> - удалить индекс;</p>
</li>
<li>
<p><code>CREATE CONSTRAINT</code> - создать ограничение (<strong>Primary Key</strong>, <strong>Foreign Key</strong>);</p>
</li>
<li>
<p><code>DROP CONSTRAINT</code> - удалить ограничение (<strong>Primary Key</strong>, <strong>Foreign Key</strong>).</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>DML</strong> (<strong>Data Manipulation Language</strong>) - язык манипуляции данными; используется для извлечения, вставки, изменения и удаления данных в таблицах. <strong>Операторы DML</strong>:</p>
<div class="ulist">
<ul>
<li>
<p><code>SELECT</code> - чтение инфомации (из одной или нескольких таблиц);</p>
</li>
<li>
<p><code>INSERT</code> - добавить строки в таблицу;</p>
</li>
<li>
<p><code>UPDATE</code> - изменить строки в таблице;</p>
</li>
<li>
<p><code>DELETE</code> - удалить строки в таблице;</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>DCL</strong> (<strong>Data Control Language</strong>) - язык определения доступа к данным; используется для контроля доступа к информации БД. Операторы DCL определяют привилегии пользователя и позволяют выдавать и отбирать права на использование DDL и DML определенных операторов к определенным объектам БД. <strong>Операторы DCL</strong>:</p>
<div class="ulist">
<ul>
<li>
<p><code>GRANT</code> - предоставление доступа пользователю или приложению на манипулирование объектами;</p>
</li>
<li>
<p><code>DENY</code> — явный запрет доступа для пользователя;</p>
</li>
<li>
<p><code>REVOKE</code> - отмена запрета или разрешения пользователя.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>TCL</strong> (<strong>Transaction Control Language</strong>) - язык управления транзакциями; используется для контроля обработки транзакций в БД. Операторы TCL включают, как правило, оператор commit для сохранения изменений, сделанных в ходе транзакции, и rollback для их отмены.
Оператор savepoint можно использовать для разбиения транзакции на несколько частей, и, в зависимости от определенных условий, часть из них "откатить". <strong>Операторы TCL</strong>:</p>
<div class="ulist">
<ul>
<li>
<p><code>BEGIN TRANSACTION</code> — начать транзакцию;</p>
</li>
<li>
<p><code>COMMIT</code> - зафиксировать внесенные изменения;</p>
</li>
<li>
<p><code>ROLLBACK</code> - откатить внесенные изменения.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Необходимо отметить, что SQL реализует декларативную парадигму программирования: с помощью данного языка пользователь описывает запрос, а СУБД принимает решение, как этот запрос выполнить, т.е. планирует элементарные операции, необходимые для выполнения данного запроса.</p>
</div>
<div class="sect2">
<h3 id="_create_database_and_schema">Create Database and Schema</h3>
<div class="paragraph">
<p><strong>Схема</strong>/<strong>Schema</strong> с точки зрения <strong>базы данных</strong> представляет собой контейнер объектов типа таблиц, триггеров, хранимых процедур и т.п. Но стоит рассмотреть некоторые особенности для следующих <strong>СУБД</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>PostgreSQL</strong>: <strong>Schema</strong> создается внутри объекта <strong>Database</strong>. <em>Сервер может управлять несколькими базами данных, каждая из которых может включать несколько схем</em>. То есть, <em>схема не связана с учетной записью пользователя</em>.</p>
</li>
<li>
<p><strong>MariaDB</strong>: понятие <strong>Schema</strong> имеет тождественный смысл с <strong>Database</strong>. <em>*База данных* (<strong>Database</strong>) является контейнером объектов, к которым пользователь получает доступ</em>.</p>
</li>
<li>
<p><strong>SQL Server</strong>: в Microsoft SQL Server начиная с версии 2005 <em>жесткая связь между пользователями и схемами была отменена</em>. <em>Пользователи могут получить доступ на выполнение определенных операций с объектами схемы: чтение, запись, обновление или выполнение</em>.</p>
</li>
<li>
<p><strong>Oracle® Database</strong>: <em>*Schema* привязывается к пользователю</em>, т.е. наименование схемы, как правило, является учетной записью пользователя. <em>*Схема* создается при создании пользователем первого объекта, и все последующие объекты созданные этим пользователем становятся частью этой схемы</em>. Кроме этого <em>Oracle позволяет создавать <strong>схему</strong> как контейнер одновременно с объектами <strong>базы данных</strong></em>.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_оператор_create_database">Оператор <code>CREATE DATABASE</code></h4>
<div class="paragraph">
<p>Оператор <code>CREATE DATABASE</code> используется для создания новой базы данных SQL.</p>
</div>
<div class="paragraph">
<p><strong>Синтаксис:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE DATABASE databasename;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Пример</strong>, следующий оператор SQL создает базу данных с именем <code>invoice</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE DATABASE invoice;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_оператор_drop_database">Оператор <code>DROP DATABASE</code></h4>
<div class="paragraph">
<p>Оператор <code>DROP DATABASE</code> используется для удаления существующей базы данных SQL.</p>
</div>
<div class="paragraph">
<p><strong>Синтаксис:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP DATABASE databasename;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Пример</strong>, следующий оператор SQL уничтожает существующую базу данных <code>info</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP DATABASE info;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_типы_данных">Типы данных</h3>
<div class="paragraph">
<p><strong>Тип данных</strong> — это атрибут, который определяет тип любого объекта. <strong>SQL</strong> предлагает шесть категорий типов данных для использования.</p>
</div>
<div class="sect3">
<h4 id="_точные_типы_числовых_данных">Точные типы числовых данных</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Тип данных</th>
<th class="tableblock halign-left valign-top">Возможные значения</th>
<th class="tableblock halign-left valign-top">Примечание</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bit</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code> или <code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Фактически является аналогом булевого типа в языках программирования. Занимает 1 байт.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TINYINT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">От <code>0</code> до <code>255</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Занимает 1 байт. Хорошо подходит для хранения небольших чисел.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SMALLINT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">От <code>–32 768</code> до <code>32 767</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Занимает 2 байта</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>INT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">От <code>–2 147 483 648</code> до <code>2 147 483 647</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Занимает 4 байта. Наиболее используемый тип для хранения чисел.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BIGINT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">От <code>-9 223 372 036 854 775 808</code> до <code>9 223 372 036 854 775 807</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Занимают в памяти 8 байт.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DECIMAL</code></p></td>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock">Хранит числа с фиксированной точностью. Занимает от 5 до 17 байт в зависимости от количества чисел после запятой. Данный тип может принимать два параметра <code>precision</code> и <code>scale</code>: <code>DECIMAL(precision, scale)</code>. Параметр <code>precision</code> представляет максимальное количество цифр, которые может хранить число. Это значение должно находиться в диапазоне от <code>1</code> до <code>38</code>. По умолчанию оно равно <code>18</code>. Параметр <code>scale</code> представляет максимальное количество цифр, которые может содержать число после запятой. Это значение должно находиться в диапазоне от <code>0</code> до значения параметра <code>precision</code>. По умолчанию оно равно <code>0</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MONEY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Дробные значения от <code>-922 337 203 685 477.5808</code> до <code>922 337 203 685 477.5807</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Представляет денежные величины и занимает 8 байт.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SMALLMONEY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Хранит дробные значения от <code>-214 748.3648</code> до <code>214 748.3647</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Предназначено для хранения денежных величин. Занимает 4 байта. Эквивалентен типу <code>DECIMAL(10,4)</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FLOAT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Хранит числа от <code>–1.79E+308</code> до <code>1.79E+308</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Занимает от 4 до 8 байт в зависимости от дробной части.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>REAL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">От <code>–340E+38</code> to <code>3.40E+38</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Занимает 4 байта. Эквивалентен типу <code>FLOAT(24)</code>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Если необходимо получать из базы данных числовое значение в строго указанном формате, то для этого следует выбрать один из точных числовых типов данных.</p>
</div>
</div>
<div class="sect3">
<h4 id="_примерные_типы_числовых_данных">Примерные типы числовых данных</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Тип данных</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возможные значения</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>float</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">От <code>-1.79E + 308</code>, до <code>1.79E + 308</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>real</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">От <code>-3.40E + 38</code>, до <code>3.40E + 38</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Некоторые числа нельзя точно представить в десятичном виде с ограниченным числом знаков, например, одну треть или число пи. Для записи таких чисел используются действительный (<code>real</code>) или плавающий (<code>float</code>) типы данных. Данные действительного типа хранятся с точностью от 1 до 7 знаков. Плавающий формат, который иногда называют еще форматом двойной точности, может хранить числа, содержащие от 8 до 15 значащих цифр. Действительный и плавающий типы данных применяются в научных приложениях для хранения чисел, не требующих точного двоичного выражения. Одна-две последние цифры могут не вполне точно сохраняться при преобразованиях в двоичный формат.</p>
</div>
</div>
<div class="sect3">
<h4 id="_типы_данных_даты_и_времени">Типы данных даты и времени</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Тип данных</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Примечание</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>datetime</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">От <code>1 января 1753</code>, до <code>31 декабря, 9999</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>smalldatetime</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">От <code>1 января 1900</code>, до <code>6 июня 2079</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>date</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Сохраняет дату, как <code>30 июня 1991 года</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>time</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Сохраняет время суток, как <code>12:30</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Для дат применяются два типа данных, <code>datetime</code> и <code>smalldatetime</code>. Тип данных <code>smalldatetime</code> охватывает период времени от 1 января 1900 года до 6 июня 2079 года и включает время с точностью до минуты. Такого диапазона достаточно для подавляющего большинства проектов. Тип данных <code>datetime</code> годен для использования до 31 декабря 9999 года (это следует учитывать при решении проблемы 10К года).</p>
</div>
</div>
<div class="sect3">
<h4 id="_типы_данных_символьных_строк">Типы данных символьных строк</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Тип данных</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возможные значения</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>char</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Максимальная длина 8000 символов. (Фиксированная длина без Unicode символов)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>varchar</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Максимум 8000 символов. (Переменная длина данных не-Unicode).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>text</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Переменная длина данных, не Unicode с максимальной длиной 2147483647 символов.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>К этому типу относятся такие символьные данные, как имена или адреса. Можно выбрать символьный тип данных либо фиксированной длины, <code>char</code>, либо переменной длины, <code>varchar</code>. Фиксированный размер оказывается предпочтительным в тех случаях, когда данные имеют одинаковую или сходную длину, например, при вводе идентификатора автора (часто в этом качестве используют индивидуальный номер системы социальной безопасности). В большинстве ситуаций применение переменной длины данных не приводит к сколько-нибудь заметному увеличению времени обработки. В то же время фамилия автора может быть очень длинной, так что использование типа <code>varchar</code> оказывается вполне оправданным. Применительно к подавляющему большинству фамилий фиксированная длина поля означает потерю значительного объема памяти, поэтому лучше использовать тип данных varchar. При выборе того или иного типа данных всегда следует искать компромисс с учетом двух аспектов: с одной стороны, потери полезного объема памяти при использовании данных фиксированной длины, а с другой стороны, увеличения времени обработки в случае применения данных переменной длины.</p>
</div>
</div>
<div class="sect3">
<h4 id="_типы_строк_данных_символов_unicode">Типы строк данных символов Unicode</h4>
<div class="paragraph">
<p><strong>Юникод</strong> (англ. <strong>Unicode</strong>) — стандарт кодирования символов, включающий в себя знаки почти всех письменных языков мира.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Тип данных</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возможные значения</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>nchar</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Максимальная длина 4000 символов. (Фиксированная длина Unicode)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>nvarchar</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Максимальная длина 4000 символов. (Переменная длина Unicode)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>nvarchar(max)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Максимальная длина 231 символов (SQL Server 2005). (Переменная длина Unicode)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ntext</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Максимальная длина 1,073,741,823 символа. (Переменная длина Unicode)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>SQL Server 7.0 поддерживает набор символов Unicode.
В связи с этим, чтобы воспользоваться всеми преимуществами, предоставляемыми расширенными возможностями Unicode, необходимо было ввести дополнительный тип данных. Если необходимо использовать символьные данные Unicode, то следует указать тип данных <code>Nchar</code> или, если это информация переменной длины, то <code>Nvarchar</code>. При вводе данных Unicode их следует заключать в одиночные кавычки, причем непосредственно перед ними необходимо поставить заглавную латинскую букву N. Ограничение максимальной длины информации при работе с типом данных Unicode составляет 4000 знаков. Это объясняется тем, что для хранения каждого символа Unicode требуется два байта памяти. Поэтому на стандартную страницу памяти размером 8К можно поместить в два раза меньше символов Unicode, чем при использовании обычных символов.</p>
</div>
</div>
<div class="sect3">
<h4 id="_двоичные_типы_данных">Двоичные типы данных</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Тип данных</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возможные значения</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>binary</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Максимальная длина 8000 байт (фиксированная длина двоичных данных)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>varbinary</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Максимальная длина 8000 байт.(Переменная длина двоичных данных)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>varbinary(max)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Максимальная длина 231 байт (SQL Server 2005).(Переменная длина двоичных данных)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>image</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Максимальная длина 2147483647 байт.(Переменная длина двоичных данных)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Если в базе данных необходимо хранить двоичную информацию, имеется выбор между двумя форматами представления: с фиксированной или переменной длиной. Данным фиксированной длины соответствует тип данных <code>binary</code>, а двоичным данным переменной длины соответствует тип данных <code>varbinary</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_таблицы">Таблицы</h3>
<div class="sect3">
<h4 id="_создание_таблицы_create_table">Создание таблицы <code>CREATE TABLE</code></h4>
<div class="paragraph">
<p>Для того чтобы создать таблицу в <strong>SQL</strong>, используется выражение <code>CREATE TABLE</code>. Оно принимает в качестве параметров все колонки, которые необходимо внести, а также их типы данных. Пример создания таблицы с названием <code>Months</code>, в которой будет три колонки:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>id</code> - порядковый номер месяца (целочисленный тип или <code>int</code>).</p>
</li>
<li>
<p><code>name</code> - название месяца.</p>
</li>
<li>
<p><code>days</code> - число дней в конкретном месяце.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Код создания будет выглядеть следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE months (id int, name varchar(10), days int);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_запрос_drop_table">Запрос <code>DROP TABLE</code></h4>
<div class="paragraph">
<p>Оператор <code>DROP TABLE</code> используется для удаления существующей таблицы в базе данных.</p>
</div>
<div class="paragraph">
<p><strong>Синтаксис:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP TABLE table_name;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_удаление_таблиц_при_помощи_truncate">Удаление таблиц при помощи <code>TRUNCATE</code></h4>
<div class="paragraph">
<p>Если необходимо все данные из таблицы, но при этом оставить саму таблицу, следует использовать команду <code>TRUNCATE</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">TRUNCATE TABLE table_name;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ограничения">Ограничения</h3>
<div class="paragraph">
<p><strong>Ограничения</strong> могут быть указаны при создании таблицы с помощью оператора <code>CREATE TABLE</code> или после создания таблицы с помощью инструкции <code>ALTER TABLE</code>.</p>
</div>
<div class="paragraph">
<p><strong>Синтаксис:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE table_name (
    column1 datatype constraint,
    column2 datatype constraint,
    column3 datatype constraint,
    ....
);</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>SQL-ограничения</strong> используются для указания правил данных таблицы, для ограничения типа данных, которые могут входить в таблицу. Это обеспечивает точность и надежность данных в таблице. Если между ограничением и действием данных существует какое-либо нарушение, действие прерывается.</p>
</div>
<div class="paragraph">
<p>Ограничения могут быть уровнями столбцов или таблиц. Ограничения уровня столбца применяются к столбцу, а ограничения уровня таблиц относятся ко всей таблице.</p>
</div>
<div class="paragraph">
<p>В SQL обычно используются следующие ограничения:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>NOT NULL</code> - гарантирует, что столбец не может иметь значение NULL</p>
</li>
<li>
<p><code>UNIQUE</code> - обеспечивает, чтобы все значения в столбце были разными</p>
</li>
<li>
<p><code>PRIMARY KEY</code> - комбинация NOT NULL и UNIQUE. Уникально идентифицирует каждую строку в таблице</p>
</li>
<li>
<p><code>FOREIGN KEY</code> - однозначно идентифицирует строку / запись в другой таблице</p>
</li>
<li>
<p><code>CHECK</code> - обеспечивает, чтобы все значения в столбце удовлетворяли конкретному условию</p>
</li>
<li>
<p><code>DEFAULT</code> - устанавливает значение по умолчанию для столбца, если не указано значение</p>
</li>
<li>
<p><code>INDEX</code> - используется для быстрого создания и извлечения данных из базы данных</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_ограничение_not_null">Ограничение <code>NOT NULL</code></h4>
<div class="paragraph">
<p>По умолчанию столбец может содержать значения <code>NULL</code>. Ограничение <code>NOT NULL</code> приводит к тому, что столбец НЕ принимает значения <code>NULL</code>. Это приводит к тому, что поле всегда содержит значение, а это означает, что нельзя вставить новую запись или обновить запись без добавления значения в это поле.</p>
</div>
<div class="paragraph">
<p>Следующий SQL-запрос гарантирует, что столбцы <code>user_id</code>, <code>name</code> и <code>fullname</code> НЕ будут принимать значения <code>NULL</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE users
(
    user_id int NOT NULL,
    name varchar(255) NOT NULL,
    fullname varchar(255) NOT NULL,
    balanse int
);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ограничение_unique">Ограничение <code>UNIQUE</code></h4>
<div class="paragraph">
<p>Ограничение <code>UNIQUE</code> гарантирует, что все значения в столбце отличаются. Ограничения <code>UNIQUE</code> и <code>PRIMARY KEY</code> гарантируют уникальность столбца или набора столбцов. Ограничение <code>PRIMARY KEY</code> автоматически имеет ограничение <code>UNIQUE</code>.</p>
</div>
<div class="paragraph">
<p>Однако для каждой таблицы может быть множество ограничений <code>UNIQUE</code>, но только одно ограничение <code>PRIMARY KEY</code> для каждой таблицы.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE users
(
    user_id int NOT NULL,
    name varchar(255) NOT NULL,
    fullname varchar(255),
    gender int,
    UNIQUE (user_id)
);</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_создание_ограничения_unique_когда_таблица_уже_создана">Создание ограничения <code>UNIQUE</code> когда таблица уже создана</h5>
<div class="paragraph">
<p>Чтобы создать ограничение <code>UNIQUE</code> в столбце <code>user_id</code>, когда таблица уже создана, используйте следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE users
ADD UNIQUE (user_id);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы назвать ограничение <code>UNIQUE</code> и определить ограничение <code>UNIQUE</code> для нескольких столбцов, используйте следующий синтаксис:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE users
ADD CONSTRAINT UC_Users UNIQUE (user_id, name);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_удаление_ограничения_unique">Удаление ограничения <code>UNIQUE</code></h5>
<div class="paragraph">
<p>Чтобы удалить ограничение <code>UNIQUE</code>, используйте следующий SQL-запрос:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE users
DROP INDEX UC_Users;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ограничение_primary_key">Ограничение <code>PRIMARY KEY</code></h4>
<div class="paragraph">
<p>Ограничение <code>PRIMARY KEY</code> однозначно идентифицирует каждую запись в таблице базы данных. Первичные ключи должны содержать <code>UNIQUE</code> значения и не могут содержать значения <code>NULL</code>.
В таблице может быть только один первичный ключ, который может состоять из одного или нескольких полей.</p>
</div>
<div class="sect4">
<h5 id="_создание_primary_key_при_создании_таблицы">Создание <code>PRIMARY KEY</code> при создании таблицы</h5>
<div class="paragraph">
<p>Следующий SQL-запрос создает <code>PRIMARY KEY</code> в столбце <code>user_id</code>, когда создается таблица <code>users</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE users
(
    user_id int NOT NULL,
    name varchar(255) NOT NULL,
    fullname varchar(255),
    gender int,
    PRIMARY KEY (user_id)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы разрешить именовать ограничение <code>PRIMARY KEY</code> и определить ограничение <code>PRIMARY KEY</code> для нескольких столбцов, используйте следующий синтаксис SQL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE users
(
    user_id int NOT NULL,
    name varchar(255) NOT NULL,
    fullname varchar(255),
    gender int,
    CONSTRAINT PK_Users PRIMARY KEY (user_id, name)
);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_создание_ограничения_primary_key_когда_таблица_уже_создана">Создание ограничения <code>PRIMARY KEY</code> когда таблица уже создана</h5>
<div class="paragraph">
<p>Чтобы создать ограничение <code>PRIMARY KEY</code> в столбце <code>user_id</code>, когда таблица уже создана, используйте следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE users
ADD PRIMARY KEY (user_id);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы разрешить именовать ограничение <code>PRIMARY `KEY</code> и определить ограничение <code>PRIMARY KEY</code> для нескольких столбцов, используйте следующий синтаксис:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE users
ADD CONSTRAINT PK_Users PRIMARY KEY (user_id, name);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_удаление_ограничения_primary_key">Удаление ограничения `PRIMARY KEY</h5>
<div class="paragraph">
<p>Чтобы удалить ограничение <code>PRIMARY KEY</code>, используйте следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE users
DROP PRIMARY KEY;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ограничение_foreign_key">Ограничение <code>FOREIGN KEY</code></h4>
<div class="paragraph">
<p><code>FOREIGN KEY</code> - это <strong>ключ</strong>, используемый для соединения двух таблиц вместе. Является полем (или набором полей) в одной таблице, которое ссылается на <code>PRIMARY KEY</code> в другой таблице.</p>
</div>
<div class="paragraph">
<p>Таблица, содержащая внешний ключ, называется дочерней таблицей, а таблица, содержащая ключ-кандидат, называется <strong>ссылочной</strong> или <strong>родительской таблицей</strong>.</p>
</div>
<div class="sect4">
<h5 id="_создание_foreign_key_при_создании_таблицы">Создание <code>FOREIGN KEY</code> при создании таблицы</h5>
<div class="paragraph">
<p>Следующий SQL-запрос создает <code>FOREIGN KEY</code> в столбце <code>user_id</code> при создании таблицы <code>invoice</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE invoice
(
    invoice_id int NOT NULL,
    number int NOT NULL,
    user_id int,
    PRIMARY KEY (invoice_id),
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы разрешить именовать ограничение <code>FOREIGN KEY</code> и определять ограничение <code>FOREIGN KEY</code> для нескольких столбцов, используйте следующий синтаксис SQL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE invoice
(
    invoice_id int NOT NULL,
    number int NOT NULL,
    user_id int,
    PRIMARY KEY (invoice_id),
    CONSTRAINT FK_UserInvoice FOREIGN KEY (user_id)
    REFERENCES Users(user_id)
);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_создание_ограничения_foreign_key_когда_таблица_уже_создана">Создание ограничения <code>FOREIGN KEY</code> когда таблица уже создана</h5>
<div class="paragraph">
<p>Чтобы создать ограничение <code>FOREIGN KEY</code> в столбце <code>user_id</code>, когда таблица <code>invoice</code> уже создана, используйте следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE invoice
ADD FOREIGN KEY (user_id) REFERENCES Users(user_id);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы разрешить именовать ограничение <code>FOREIGN KEY</code> и определять ограничение <code>FOREIGN KEY</code> для нескольких столбцов, используйте следующий синтаксис:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE invoice
ADD CONSTRAINT FK_UsersInvoice
FOREIGN KEY (user_id) REFERENCES Users(user_id);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_удаление_ограничения_foreign_key">Удаление ограничения <code>FOREIGN KEY</code></h5>
<div class="paragraph">
<p>Чтобы удалить ограничение <code>FOREIGN KEY</code>, используйте следующий:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE invoice
DROP FOREIGN KEY FK_UsersInvoice;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ограничение_check">Ограничение <code>CHECK</code></h4>
<div class="paragraph">
<p>Ограничение <code>CHECK</code> используется для ограничения диапазона значений, который может быть помещен в столбец.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Если определяется ограничение <code>CHECK</code> для одного столбца, оно допускает только определенные значения для этого столбца.</p>
</li>
<li>
<p>Если определяется ограничение <code>CHECK</code> для таблицы, оно может ограничить значения в определенных столбцах на основе значений в других столбцах в строке.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_создание_ограничения_check_при_создании_таблицы">Создание ограничения <code>CHECK</code> при создании таблицы</h5>
<div class="paragraph">
<p>Следующий SQL-запрос создает ограничение <code>CHECK</code> в столбце <code>age</code>, когда создается таблица <code>users</code>. Ограничение <code>CHECK</code> гарантирует, не может быть пользователя с возрастом старше 60 лет:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE users
(
    user_id int NOT NULL,
    name varchar(255) NOT NULL,
    fullname varchar(255),
    age int,
    CHECK (age&gt;=60)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы разрешить именовать ограничение <code>CHECK</code> и определить ограничение <code>CHECK</code> для нескольких столбцов, используйте следующий синтаксис SQL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE users
(
    user_id int NOT NULL,
    name varchar(255) NOT NULL,
    fullname varchar(255),
    age int,
    balance int,
    CONSTRAINT CHK_Users CHECK (age&gt;=60 AND balance = 500)
);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_создание_ограничения_check_когда_таблица_уже_создана">Создание ограничения <code>CHECK</code> когда таблица уже создана</h5>
<div class="paragraph">
<p>Чтобы создать ограничение <code>CHECK</code> в столбце <code>age</code>, когда таблица уже создана, используйте следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE users
ADD CHECK (age&gt;=60);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы разрешить именовать ограничение <code>CHECK</code> и определить ограничение <code>CHECK</code> для нескольких столбцов, используйте следующий синтаксис:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE users
ADD CONSTRAINT CHK_UsersAge CHECK (age&gt;=60 AND country='Spain');</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_drop_check"><code>DROP CHECK</code></h5>
<div class="paragraph">
<p>Чтобы удалить ограничение <code>CHECK</code>, используйте следующий SQL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE users
DROP CHECK CHK_UsersAge;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ограничение_default">Ограничение <code>DEFAULT</code></h4>
<div class="paragraph">
<p>Ограничение <code>DEFAULT</code> используется для предоставления значения по умолчанию для столбца. Значение по умолчанию будет добавлено ко всем новым записям, если другое значение не указано.</p>
</div>
<div class="sect4">
<h5 id="_установка_default_столбца_при_создании_таблицы">Установка <code>DEFAULT</code> столбца при создании таблицы</h5>
<div class="paragraph">
<p>Следующий SQL-запрос устанавливает значение <code>DEFAULT</code> для столбца <code>country</code>, когда создается таблица <code>users</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE users
(
    user_id int NOT NULL,
    name varchar(255) NOT NULL,
    fullname varchar(255),
    gender int,
    country varchar(255) DEFAULT 'Spain'
);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_установка_default_столбца_в_уже_созданной_таблице">Установка <code>DEFAULT</code> столбца в уже созданной таблице</h5>
<div class="paragraph">
<p>Чтобы создать ограничение <code>DEFAULT</code> в столбце <code>country</code>, когда таблица уже создана, используйте следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE users
ALTER country SET DEFAULT 'Spain';</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_удаление_ограничения_default">Удаление ограничения <code>DEFAULT</code></h5>
<div class="paragraph">
<p>Чтобы удалить ограничение <code>DEFAULT</code>, используйте следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE users
ALTER country DROP DEFAULT;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_изменение_структуры_таблицы">Изменение структуры таблицы</h3>
<div class="paragraph">
<p>Оператор <code>ALTER TABLE</code> используется для добавления, удаления или изменения столбцов в существующей таблице, а также для добавления и удаления различных ограничений для существующей таблицы.</p>
</div>
<div class="sect3">
<h4 id="_alter_table_add_column"><code>ALTER TABLE - ADD Column</code></h4>
<div class="paragraph">
<p>Чтобы добавить столбец в таблицу, используйте следующий синтаксис:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE table_name
ADD column_name datatype;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_alter_table_drop_column"><code>ALTER TABLE - DROP COLUMN</code></h4>
<div class="paragraph">
<p>Чтобы удалить столбец в таблице, используйте следующий синтаксис, обратите внимание, что некоторые системы баз данных не позволяют удалить столбец:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE table_name
DROP COLUMN column_name;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_alter_table_altermodify_column"><code>ALTER TABLE - ALTER/MODIFY COLUMN</code></h4>
<div class="paragraph">
<p>Чтобы изменить тип данных столбца в таблице, используйте следующий синтаксис:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE table_name
ALTER COLUMN column_name datatype;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE table_name
MODIFY COLUMN column_name datatype;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_изменить_тип_данных">Изменить тип данных</h4>
<div class="paragraph">
<p>Изменим тип данных столбца с именем <code>day_birth</code> в таблице <code>users</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE users
ALTER COLUMN day_birth year;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_пример_drop_column">Пример <code>DROP COLUMN</code></h4>
<div class="paragraph">
<p>Для удаления столбца <code>day_birth</code> в таблице <code>users</code> используется следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE users
DROP COLUMN day_birth;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_однострочные_и_многострочные_комментарии">Однострочные и многострочные комментарии</h3>
<div class="paragraph">
<p>Комментарии используются для пояснения разделов операторов SQL или для предотвращения выполнения операторов во время отладки запросов.</p>
</div>
<div class="sect3">
<h4 id="_однострочные_комментарии">Однострочные комментарии</h4>
<div class="paragraph">
<p>Однострочные комментарии начинаются со знака <code>-</code>. Любой текст между <code>-</code> и концом строки будет проигнорирован (не будет выполнен).</p>
</div>
<div class="paragraph">
<p>В следующем примере в качестве объяснения используется однострочный комментарий:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">-- Select all:
SELECT * FROM users;</code></pre>
</div>
</div>
<div class="paragraph">
<p>В следующем примере используется однострочный комментарий для игнорирования конца строки:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT * FROM users -- WHERE balance = 1000;</code></pre>
</div>
</div>
<div class="paragraph">
<p>В следующем примере используется однострочный комментарий для игнорирования оператора:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">-- SELECT * FROM users
SELECT * FROM users;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_многострочные_комментарии">Многострочные комментарии</h4>
<div class="paragraph">
<p>Многострочные комментарии начинаются с <code>/</code> и заканчиваются на <code>/</code>. Любой текст между <code>/</code> и <code>/</code> будет проигнорирован. В следующем примере в качестве объяснения используется многострочный комментарий:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">/* Этот запрос
выведет данные
всех пользователей */

SELECT * FROM users;</code></pre>
</div>
</div>
<div class="paragraph">
<p>В следующем примере используется многострочный комментарий для игнорирования многих операторов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">/*SELECT * FROM users;
SELECT * FROM product;
SELECT * FROM invoice;*/

SELECT * FROM category;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_манипуляция_данными">Манипуляция данными</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_добавление_записи_в_таблицу_insert_into">Добавление записи в таблицу (<code>INSERT INTO</code>)</h3>
<div class="paragraph">
<p><code>INSERT INTO</code> - этот запрос используется для добавления двумя разными способами новых строк данных в таблицу в базе данных.</p>
</div>
<div class="paragraph">
<p><strong>Способ первый:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">INSERT INTO months
VALUES (1, 'January', 31);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Этот способ не подразумевает указания названий колонок, а лишь принимает значения в том порядке, в котором они указаны в таблице. Однако, если в будущем необходимо добавить дополнительные колонки, все предыдущие запросы работать не будут.</p>
</div>
<div class="paragraph">
<p>Для решения данной проблемы следует использовать <strong>второй способ</strong>. Его суть заключается в том, что перед вводом данных указываются названия колонок.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">INSERT INTO months (id, name, days)
VALUES (2, 'February', 29);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_выборка_записей_из_таблицы_select">Выборка записей из таблицы (<code>SELECT</code>)</h3>
<div class="sect3">
<h4 id="_простая_выборка_select">Простая выборка (<code>SELECT</code>)</h4>
<div class="paragraph">
<p><code>SELECT</code> - используется для выбора данных из базы данных. Возвращаемые данные сохраняются в таблице результатов, называемой результирующим набором.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM characters;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Результатом данного запроса будет таблица со всеми данными в таблице <code>characters</code>. Знак звёздочки (<code>*</code>) означает то, что необходимо показать все столбцы из таблицы без исключений. Так как в базе данных обычно больше одной таблицы, нам необходимо указывать название таблицы, данные из которой требуется посмотреть. Сделать это можно используя ключевое слово <code>FROM</code>.</p>
</div>
<div class="paragraph">
<p>Когда необходимы лишь некоторые столбцы из таблицы, то можно указать их имена через запятую вместо звёздочки.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT name, weapon
FROM characters;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_выборка_уникальных_select_distinct">Выборка уникальных (<code>SELECT DISTINCT</code>)</h4>
<div class="paragraph">
<p>Оператор <code>SELECT DISTINCT</code> используется для возврата только отдельных (разных) значений. Внутри таблицы столбец часто содержит много повторяющихся значений и вам нужно только перечислить отличающиеся значения.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT DISTINCT column1, column2, ...
FROM table_name;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Пример</strong>, следующий оператор SQL выбирает только значения <code>DISTINCT</code> из столбца <code>name</code> в таблице <code>users</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT DISTINCT name
FROM users;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Пример</strong>, следующий оператор SQL выбирает только значения <code>DISTINCT</code> по столбцам <code>name</code>, <code>age</code> в таблице <code>users</code>, т.е. уникальное сочетание <code>name</code> + <code>age</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT DISTINCT name, age
FROM users;</code></pre>
</div>
</div>
<div class="paragraph">
<p>В следующем SQL-заявлении указано количество разных имен пользователей:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT COUNT(DISTINCT name)
FROM users;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_выборка_с_условием_where">Выборка с условием (<code>WHERE</code>)</h3>
<div class="paragraph">
<p><code>WHERE</code> - это запрос позволяющий включить в вывод лишь некоторые конкретные строки. Данное ключевое слово позволяет фильтровать данные по определённому условию.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column1, column2, ...
FROM table_name
WHERE condition;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Пример предложения</strong>, следующий оператор SQL выбирает всех пользователей с именем <code>name</code> в таблице <code>users</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM users
WHERE name = 'Tom';</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Следует отметить, что <strong>SQL</strong> требует одинарных кавычек вокруг текстовых значений (большинство систем баз данных также допускают двойные кавычки). Однако числовые поля не должны быть заключены в кавычки.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_операторы_в_разделе_where">Операторы в разделе <code>WHERE</code></h4>
<div class="paragraph">
<p>Следующие операторы могут использоваться в предложении <code>WHERE</code>:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><strong>Заголовок</strong></th>
<th class="tableblock halign-left valign-top"><strong>Группа</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Равно</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>!=</code> или <code>&lt;&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Не равно</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Больше чем</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Меньше чем</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&gt;=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Больше или равно</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Меньше или равно</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BETWEEN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Между включенным диапазоном</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LIKE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Поиск по шаблону</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Поиск данных по нескольким значениям, перечисленным через запятую</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_операторы_and_or_и_not">Операторы <code>AND</code>, <code>OR</code> и <code>NOT</code></h4>
<div class="paragraph">
<p>Предложение <code>WHERE</code> может быть объединено с операторами <code>AND</code>, <code>OR</code> и <code>NOT</code>. Операторы <code>AND</code> и <code>OR</code> используются для фильтрации записей на основе более чем одного условия:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Оператор <code>AND</code> отображает запись, если все условия, разделенные символом <code>AND</code>, имеют значение <code>true</code>.</p>
</li>
<li>
<p>Оператор <code>OR</code> отображает запись, если любое из условий, разделенных <code>OR</code>, является <code>true</code>.</p>
</li>
<li>
<p>Оператор <code>NOT</code> отображает запись, если условие (и) <strong>false</strong>.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_оператор_and">Оператор <code>AND</code></h5>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column1, column2, ...
FROM table_name
WHERE condition1 AND condition2 AND condition3 ...;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий оператор SQL выбирает все поля из <code>users</code>, где пол <code>gender</code> равен <code>F</code> (<em>Female</em>), а баланс <code>balance</code> больше или равен <code>1000</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM users
WHERE gender = 'F'
  AND balance &gt;= 1000;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_оператор_or">Оператор <code>OR</code></h5>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column1, column2, ...
FROM table_name
WHERE condition1 OR condition2 OR condition3 ...;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий оператор SQL выбирает все поля из <code>users</code>, где баланс пользователя <code>balance</code> равен <code>1000</code> или возраст пользователя <code>age</code> равен <code>25</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT * FROM users
WHERE balance = 1000 OR age = 25;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_оператор_not">Оператор <code>NOT</code></h5>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column1, column2, ...
FROM table_name
WHERE NOT condition;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий оператор SQL выбирает все поля из <code>users</code>, где возраст <code>age</code> не равен <code>30</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM users
WHERE NOT age = 30;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_комбинирование_and_or_и_not">Комбинирование <code>AND</code>, <code>OR</code> и <code>NOT</code></h5>
<div class="paragraph">
<p>Также можно комбинировать операторы <code>AND</code>, <code>OR</code> и <code>NOT</code>.</p>
</div>
<div class="paragraph">
<p>Следующий оператор выбирает все поля из <code>users</code>, где возраст <code>age</code> равно <code>30</code>. И баланс <code>balance</code> больше <code>1000</code> или имя <code>name</code> не равно <code>Tom</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM users
WHERE age = 30
  AND (balance &gt; 1000 OR NOT name = 'Tom');</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_выборка_с_сортировкой_результата_order_by">Выборка с сортировкой результата (<code>ORDER BY</code>)</h4>
<div class="paragraph">
<p>Ключевое слово <code>ORDER BY</code> используется для сортировки результирующего набора в порядке возрастания или убывания. По умолчанию оно сортирует записи по возрастанию. Чтобы отсортировать записи в порядке убывания, используйте ключевое слово <code>DESC</code>. Для сортировки по возрастанию, используйте ключевое слово <code>ASC</code>.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column1, column2, ...
FROM table_name
ORDER BY column1, column2, ... ASC|DESC;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий оператор выбирает всех пользователей из таблицы <code>users</code>, отсортированные по столбцу <code>name</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM users
ORDER BY name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>или</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM users
ORDER BY name ASC;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Но <code>ASC</code> избыточен, так как он идет по умолчанию.</p>
</div>
<div class="paragraph">
<p>Следующий оператор выбирает всех пользователей из таблицы <code>users</code>, отсортированные по столбцу <code>name</code> в обратном порядке:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM users
ORDER BY name DESC;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_значение_null">Значение <code>NULL</code></h4>
<div class="paragraph">
<p>Поле со значением <code>NULL</code> является <strong>полем без значения</strong>. Если поле в таблице является необязательным, можно вставить новую запись или обновить запись без добавления значения в это поле. Затем поле будет сохранено со значением <code>NULL</code>. Значение <code>NULL</code> отличается от нулевого значения или поля, содержащего пробелы.</p>
</div>
<div class="sect4">
<h5 id="_как_проверить_значения_null">Как проверить значения <code>NULL</code>?</h5>
<div class="paragraph">
<p>Невозможно проверить значения <code>NULL</code> с операторами сравнения, такими как <code>=</code>, <code>&lt;</code> или <code>!=</code>. Вместо этого нужно использовать операторы <code>IS NULL</code> и <code>IS NOT NULL</code>.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис <code>IS NULL</code></div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column_names
FROM table_name
WHERE column_name IS NULL;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий оператор использует оператор <code>IS NULL</code> для перечисления всех пользователей, у которых нет телефона.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT name, phone
FROM users
WHERE phone IS NULL;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Синтаксис <code>NOT NULL</code></div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column_names
FROM table_name
WHERE column_name IS NOT NULL;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий оператор использует оператор <code>IS NOT NULL</code> для перечисления всех пользователей, у которых есть телефон.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT name, phone
FROM users
WHERE phone IS NOT NULL;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_выборка_с_указанием_количества_записей_в_результате_limit">Выборка с указанием количества записей в результате (<code>LIMIT</code>)</h4>
<div class="paragraph">
<p>Предложение <code>SELECT &#8230;&#8203; LIMIT</code> используется для указания количества возвращаемых записей. Оно полезно для больших таблиц с тысячами записей. Возвращение большого количества записей может повлиять на производительность.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column_name(s)
FROM table_name
WHERE condition
LIMIT number;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_примеры_top_limit_и_rownum">Примеры <code>TOP</code>, <code>LIMIT</code> и <code>ROWNUM</code></h4>
<div class="paragraph">
<p>Следующий оператор показывает эквивалентный пример, используя предложение <code>LIMIT</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM users
LIMIT 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий оператор показывает эквивалентный пример, используя предложение <code>LIMIT</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM users
WHERE balance = 1000
LIMIT 5;</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<code>TOP</code>, <code>ROWNUM</code> - не входят в стандарт <strong>SQL</strong>, это dialect для <strong>СУБД</strong> Oracle. Поэтому они не будут работать например для <strong>PostgreSQL</strong>, <strong>MariaDB</strong>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Следующий оператор выбирает первые три записи из таблицы <code>users</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT TOP 3 *
FROM users;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий оператор показывает эквивалентный пример с использованием <code>ROWNUM</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM users
WHERE ROWNUM &lt;= 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий оператор выбирает <strong>первые 25% записей</strong> из таблицы <code>users</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT TOP 25 PERCENT *
FROM users;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий оператор выбирает первые 5 записи из таблицы <code>users</code>, где баланс <code>balance</code> равен <code>1000</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT TOP 5 *
FROM users
WHERE balance = 1000;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий оператор показывает эквивалентный пример с использованием <code>ROWNUM</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT * FROM users
WHERE balance = 1000 AND ROWNUM &lt;= 5;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_выборка_по_заданному_шаблону_like">Выборка по заданному шаблону (<code>LIKE</code>)</h4>
<div class="paragraph">
<p>Оператор <code>LIKE</code> используется в предложении <code>WHERE</code> для поиска заданного шаблона в столбце.</p>
</div>
<div class="paragraph">
<p>В сочетании с оператором <code>LIKE</code> используются два подстановочных знака:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>%</code> - знак процента представляет нулевой, один или несколько символов</p>
</li>
<li>
<p><code>_</code> - подчеркнутый символ представляет собой один символ</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column1, column2, ...
FROM table_name
WHERE columnN LIKE pattern;</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Выражение</th>
<th class="tableblock halign-left valign-top">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WHERE name LIKE 'text%'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Находит любые значения, начинающиеся с <code>text</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WHERE name LIKE '%text'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Находит любые значения, заканчивающиеся на <code>text</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WHERE name LIKE '%text%'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Находит любые значения, которые имеют <code>text</code> в любой позиции</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WHERE name LIKE '_text%'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Находит любые значения, которые имеют <code>text</code> во второй позиции</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WHERE name LIKE 'text_%_%'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Находит любые значения, начинающиеся с <code>text</code> и длиной не менее 3 символов</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WHERE name LIKE 'text%data'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Находит любые значения, начинающиеся с <code>text</code> и заканчивающиеся на <code>data</code></p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="_подстановочные_знаки">Подстановочные знаки</h5>
<div class="paragraph">
<p>Символ подстановки используется для замены любого другого символа в строке. Подстановочные символы используются с оператором <code>LIKE</code>. Оператор <code>LIKE</code> используется в предложении <code>WHERE</code> для поиска заданного шаблона в столбце.</p>
</div>
<div class="sect5">
<h6 id="_использование_подстановочного_знака">Использование подстановочного знака</h6>
<div class="paragraph">
<p>Следующий оператор SQL выбирает всех пользователей с <code>name</code>, начиная с любого символа, за которым следует <code>о</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM users
WHERE name LIKE '_o';</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий оператор выбирает всех пользователей с <code>name</code> начиная с <code>B</code>, за которыми, следует любой символ. А за ним следует <code>l</code>, за которым следует любой символ, а затем <code>y</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM users
WHERE name LIKE 'B_l_y';</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Подстановочные знаки <code>[charlist]</code> и <code>[!charlist]</code> - не входят в стандарт <strong>SQL</strong>, это dialect для <strong>СУБД</strong> Oracle. Поэтому они не будут работать например для <strong>PostgreSQL</strong>, <strong>MariaDB</strong>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_использование_подстановочного_знака_charlist">Использование подстановочного знака <code>[charlist]</code></h6>
<div class="paragraph">
<p>Следующий оператор SQL выбирает всех пользователей с name, начиная с <code>Т</code>, <code>Р</code> или <code>Е</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM users
WHERE name LIKE '[ТРЕ]%';</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий оператор SQL выбирает всех пользователей с <code>name</code>, начиная с <code>Т</code>, <code>Р</code> или <code>Е</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM users
WHERE name LIKE '[Т-E]%';</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_использование_подстановочного_знака_charlist_2">Использование подстановочного знака <code>[!charlist]</code></h6>
<div class="paragraph">
<p>Два следующих оператора SQL выбирают всех пользователей с помощью <code>name NOT</code>, начинающегося с <code>Т</code>, <code>Р</code> или <code>E</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM users
WHERE name LIKE '[!ТРЕ]%';</code></pre>
</div>
</div>
<div class="paragraph">
<p>Или:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM users
WHERE name NOT LIKE '[ТРЕ]%';</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_выборка_с_проверкой_на_вхождение_в_множество_in">Выборка с проверкой на вхождение в множество (<code>IN</code>)</h4>
<div class="paragraph">
<p>Оператор <code>IN</code> позволяет указать несколько значений в предложении <code>WHERE</code>. Он является сокращением для нескольких условий <code>OR</code>.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column_name(s)
FROM table_name
WHERE column_name IN (value1, value2, ...);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Синтаксис  подзапросом</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column_name(s)
FROM table_name
WHERE column_name IN (SELECT STATEMENT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий SQL запрос выбирает всех пользователей, которые находятся в странах <code>Belarus</code>, <code>Spain</code> и <code>France</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM users
WHERE country IN ('Belarus', 'Spain', 'France');</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий SQL запрос выбирает всех пользователей, которые <strong>НЕ расположены</strong> в <code>Belarus</code>, <code>Spain</code> и <code>France</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM users
WHERE country NOT IN ('Belarus', 'Spain', 'France');</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_выборка_с_проверкой_на_вхождение_в_диапазон_between_и_not_between">Выборка с проверкой на вхождение в диапазон (<code>BETWEEN</code> и <code>NOT BETWEEN</code>)</h4>
<div class="paragraph">
<p>Оператор <code>BETWEEN</code> выбирает значения в заданном диапазоне. Значения могут быть числами, текстом или датами.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column_name(s)
FROM table_name
WHERE column_name BETWEEN value1 AND value2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий SQL запрос выбирает все продукты с ценой <code>BETWEEN</code> <code>5</code> и <code>200</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM products
WHERE price BETWEEN 5 AND 200;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы отобразить товары вне диапазона предыдущего примера, используйте <code>NOT BETWEEN</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM products
WHERE price NOT BETWEEN 5 AND 200;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_пример_between_с_in">Пример <code>BETWEEN</code> с <code>IN</code></h5>
<div class="paragraph">
<p>Следующий оператор выбирает все товары с ценой <code>BETWEEN</code> <code>5</code> и <code>200</code> и не показывать товары с категориями <code>1</code>, <code>2</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM products
WHERE (price BETWEEN 5 AND 200)
  AND NOT category_id IN (1, 2);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_between_текстовых_значений"><code>BETWEEN</code> текстовых значений</h5>
<div class="paragraph">
<p>Следующий оператор выбирает все товары с name <code>BETWEEN</code> <code>Bike</code> и <code>PC</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM products
WHERE name BETWEEN 'Bike' AND 'PC'
ORDER BY name;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_not_between_текстовых_значений"><code>NOT BETWEEN</code> текстовых значений</h5>
<div class="paragraph">
<p>Следующий оператор выбирает все продукты с name <code>NOT BETWEEN</code> <code>Bike</code> и <code>PC</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM products
WHERE name NOT BETWEEN 'Bike' AND 'PC'
ORDER BY name;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_пример_between_с_датами">Пример <code>BETWEEN</code> с датами</h5>
<div class="paragraph">
<p>Следующий оператор SQL выбирает все счета с помощью <code>date BETWEEN</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
FROM products
WHERE manufacture_date BETWEEN '2021-02-01' AND '2021-04-01';</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_псевдонимы_aliases">Псевдонимы (<code>Aliases</code>)</h3>
<div class="paragraph">
<p><strong>SQL-псевдонимы</strong> используются для предоставления таблицы или столбца таблицы временного имени. Псевдонимы часто используются, чтобы сделать имена столбцов более читабельными. Псевдоним существует только для продолжительности запроса.</p>
</div>
<div class="paragraph">
<p>Псевдонимы могут быть полезны, когда:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>В запросе содержится более одной таблицы</p>
</li>
<li>
<p>Функции используются в запросе</p>
</li>
<li>
<p>Названия столбцов большие или не очень читаемые</p>
</li>
<li>
<p>Два или более столбца объединяются вместе</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Синтаксис псевдонимов для столбца</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column_name AS alias_name
FROM table_name;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Синтаксис псевдонимов для таблицы</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column_name(s)
FROM table_name AS alias_name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий оператор создает два псевдонима: один для столбца <code>user_id</code> и один для столбца <code>name</code>:</p>
</div>
<div class="paragraph">
<p><strong>Пример:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT user_id AS id, name AS user
FROM users;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий оператор создает два псевдонима: один для столбца <code>name</code> и один для столбца <code>country</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT name AS user, country AS "User from Country"
FROM users;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий оператор выбирает все покупки от пользователя с помощью <code>user_id</code> и <code>name</code>. В запросе используются таблицы <code>users</code> и <code>products</code>, которым даются псевдонимы таблиц <code>u</code> и <code>p</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT u.name AS buyer, p.name as purchase, p.price
FROM users AS u,
     products AS p
WHERE u.name = 'Lily'
  AND u.user_id = p.user_id;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_обновление_записей_update">Обновление записей (<code>UPDATE</code>)</h3>
<div class="paragraph">
<p>Зачастую необходимо изменить данные в таблице. В <strong>SQL</strong> это делается с помощью <code>UPDATE</code>.</p>
</div>
<div class="paragraph">
<p>Использование <code>UPDATE</code> включает в себя выбор таблицы, в которой находится поле подлежащее изменению. Запись нового значения осуществляется с помощью запроса <code>WHERE</code>, чтобы обозначить конкретное место в таблице.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition</code></pre>
</div>
</div>
<div class="paragraph">
<p>Предположим есть таблица с самыми высоко оценёнными сериалами всех времён. Однако в ней есть несоответствие: <strong>Игра Престолов</strong>  обозначена как комедия, изменим значение поля следующим запросом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">UPDATE tv_series
SET genre = 'drama'
WHERE name = 'Game of Thrones';</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_удаление_записей_из_таблицы_delete">Удаление записей из таблицы (<code>DELETE</code>)</h3>
<div class="paragraph">
<p>Удаление записи из таблицы очень простая операция, всё что нужно - это обозначить, что необходимо удалить.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DELETE
FROM tv_serials
WHERE tv_serial_id = 3;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Необходимо убедиться что используется запрос <code>WHERE</code>, когда происходит удаление записи из таблицы. Иначе удалятся все записи.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_удалить_все_записи">Удалить все записи</h4>
<div class="paragraph">
<p>Можно удалить все строки таблицы без удаления таблицы. Это означает, что структура таблицы, атрибуты и индексы будут неповрежденными:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DELETE FROM table_name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>или:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DELETE
FROM tv_serials
WHERE tv_serial_id IS NOT NULL;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_многотабличные_базы_данных">Многотабличные базы данных</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_ключи">Ключи</h3>
<div class="paragraph">
<p><strong>Ключ</strong> — это колонка или колонки, не имеющие в строках дублирующих значений.</p>
</div>
<div class="paragraph">
<p><strong>Ключи бывают:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Первичные</strong></p>
</li>
<li>
<p><strong>Внешние</strong></p>
</li>
<li>
<p><strong>Составные</strong></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_первичный_ключ">Первичный ключ</h4>
<div class="paragraph">
<p>Столбец, который в базе данных должен быть уникальным помечают первичным ключом. <strong>Первичный ключ</strong> или <strong>primary key</strong> означает, что в таблице значение колонки <strong>primary key</strong> не может повторяться. Таким образом данный ключ позволяет однозначно идентифицировать запись в таблице не боясь при этом, что значение столбца повториться.</p>
</div>
<div class="paragraph">
<p>В качестве первичного ключа может использоваться:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Естественный Ключ</strong> (<strong>Natural key</strong>) – набор атрибутов описываемой записью сущности, уникально её идентифицирующий (например, номер паспорта для человека).</p>
</li>
<li>
<p><strong>Суррогатный Ключ</strong> (<strong>Surrogate Key</strong>) – автоматически сгенерированное поле, никак не связанное с информационным содержанием записи.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Допустим есть таблица студентов с полями: <code>ФИО</code>, <code>год рождения</code>. Поскольку может возникнуть ситуация когда <code>ФИО</code> и <code>год рождения</code> совпадут сразу у нескольких студентов, верным решением будет внести в таблицу первичный ключ:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Первичный ключ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ФИО</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Год рождения</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Иванов Иван</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2001</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Егоров Егор</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2002</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Николаенко Николай</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2001</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_внешний_ключ">Внешний ключ</h4>
<div class="paragraph">
<p><strong>Внешние ключи</strong> еще называют <strong>ссылочным</strong>, они необходимы для связывания таблиц между собой.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Товары</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Артикул</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ID тип товара</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Цена</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">151687</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">104</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">151605</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">42</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">151690</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">77</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">151601</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">90</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Тип товара</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Тип товара</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Джемпер</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Футболка</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>В таблице <code>Тип товара</code> внешним ключом будет поле <code>ID тип товара</code> в таблице <code>Товары</code>. Благодаря такой зависимости образуется связь между двумя таблицами.</p>
</div>
</div>
<div class="sect3">
<h4 id="_составной_ключ">Составной ключ</h4>
<div class="paragraph">
<p>Бывают ситуации, когда при вставке в таблицу нужно проверять запись на уникальность сразу по нескольким полям.</p>
</div>
<div class="paragraph">
<p><strong>Составной ключ</strong> — это несколько первичных ключей в таблице. Таким образом, создав составной ключ, уникальность записи будет проверяться по полям, которые объединенные в этот ключ.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Город</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">№ школы</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Директор</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Адрес</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Телефон</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Гомель</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Иванов Иван</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Лесная, 2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2-22-99</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Минск</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Егоров Егор</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Солнечная, 4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4-44-44</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Минск</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Николаенко Николай</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Радужная, 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5-55-55</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Составной ключ может состоять и более чем из двух полей. В таблице поля <code>Город</code> и <code>№ школы</code> вместе образуют составной ключ. В такой таблице у разных записей не могут совпасть одновременно два поля <code>Город</code> и <code>№ школы</code>, а номера школ совпасть могут.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_подзапросы">Подзапросы</h3>
<div class="sect3">
<h4 id="_оператор_exists">Оператор <code>EXISTS</code></h4>
<div class="paragraph">
<p>Оператор <code>EXISTS</code> используется для проверки существования любой записи в подзапросе. Если подзапрос возвращает одну или несколько записей, то возвращается <code>true</code>.</p>
</div>
<div class="sect4">
<h5 id="_синтаксис_exists">Синтаксис <code>EXISTS</code></h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column_name(s)
FROM table_name
WHERE EXISTS
(SELECT column_name FROM table_name WHERE condition);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_примеры_использования_exists">Примеры использования <code>EXISTS</code></h5>
<div class="paragraph">
<p>Следующий оператор возвращает <code>TRUE</code> и перечисляет доставки с ценой товара менее <code>1000</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT name
FROM delivery
WHERE EXISTS (SELECT name FROM product WHERE delivery_id = delivery.delivery_id AND price &lt; 1000);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий оператор SQL возвращает <code>TRUE</code> и перечисляет доставки с ценой товара <code>5000</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT name
FROM delivery
WHERE EXISTS (SELECT name FROM product WHERE delivery_id = delivery.delivery_id AND price = 5000);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_операторы_any_и_all">Операторы <code>ANY</code> и <code>ALL</code></h4>
<div class="paragraph">
<p>Операторы <code>ANY</code> и <code>ALL</code> используются с предложением <code>WHERE</code> или <code>HAVING</code>. Оператор <code>ANY</code> возвращает <code>true</code>, если какое-либо из значений подзапроса соответствует условию. Оператор <code>ALL</code> возвращает <code>true</code>, если все значения подзапроса удовлетворяют условию.</p>
</div>
<div class="sect4">
<h5 id="_синтаксис_any">Синтаксис <code>ANY</code></h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column_name(s)
FROM table_name
WHERE column_name operator ANY
(SELECT column_name FROM table_name WHERE condition);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_пример_any">Пример <code>ANY</code></h5>
<div class="paragraph">
<p>Оператор <code>ANY</code> возвращает <code>TRUE</code>, если какое-либо из значений подзапроса соответствует условию. Следующий оператор возвращает <code>TRUE</code> и перечисляет имена товаров, если он находит ЛЮБЫЕ записи в таблице <code>info</code>, с количеством = <code>15</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT name
FROM product
WHERE product_id = ANY (SELECT product_id FROM info WHERE counts = 15)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий оператор возвращает <code>TRUE</code> и перечисляет имена товаров, если он находит ЛЮБЫЕ записи в таблице <code>info</code>, с количеством &gt; <code>15</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT name
FROM product
WHERE product_id = ANY (SELECT product_id FROM info WHERE counts &gt; 15);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_синтаксис_all">Синтаксис <code>ALL</code></h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column_name(s)
FROM table_name
WHERE column_name operator ALL
(SELECT column_name FROM table_name WHERE condition);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_пример_all">Пример <code>ALL</code></h5>
<div class="paragraph">
<p>Оператор <code>ALL</code> возвращает <code>TRUE</code>, если все значения подзапроса удовлетворяют условию.</p>
</div>
<div class="paragraph">
<p>Следующий оператор возвращает <code>TRUE</code> и перечисляет имена товаров, если ВСЕ записи в таблице <code>info</code> имеют количество = <code>7</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT name
FROM product
WHERE product_id = ALL (SELECT product_id FROM info WHERE couns =7);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_соединение">Соединение</h3>
<div class="paragraph">
<p>Оператор <code>UNION</code> используется для объединения результирующего набора из двух или более операторов <code>SELECT</code>. Каждый оператор <code>SELECT</code> в <code>UNION</code> должен иметь одинаковое количество столбцов. Столбцы также должны иметь похожие типы данных и в каждой инструкции <code>SELECT</code> быть в том же порядке.</p>
</div>
<div class="sect3">
<h4 id="_синтаксис_union">Синтаксис <code>UNION</code></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column_name(s) FROM table1
UNION
SELECT column_name(s) FROM table2;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_пример_union">Пример <code>UNION</code></h4>
<div class="paragraph">
<p>Следующий оператор выбирает все разные города (только отдельные значения) от <code>users</code> и <code>delivery</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT city FROM users
UNION
SELECT city FROM delivery
ORDER BY city;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_синтаксис_union_all">Синтаксис <code>UNION ALL</code></h4>
<div class="paragraph">
<p>Оператор <code>UNION</code> по умолчанию выбирает только разные значения. Чтобы разрешить повторяющиеся значения, используйте <code>UNION ALL</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column_name(s) FROM table1
UNION ALL
SELECT column_name(s) FROM table2;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_пример_union_all">Пример <code>UNION ALL</code></h4>
<div class="paragraph">
<p>Следующий оператор выбирает все города (дублирующиеся значения также) из <code>users</code> и <code>delivery</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT city FROM users
UNION ALL
SELECT city FROM delivery
ORDER BY city;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_оператор_union_с_where">Оператор <code>UNION</code> с <code>WHERE</code></h4>
<div class="paragraph">
<p>Следующий оператор выбирает все разные испанские города (только отдельные значения) от <code>users</code> и <code>delivery</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT city, country FROM users
WHERE country='Spain'
UNION
SELECT city, country FROM delivery
WHERE country='Spain'
ORDER BY city;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_оператор_union_all_с_where">Оператор <code>UNION ALL</code> с <code>WHERE</code></h4>
<div class="paragraph">
<p>Следующий оператор выбирает все испанские города (повторяющиеся значения) также из <code>users</code> и <code>delivery</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT city, country FROM users
WHERE country='Spain'
UNION ALL
SELECT city, country FROM delivery
WHERE country = 'Spain'
ORDER BY city;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_объединения">Объединения</h3>
<div class="paragraph">
<p>Предложение <code>JOIN</code> используется для объединения строк из двух или более таблиц на основе соответствующего столбца между ними.</p>
</div>
<div class="paragraph">
<p>Существует несколько типов <code>JOIN</code> в <strong>SQL</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>(INNER) JOIN</code> - возвращает записи, имеющие соответствующие значения в обеих таблицах</p>
</li>
<li>
<p><code>LEFT (OUTER) JOIN</code> - возвращает все записи из левой таблицы и соответствующие записи из правой таблицы</p>
</li>
<li>
<p><code>RIGHT (OUTER) JOIN</code> - вернуть все записи из правой таблицы и сопоставленные записи из левой таблицы</p>
</li>
<li>
<p><code>FULL (OUTER) JOIN</code> - возвращает все записи, когда есть совпадение в левой или правой таблице</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_inner_join"><code>INNER JOIN</code></h4>
<div class="paragraph">
<p>Ключевое слово <code>INNER JOIN</code> выбирает записи, имеющие соответствующие значения в обеих таблицах</p>
</div>
<div class="paragraph">
<p><strong>Синтаксиc:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column_name(s)
FROM table1
INNER JOIN table2 ON table1.column_name = table2.column_name;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Пример:</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. Таблица users</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">user_id</th>
<th class="tableblock halign-left valign-top">name</th>
<th class="tableblock halign-left valign-top">fullname</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ник</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Никольский</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Майк</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Майкович</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. Таблица invoice</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">invoice_id</th>
<th class="tableblock halign-left valign-top">user_id</th>
<th class="tableblock halign-left valign-top">product_id</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Столбец <code>user_id</code> в таблице <code>invoice</code> ссылается на <code>user_id</code> в таблице <code>invoice</code> между которыми осуществляется взаимосвязь. Для выбора записей, имеющие соответствующие значения в обеих таблицах используется следующий запрос:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT invoice.invoice_id, users.name
FROM Orders
INNER JOIN users ON invoice.user_id = users.user_id;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_join_three_таблиц"><code>JOIN Three</code> таблиц</h5>
<div class="paragraph">
<p>Следующий оператор выбирает все счета с информацией о пользователях и отправителях:</p>
</div>
<div class="paragraph">
<p><strong>Пример:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT invoice.invoice, users.name, addresser.name
FROM ((invoice
INNER JOIN users ON invoice.user_id = users.user_id)
INNER JOIN addresser ON invoice.addresser_id = addresser.addresser_id);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_left_join"><code>LEFT JOIN</code></h4>
<div class="paragraph">
<p>Ключевое слово <code>LEFT JOIN</code> возвращает все записи из левой таблицы и сопоставленные записи из правой таблицы. Результат равен <code>NULL</code> с правой стороны, если нет совпадения.</p>
</div>
<div class="paragraph">
<p><strong>Синтаксис:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column_name(s)
FROM table1
LEFT JOIN table2 ON table1.column_name = table2.column_name;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Пример</strong>, следующий оператор выберет всех пользователей и любые заказы, которые они могут иметь:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT users.name, invoice.invoice_id
FROM users
LEFT JOIN invoice ON users.user_id = invoice.user_id
ORDER BY users.name;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_right_join"><code>RIGHT JOIN</code></h4>
<div class="paragraph">
<p>Ключевое слово <code>RIGHT JOIN</code> возвращает все записи из правой таблицы и сопоставленные записи из левой таблицы. Результат равен <code>NULL</code> с левой стороны, когда нет совпадения.</p>
</div>
<div class="paragraph">
<p><strong>Синтаксис:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column_name(s)
FROM table1
RIGHT JOIN table2 ON table1.column_name = table2.column_name;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Пример</strong>, следующий оператор вернет всех пользователей и любые заказы, которые они могли бы разместить.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT invoice.invoice_id, users.name, users.fullname
FROM invoice
RIGHT JOIN users ON invoice.user_id = users.user_id
ORDER BY invoice.invoice_id;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_full_outer_join"><code>FULL OUTER JOIN</code></h4>
<div class="paragraph">
<p>Ключевое слово <code>FULL OUTER JOIN</code> возвращает все записи, когда есть совпадение в обеих таблицах таблицы или справа.</p>
</div>
<div class="paragraph">
<p><strong>Синтаксис:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column_name(s)
FROM table1
FULL OUTER JOIN table2 ON table1.column_name = table2.column_name;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Пример</strong>, следующий оператор выбирает всех пользователей и все заказы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT users.name, invoice.invoice_id
FROM users
FULL OUTER JOIN invoice ON users.user_id = invoice.user_id
ORDER BY users.name;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_регулярное_соединение_self_join">Регулярное соединение <code>Self JOIN</code></h4>
<div class="paragraph">
<p><code>Self JOIN</code> - это регулярное соединение, но таблица соединяется сама с собой.</p>
</div>
<div class="paragraph">
<p><strong>Синтаксис:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column_name(s)
FROM table1 T1, table1 T2
WHERE condition;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Пример</strong>, следующий оператор соответствует пользователям из одного города:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT A.name AS name1, B.name AS name2, A.city
FROM users A, users B
WHERE A.user_id &lt;&gt; B.user_id
AND A.city = B.city
ORDER BY A.city;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_агрегатные_функции_и_группировка">Агрегатные функции и группировка</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_агрегатные_функции">Агрегатные функции</h3>
<div class="sect3">
<h4 id="_функции_min_и_max">Функции <code>MIN()</code> и <code>MAX()</code></h4>
<div class="paragraph">
<p>Функция <code>MIN()</code> возвращает наименьшее значение выбранного столбца. Функция <code>MAX()</code> возвращает наибольшее значение выбранного столбца.</p>
</div>
<div class="paragraph">
<p><strong>Синтаксис <code>MIN()</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT MIN(column_name)
FROM table_name
WHERE condition;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Пример <code>MIN()</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT MIN(price) AS min_price
FROM product;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Синтаксис <code>MAX()</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT MAX(column_name)
FROM table_name
WHERE condition;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Пример <code>MAX()</code></strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT MAX(price) AS max_price
FROM product;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_функция_count">Функция <code>COUNT()</code></h4>
<div class="paragraph">
<p>Функция <code>COUNT()</code> возвращает количество строк, соответствующих заданным критериям.</p>
</div>
<div class="paragraph">
<p><strong>Синтаксис:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT COUNT(column_name)
FROM table_name
WHERE condition;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Пример:</strong></p>
</div>
<div class="paragraph">
<p>Следующий оператор SQL находит количество товаров.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT COUNT(product_id)
FROM product;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_функция_avg">Функция <code>AVG()</code></h4>
<div class="paragraph">
<p>Функция <code>AVG()</code> возвращает среднее значение числового столбца.</p>
</div>
<div class="paragraph">
<p><strong>Синтаксис:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT AVG(column_name)
FROM table_name
WHERE condition;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Например</strong> найдем среднюю стоимость товара:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT AVG(price)
FROM product;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_функция_sum">Функция <code>SUM()</code></h4>
<div class="paragraph">
<p>Функция <code>SUM()</code> возвращает общую сумму числового столбца.</p>
</div>
<div class="paragraph">
<p><strong>Синтаксис:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT SUM(column_name)
FROM table_name
WHERE condition;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Пример</strong>, найдем сумму полей доставка <code>delivery</code> в таблице <code>invoice</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT SUM(delivery)
FROM invoice;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_группировка">Группировка</h3>
<div class="paragraph">
<p>Оператор <code>GROUP BY</code> часто используется с агрегатными функциями (<code>COUNT</code>, <code>MAX</code>, <code>MIN</code>, <code>SUM</code>, <code>AVG</code>) для группировки результирующего набора одним или несколькими столбцами.</p>
</div>
<div class="sect3">
<h4 id="_синтаксис_group_by">Синтаксис <code>GROUP BY</code></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column_name(s)
FROM table_name
WHERE condition
GROUP BY column_name(s)
ORDER BY column_name(s);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_пример_sql_group_by">Пример SQL <code>GROUP BY</code></h4>
<div class="paragraph">
<p>В следующем выражении указано количество пользователей в каждой стране:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT COUNT(use_id), country
FROM users
GROUP BY country;</code></pre>
</div>
</div>
<div class="paragraph">
<p>В следующем SQL-заявлении указано количество пользователей в каждой стране, отсортированных по высоким и низким:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT COUNT(user_id), country
FROM users
GROUP BY country
ORDER BY COUNT(user_id) DESC;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_операторgroup_by_с_join">Оператор`GROUP BY` с <code>JOIN</code></h4>
<div class="paragraph">
<p>В следующем выражении указано количество заказов, отправленных каждой службой доставки:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT delivery.name, COUNT(invoice.delivery_id) AS orders FROM invoice
LEFT JOIN delivery ON invoice.delivery_id = delivery.delivery_id
GROUP BY name;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_предложение_having">Предложение <code>HAVING</code></h3>
<div class="paragraph">
<p>Предложение <code>HAVING</code> используется в SQL, для работы с агрегатными функциями, так как <code>WHERE</code> не могло с ними использоваться.</p>
</div>
<div class="paragraph">
<p><strong>Синтаксис:</strong>`</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column_name(s)
FROM table_name
WHERE condition
GROUP BY column_name(s)
HAVING condition
ORDER BY column_name(s);</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Пример</strong>, в следующем SQL-заявлении указано количество пользователей в каждой стране. Включать только страны с более чем 7 клиентами:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT COUNT(user_id), country
FROM users
GROUP BY country
HAVING COUNT(user_id) &gt; 7;</code></pre>
</div>
</div>
<div class="paragraph">
<p>В следующем SQL-заявлении указано количество пользователей в каждой стране, отсортированные по высоким и низким.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT COUNT(user_id), country
FROM users
GROUP BY country
HAVING COUNT(user_id) &gt; 7
ORDER BY COUNT(user_id) DESC;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_проектирование_баз_данных">Проектирование баз данных</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_нормализация_и_денормализация_баз_данных">Нормализация и денормализация баз данных</h3>
<div class="paragraph">
<p><strong>Нормализация базы данных</strong> - это процесс эффективной организации данных в базе данных. Есть две причины процесса нормализации:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Устранение избыточных данных, например, хранение тех же данных в более чем одной таблице.</p>
</li>
<li>
<p>Обеспечение зависимостей данных.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Денормализация</strong> — намеренное приведение структуры базы данных в состояние, не соответствующее критериям нормализации, обычно проводимое с целью ускорения операций чтения из базы за счет добавления избыточных данных.</p>
</div>
<div class="paragraph">
<p><strong>Нормализация</strong> состоит из ряда принципов, которые помогают в создании хорошей структуры базы данных. Эти принципы делятся на нормальные формы, их цель в организации структуры базы данных таким образом, чтобы правильно организовать структуру базы данных.</p>
</div>
<div class="sect3">
<h4 id="_первая_нормальная_форма">Первая нормальная форма</h4>
<div class="paragraph">
<p>Правила первой нормальной формы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>В таблице не должно быть дублирующих строк.</p>
</li>
<li>
<p>В каждой ячейке таблицы хранится атомарное значение (одно не составное значение).</p>
</li>
<li>
<p>В столбце хранятся данные одного типа.</p>
</li>
<li>
<p>Нет упорядочивания строк сверху вниз (другими словами, порядок строк не несет в себе никакой информации).</p>
</li>
<li>
<p>Нет упорядочивания столбцов слева направо (другими словами, порядок столбцов не несет в себе никакой информации).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Пример, допустим есть ненормализованная таблица:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ID покупателя</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ФИО</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Заказ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Телефон</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Егоров Егор</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ноутбук Asus G53</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Мобильный телефон 44 888 77 77, Домашний Телефон 8-77-77</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Егоров Егор</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Телефон Nokia 5310</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Мобильный телефон 44 888 77 77, Домашний Телефон 8-77-77</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Егоров Егор</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Наушники LG 700</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Мобильный телефон 44 888 77 77, Домашний Телефон 8-77-77</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Такая таблица нарушает требования первой нормальной формы. Ее следует разбить на две части, а затем соединить их с помощью ключа.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. Информация о клиенте</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ID покупателя</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ФИО</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Мобильный телефон</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Домашний телефон</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Егоров Егор</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">44 888 77 77</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8-77-77</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. Информация о заказах</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ID заказа</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ID клиента</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Заказ</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ноутбук Asus G53</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Телефон Nokia 5310</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Наушники LG 700</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Такие таблицы соответствуют требованиям первой нормальной формы.</p>
</div>
<div class="sect4">
<h5 id="_вторая_нормальная_форма">Вторая нормальная форма</h5>
<div class="paragraph">
<p><strong>Правило второй нормальной формы</strong> звучит следующим образом: отношение соответствует второй нормальной форме, если оно соответствует первой нормальной форме и каждый не ключевой атрибут неприводимо зависит от первичного ключа.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ФИО</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Должность</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Подразделение</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Егоров Егор</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Программист</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Отдел разработки ПО</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Иванов Иван</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Бухгалтер</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Бухгалтерия</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Борисов Борис</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Продавец</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Отдел реализации</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Допустим в организации каждому сотруднику присваивается уникальный табельный номер, который никогда не будет изменен. Таким образом, чтобы привести эту таблицу ко второй нормальной форме, необходимо добавить в нее еще один атрибут, т.е. столбец с табельным номером, который будет выступать первичным ключом.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Табельный номер</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ФИО</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Должность</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Подразделение</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">660</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Егоров Егор</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Программист</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Отдел разработки ПО</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">212</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Иванов Иван</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Бухгалтер</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Бухгалтерия</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1024</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Борисов Борис</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Продавец</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Отдел реализации</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_третья_нормальная_форма">Третья нормальная форма</h5>
<div class="paragraph">
<p><strong>Правило третьей нормальной формы</strong> звучит следующим образом: отношение находится в третьей нормальной форме, когда находится во второй нормальной форме и каждый не ключевой атрибут не транзитивно зависит от первичного ключа.</p>
</div>
<div class="paragraph">
<p>Иначе говоря, третья нормальная форма требует выносить все не ключевые поля, содержимое которых может относиться к нескольким записям таблицы в отдельные таблицы.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CourseID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Course</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TeacherID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Teacher</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Математика</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Егоров Егор</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Иванов Иван</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Алгоритмы</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Иванов Иван</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Такую ненормализованную таблицу требуется разбить на две разные таблицы:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TeacherID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Teacher</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Егоров Егор</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Иванов Иван</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Таким образом в первой таблице TeacherID является ключом, явный указывающий на преподавателя.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CourseID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Course</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TeacherID</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Математика</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Алгоритмы</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_нормальная_форма_бойса_кодда">Нормальная форма Бойса-Кодда</h5>
<div class="paragraph">
<p><strong>Требование нормальной формы Бойса-Кодда</strong> звучит следующим образом: таблица должна находиться в третьей нормальной форме и ключевые атрибуты составного ключа не должны зависеть от неключевых атрибутов. Отсюда следует, что требования нормальной формы Бойса-Кодда предъявляются только к таблицам, у которых первичный ключ составной.</p>
</div>
<div class="paragraph">
<p><strong>Пример</strong></p>
</div>
<div class="paragraph">
<p>Представим, что у нас есть организация, которая реализует множество различных проектов. При этом в каждом проекте работа ведётся по нескольким функциональным направлениям, в каждом из которых есть свой куратор. Сотрудник может быть куратором только того направления, на котором он специализируется, т.е. если сотрудник программист, он не может курировать в проекте направление, связанное с бухгалтерией.</p>
</div>
<div class="paragraph">
<p>Допустим, что нам нужно хранить информацию о кураторах всех проектов по каждому направлению в таблице, где <strong>первичный ключ составной</strong> «Проект + Направление:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Проект</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Направление</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Куратор</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Разработка</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Егоров Егор</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Бухгалтерия</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Иванов Иван</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Разработка</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Егоров Егор</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Реализация</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Андреев Андрей</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>В данном случае таблица не находится в нормальной форме Бойса-Кодда, дело в том, что зная куратора, можно четко определить, какое направление он курирует, иными словами, часть составного ключа, т.е. «Направление», зависит от неключевого атрибута, т.е. «Куратора». Чтобы привести данную таблицу к нормальной форме Бойса-Кодда, необходимо сделать декомпозицию данного отношения, т.е. разбить эту таблицу на несколько таблиц.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 7. Таблица кураторов</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Идентификатор куратора</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ФИО</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Направление</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Егоров Егор</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Разработка</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Иванов Иван</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Бухгалтерия</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Андреев Андрей</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Реализация</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8. Таблица связи кураторов и проектов</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Проект</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Идентификатор куратора</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_продвинутый_sql">Продвинутый SQL</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_заявление_select_into">Заявление <code>SELECT INTO</code></h3>
<div class="paragraph">
<p>Оператор <code>SELECT INTO</code> копирует данные из одной таблицы в новую таблицу.</p>
</div>
<div class="sect3">
<h4 id="_синтаксис_select_into">Синтаксис <code>SELECT INTO</code></h4>
<div class="paragraph">
<p>Скопировать все столбцы в новую таблицу:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT *
INTO newtable [IN externaldb]
FROM oldtable
WHERE condition;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Скопировать только несколько столбцов в новую таблицу:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT column1, column2, column3, ...
INTO newtable [IN externaldb]
FROM oldtable
WHERE condition;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Новая таблица будет создана с именами и типами столбцов, как определено в старой таблице. Можно создавать новые имена столбцов, используя предложение <code>AS</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_примеры_sql_select_into">Примеры SQL <code>SELECT INTO</code></h4>
<div class="paragraph">
<p>Следующий оператор SQL создает резервную копию <code>users</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT * INTO usersBackup001
FROM users;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий оператор использует предложение <code>IN</code> для копирования таблицы в новую таблицу в другой базе данных:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT * INTO usersBackup001 IN 'backup.mdb'
FROM users;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующий оператор копирует только несколько столбцов в новую таблицу:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT name, fullname INTO usersBackup001
FROM users;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_оператор_insert_into_select">Оператор <code>INSERT INTO SELECT</code></h3>
<div class="paragraph">
<p>Оператор <code>INSERT INTO SELECT</code> копирует данные из одной таблицы и вставляет ее в другую таблицу. <code>INSERT INTO SELECT</code> требует, чтобы типы данных в исходной и целевой таблицах соответствовали.</p>
</div>
<div class="paragraph">
<p>Синтаксис <code>INSERT IN SELECT</code>
Скопировать все столбцы из одной таблицы в другую:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">INSERT INTO table2
SELECT * FROM table1
WHERE condition;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Скопировать только несколько столбцов из одной таблицы в другую таблицу:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">INSERT INTO table2 (column1, column2, column3, ...)
SELECT column1, column2, column3, ...
FROM table1
WHERE condition;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_пример_sql_insert_into_select">Пример SQL <code>INSERT INTO SELECT</code></h4>
<div class="paragraph">
<p>Следующий оператор копирует <code>clients</code> в <code>users</code> (столбцы, которые не заполнены данными, будет содержать <code>NULL</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">INSERT INTO users (nme, fullname, balance)
SELECT nme, fullname, balance FROM clients;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_create_index"><code>CREATE INDEX</code></h3>
<div class="paragraph">
<p>Оператор <code>CREATE INDEX</code> используется для создания индексов в таблицах. Индексы используются для быстрого извлечения данных из базы данных. Пользователи не могут видеть индексы, они просто используются для ускорения поиска/запросов.</p>
</div>
<div class="sect3">
<h4 id="_синтаксис_create_index">Синтаксис <code>CREATE INDEX</code></h4>
<div class="paragraph">
<p><code>CREATE INDEX</code> создает индекс в таблице. Допускаются повторяющиеся значения:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE INDEX index_name
ON table_name (column1, column2, ...);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_синтаксис_create_unique_index">Синтаксис <code>CREATE UNIQUE INDEX</code></h4>
<div class="paragraph">
<p>Создает уникальный индекс в таблице. Дублирующие значения не допускаются:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE UNIQUE INDEX index_name
ON table_name (column1, column2, ...);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_пример_create_index">Пример <code>CREATE INDEX</code></h4>
<div class="paragraph">
<p>В приведенной ниже инструкции SQL создается индекс с именем <code>ind_name</code> в столбце <code>name</code> в таблице <code>users</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE INDEX ind_name
ON users (name);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если необходимо создать индекс в комбинации столбцов, можно указать имена столбцов в круглых скобках, разделенные запятыми:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE INDEX ind_name
ON users (name, fullname);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_оператор_drop_index">Оператор <code>DROP INDEX</code></h3>
<div class="paragraph">
<p>Оператор <code>DROP INDEX</code> используется для удаления индекса в таблице.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE table_name
DROP INDEX index_name;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_поле_auto_increment">Поле <code>AUTO INCREMENT</code></h3>
<div class="paragraph">
<p><code>Auto-increment</code> позволяет создавать уникальный номер автоматически, когда новая запись вставляется в таблицу. Часто это поле основного ключа, которое необходимо создать автоматически каждый раз, когда будет вставлена новая запись.</p>
</div>
<div class="sect3">
<h4 id="_синтаксис_для_mysql">Синтаксис для <code>MySQL</code></h4>
<div class="paragraph">
<p>Следующий оператор SQL определяет столбец <code>user_id</code> как поле первичного ключа с автоматическим приращением в таблице «users»:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE users (
user_id int NOT NULL AUTO_INCREMENT,
name varchar(255) NOT NULL,
fullname varchar(255),
balance int,
PRIMARY KEY (user_id)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>MySQL использует ключевое слово <code>AUTO_INCREMENT</code> для выполнения функции автоматического увеличения.</p>
</div>
<div class="paragraph">
<p>По умолчанию начальное значение для <code>AUTO_INCREMENT</code> равно <code>1</code>, и оно будет увеличиваться на 1 для каждой новой записи.</p>
</div>
<div class="paragraph">
<p>Чтобы последовательность <code>AUTO_INCREMENT</code> начиналась с другого значения, используйте следующий оператор:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE users AUTO_INCREMENT = 7;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы вставить новую запись в таблицу <code>user</code>, нам не нужно указывать значение для столбца <code>user_id</code>, так как уникальное значение будет добавляться автоматически:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">INSERT INTO users (name, fullname)
VALUES ('Том','Эдисон');</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_работа_с_датами">Работа с датами</h3>
<div class="paragraph">
<p>Пока ваши данные содержат только часть даты, ваши запросы будут работать должным образом. Однако, если задействована временная часть, она становится более сложной.</p>
</div>
<div class="sect3">
<h4 id="_типы_данных_sql_date">Типы данных <code>SQL Date</code></h4>
<div class="paragraph">
<p>MySQL имеет следующие типы данных для хранения даты или значения даты/времени в базе данных:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DATE</code> - формат: <code>YYYY-MM-DD</code></p>
</li>
<li>
<p><code>DATETIME</code> - формат: <code>YYYY-MM-DD HH:MI:SS</code></p>
</li>
<li>
<p><code>TIMESTAMP</code> - формат: <code>YYYY-MM-DD HH:MI:SS</code></p>
</li>
<li>
<p><code>YEAR</code> - формат: <code>YYYY</code> or <code>YY</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_операторы">Операторы</h3>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 9. Арифметические операторы SQL</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Оператор</th>
<th class="tableblock halign-left valign-top">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>+</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Добавление</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Вычитание</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>*</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Умножение</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Деление</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>%</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Модуль</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 10. Побитовые операции SQL</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Оператор</th>
<th class="tableblock halign-left valign-top">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Побитовое М</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Побитовое ИЛИ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>^</code></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 11. Операторы сравнения SQL</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Оператор</th>
<th class="tableblock halign-left valign-top">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Равно</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Больше</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Меньше</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&gt;=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Больше или равно</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Меньше или равно</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Не равно</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 12. Составные операторы SQL</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Оператор</th>
<th class="tableblock halign-left valign-top">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>+=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Добавить равно</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Вычесть равно</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>*=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Умножить равно</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Разделить равно</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>%=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Модуль равно</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Побитовое И равно</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>^-=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Побитовое исключающее равно</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>|*=</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Побитовое ИЛИ равно</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 13. Логические операторы SQL</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Оператор</th>
<th class="tableblock halign-left valign-top">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ALL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Если все значения подзапроса являются <code>TRUE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AND</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Если все условия, разделенные И, являются <code>TRUE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ANY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Если какое-либо из значений подзапроса соответствует <code>TRUE</code> условию</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BETWEEN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Если операнд находится в диапазоне сравнения</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EXISTS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Если подзапрос возвращает одну или несколько записей</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Если операнд равен одному из списка выражений</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LIKE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Если операнд соответствует шаблону</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NOT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Отображает запись, если условие (И) НЕ <code>TRUE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Если любое из условий, разделенных <code>OR</code>, является <code>TRUE</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SOME</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Если какое-либо из значений подзапроса соответствует условию</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_функции">Функции</h3>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 14. Функции</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Функция</th>
<th class="tableblock halign-left valign-top">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ASCII</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает числовой код, который представляет конкретный символ</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CHAR_LENGTH</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает длину указанной строки (в символах)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CHARACTER_LENGTH</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает длину указанной строки (в символах)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONCAT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Объединяет два или более выражения вместе</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONCAT_WS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Объединяет два или более выражения вместе и добавляет разделитель между ними</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FIELD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает позицию значения в списке значений</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FIND_IN_SET</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает позицию строки в списке строк</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FORMAT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Форматирует число как формат «<mark>, <mark></mark>. </mark>», округляя его до определенного количества знаков после запятой</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>INSERT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Вставляет подстроку в строку в указанной позиции для определенного количества символов</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>INSTR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает позицию первого вхождения строки в другую строку</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LCASE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Преобразует строку в нижний регистр</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LEFT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Извлекает подстроку из строки (начиная слева)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LENGTH</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает длину указанной строки (в байтах)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOCATE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает позицию первого вхождения подстроки в строку</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOWER</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Преобразует строку в нижний регистр</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LPAD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает строку, которая добавлена в левую сторону с указанной строкой до определенной длины</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LTRIM</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Удаляет ведущие пробелы из строки</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MID</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Извлекает подстроку из строки (начиная с любой позиции)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>POSITION</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает позицию первого вхождения подстроки в строку</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>REPEAT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Повторяет строку определенное количество раз</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>REPLACE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Заменяет все вхождения указанной строки</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>REVERSE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Отменяет строку и возвращает результат</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RIGHT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Извлекает подстроку из строки (начиная справа)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RPAD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает строку с правой строкой с определенной строкой до определенной длины</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RTRIM</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Удаляет конечные пробелы из строки</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SPACE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает строку с заданным количеством пробелов</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>STRCMP</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Проверяет, одинаковы ли две строки</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SUBSTR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Извлекает подстроку из строки (начиная с любой позиции)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SUBSTRING</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Извлекает подстроку из строки (начиная с любой позиции)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SUBSTRING_INDEX</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает подстроку  string и перед integer вхождений delimiter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRIM</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Удаляет начальные и конечные пробелы из строки</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UCASE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Преобразует строку в верхний регистр</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UPPER</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Преобразует строку в верхний регистр</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 15. Числовые функции</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Функция</th>
<th class="tableblock halign-left valign-top">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ABS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает абсолютное значение числа</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ACOS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает косинус дуги числа</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ASIN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает синус дуги числа</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ATAN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает тангенс дуги числа или дуги касательной n и m</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ATAN2</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает тангенс дуги n и m</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AVG</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает среднее значение выражения</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CEIL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает наименьшее целочисленное значение, которое больше или равно числу</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CEILING</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает наименьшее целочисленное значение, которое больше или равно числу</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>COS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает косинус числа</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>COT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает котангенс числа</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>COUNT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает количество записей в выбранном запросе</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DEGREES</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Преобразует значение радиана в градусы</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DIV</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Используется для целочисленного деления</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EXP</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает e, поднятый до степени числа</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FLOOR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает наибольшее целочисленное значение, которое меньше или равно числу</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GREATEST</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает наибольшее значение в списке выражений</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LEAST</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает наименьшее значение в списке выражений</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает натуральный логарифм числа</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает натуральный логарифм числа или логарифм числа к заданной базе</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG10</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает логарифм базы-10 числа</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG2</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает логарифм базы-2 числа</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MAX</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает максимальное значение выражения</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MIN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает минимальное значение выражения</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MOD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает остаток n, деленный на m</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PI</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает значение PI, отображаемое с шестью знаками после запятой</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>POW</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает m, поднятую до n-й степени</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>POWER</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает m, поднятую до n-й степени</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RADIANS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Преобразует значение в градусах в радианы</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RAND</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает случайное число или случайное число в пределах диапазона</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ROUND</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает число, округленное до определенного количества знаков после запятой</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SIGN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает значение, обозначающее знак числа</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SIN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает синус числа</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SQRT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает квадратный корень из числа</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SUM</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает суммарное значение выражения</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TAN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает тангенс числа</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRUNCATE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает число, усеченное до определенного количества знаков после запятой</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 16. Функции даты</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Функция</th>
<th class="tableblock halign-left valign-top">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DATEDIFF</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает дату после добавления определенного интервала времени / даты</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DATE_ADD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает время / дату-время после добавления определенного временного интервала</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DATE_FORMAT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает текущую дату</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DATE_SUB</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает текущую дату</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DAY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает текущее время</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DAYNAME</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает текущую дату и время</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DAYOFMONTH</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает текущее время</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DAYOFWEEK</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Извлекает значение даты из выражения даты или даты и времени</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DAYOFYEAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает разницу в днях между двумя значениями даты</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EXTRACT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает дату после добавления определенного интервала времени / даты</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FROM_DAYS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Форматирует дату, указанную маской формата</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HOUR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает дату после вычитания определенного интервала времени / даты</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LAST_DAY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает дневную часть значения даты</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOCALTIME</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает имя дня недели для даты</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOCALTIMESTAMP</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает дневную часть значения даты</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MAKEDATE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает индекс недели для значения даты</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MAKETIME</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает день года для значения даты</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MICROSECOND</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Извлекает части с даты</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MINUTE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает значение даты из числового представления дня</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MONTH</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает часовую часть значения даты</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MONTHNAME</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает последний день месяца на заданную дату</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NOW</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает текущую дату и время</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PERIOD_ADD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает текущую дату и время</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PERIOD_DIFF</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает дату определенного годового и дневного значения</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>QUARTER</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает время для определенного часа, минуты, второй комбинации</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SECOND</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает микросекундную часть значения даты</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SEC_TO_TIME</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает минутную часть значения даты</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>STR_TO_DATE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает месячную часть значения даты</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SUBDATE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает полное название месяца для даты</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SUBTIME</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает текущую дату и время</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SYSDATE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Принимает период и добавляет к нему определенное количество месяцев</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TIME</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает разницу в месяцах между двумя периодами</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TIME_FORMAT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает четвертную часть значения даты</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TIME_TO_SEC</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает вторую часть значения даты</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TIMEDIFF</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Преобразует числовые секунды в значение времени</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TIMESTAMP</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Принимает строку и возвращает дату, заданную маской формата</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TO_DAYS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает дату, после которой вычитается определенный интервал времени / даты</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WEEK</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает значение time / datetime после вычитания определенного временного интервала</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WEEKDAY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает текущую дату и время</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WEEKOFYEAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Извлекает значение времени из выражения time / datetime</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>YEAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Форматирует время, указанное маской формата</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>YEARWEEK</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Преобразует значение времени в числовые секунды</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 17. Расширенные функции</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Функция</th>
<th class="tableblock halign-left valign-top">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BIN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Преобразует десятичное число в двоичное число</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BINARY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Преобразует значение в двоичную строку</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CASE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Позволяет вам оценить условия и вернуть значение при выполнении первого условия</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CAST</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Преобразует значение из одного типа данных в другой тип данных</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>COALESCE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает первое ненулевое выражение в списке</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONNECTION_ID</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает уникальный идентификатор соединения для текущего соединения</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONV</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Преобразует число из одной базы чисел в другую</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONVERT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Преобразует значение из одного типа данных в другой или один набор символов в другой</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CURRENT_USER</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает имя пользователя и имя хоста для учетной записи MySQL, используемой сервером, для проверки подлинности текущего клиента</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DATABASE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает имя базы данных по умолчанию</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IF</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает одно значение, если условие TRUE или другое значение, если условие FALSE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IFNULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Позволяет вернуть альтернативное значение, если выражение равно NULL</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ISNULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Проверяет, является ли выражение NULL</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LAST_INSERT_ID</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает первое значение AUTO_INCREMENT, заданное последним оператором INSERT или UPDATE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NULLIF</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Сравнивает два выражения</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SESSION_USER</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает имя пользователя и имя хоста для текущего пользователя MySQL</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SYSTEM_USER</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает имя пользователя и имя хоста для текущего пользователя MySQL</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>USER</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает имя пользователя и имя хоста для текущего пользователя MySQL</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VERSION</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Возвращает версию базы данных MySQL</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_блокировки">Блокировки</h3>
<div class="paragraph">
<p><strong>Блокировки</strong> - это механизм поддержки требований об изолированности транзакций.</p>
</div>
<div class="paragraph">
<p>Одновременный конкурентный доступ может вызывать разные отрицательные эффекты, например <strong>чтение несуществующих данных</strong> или <strong>потерю модифицированных данных</strong>.</p>
</div>
<div class="paragraph">
<p>Рассмотрим следующий практический пример: Пользователь №1 из отдела кадров получает извещение, что сотрудник "Егор Егоров" поменял место жительства. Он вносит соответствующее изменение в базу данных для данного сотрудника, но при просмотре другой информации об этом сотруднике он понимает, что изменил адрес не того человека. Он нажимает кнопку отмены, уверенный в том, что данные после отмены операции изменения адреса уже не содержат никакой ошибки. В то же самое время пользователь №2 в отделе проектирования обращается к данным второго сотрудника с именем Егор Егоров, чтобы отправить ему домой последнюю техническую документацию, поскольку этот служащий редко бывает в офисе. Однако пользователь №2 обратился к базе данных после того, как адрес этого второго сотрудника с именем Егор Егоров был ошибочно изменен, но до того, как он был исправлен. В результате письмо отправляется не тому адресату. Чтобы предотвратить подобные проблемы, каждая система управления базами данных должна обладать механизмом для управления одновременным доступом к данным всеми пользователями. Для обеспечения согласованности данных в случае одновременного обращения к данным несколькими пользователями, применяют блокировки. Каждая прикладная программа блокирует требуемые ей данные, что гарантирует, что никакая другая программа не сможет модифицировать эти данные. Когда другая прикладная программа пытается получить доступ к заблокированным данным для их модификации, то система или завершает эту попытку ошибкой, или заставляет программу ожидать снятия блокировки.</p>
</div>
<div class="paragraph">
<p>Режимы блокировки определяют разные типы блокировок. Выбор определенного режима блокировки зависит от типа ресурса, который требуется заблокировать. Для блокировок ресурсов уровня строки и страницы применяются следующие три типа блокировок:</p>
</div>
<div class="sect3">
<h4 id="_разделяемая_блокировка_shared_lock">Разделяемая блокировка (shared lock)</h4>
<div class="paragraph">
<p>Резервирует ресурс только для чтения. Другие процессы не могут изменять заблокированный таким образом ресурс, но несколько процессов могут одновременно считывать информацию или накладывать разделяемую блокировку на один и тот же ресурс. Иными словами, чтение ресурса с разделяемой блокировкой могут одновременно выполнять несколько процессов.</p>
</div>
</div>
<div class="sect3">
<h4 id="_монопольная_блокировка_exclusive_lock">Монопольная блокировка (exclusive lock)</h4>
<div class="paragraph">
<p>Резервирует страницу или строку для монопольного использования одной транзакции. Блокировка этого типа применяется такими инструкциями как <em>INSERT</em>, <em>UPDATE</em> и <em>DELETE</em>, которые модифицируют ресурс. Монопольную блокировку нельзя установить, если на ресурс уже установлена разделяемая или монопольная блокировка другим процессом, т.е. на ресурс может быть установлена только одна монопольная блокировка.</p>
</div>
</div>
<div class="sect3">
<h4 id="_блокировка_обновления_update_lock">Блокировка обновления (update lock)</h4>
<div class="paragraph">
<p>Является промежуточной между разделяемой блокировкой и монопольной. Блокировка обновления устанавливается при намерении транзакции изменить данные, но при этом само изменение не происходит. В этом случае другим транзакциям разрешается устанавливать разделяемые блокировки, но не позволяется устанавливать монопольные блокировки, до тех пор пока транзакция не завершится.</p>
</div>
</div>
<div class="sect3">
<h4 id="_блокировки_намерения">Блокировки намерения</h4>
<div class="paragraph">
<p>Чтобы наложить монопольную блокировку на страницу данных, сервер должен убедиться, что ни на одну из записей, входящих в эту страницу, никакая блокировка не наложена. То есть необходимо перебрать все записи, входящие в страницу, и проверить их на наличие блокировок. То же самое, только в гораздо большем объеме, необходимо делать и для таблицы. Это было бы достаточно дорогостоящей операцией, но тут на помощь приходят блокировки намерения. Прежде чем ставить блокировку на конкретную запись, ставится соответствующая блокировка намерения на таблицу и страницу. Таким образом, отпадает необходимость проверять все записи, достаточно проверить, есть ли блокировка намерения на соответствующем уровне иерархии.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sql_транзакции">SQL-транзакции</h3>
<div class="paragraph">
<p><strong>Транзакция</strong> представляет собой единицу работы, которая выполняется с базой данных.</p>
</div>
<div class="paragraph">
<p>Транзакцию можно рассматривать как внесение одного или нескольких изменений в базу данных. Например, если необходимо создать запись или выполнить обновление, удаление записи из таблицы, то выполняется транзакция в этой таблице.</p>
</div>
<div class="sect3">
<h4 id="_свойства_транзакций">Свойства транзакций</h4>
<div class="paragraph">
<p>Транзакции имеют следующие четыре стандартных свойств, как правило, называют аббревиатурой <strong>ACID</strong>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Atomicity</strong> – гарантирует, что все операции в рамках единицы работы завершены успешно, иначе транзакция прерывается в точке выхода из строя, и все предыдущие операции откатываются в прежнее состояние.</p>
</li>
<li>
<p><strong>Consistency</strong> – гарантирует, что база данных правильно изменяет состояния на более успешное совершенные транзакции.</p>
</li>
<li>
<p><strong>Isolation</strong> – позволяет транзакции работать независимо и прозрачно друг с другом.</p>
</li>
<li>
<p><strong>Durability</strong> – гарантирует, что результат или эффект зафиксированной транзакции сохраняется в случае сбоя системы.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_управление_транзакцией">Управление транзакцией</h4>
<div class="paragraph">
<p>Следующие команды используются для управления операциями.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>COMMIT</code> – для сохранения изменений.</p>
</li>
<li>
<p><code>ROLLBACK</code> – откат изменений.</p>
</li>
<li>
<p><code>SAVEPOINT</code> – создает точки внутри групп операций, которые следует откатить.</p>
</li>
<li>
<p><code>SET TRANSACTION</code> – устанавливает характеристики транзакции.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_уровни_изоляции">Уровни изоляции</h4>
<div class="paragraph">
<p>Чаще всего транзакции не должна зависеть от других транзакций, но применение жестких ограничений (блокировок) приводит к эффекту выстраивания в очередь транзакций на выполнение, что замедляет производительность системы.
Но бывают случаи, когда жесткие ограничения не нужны, поэтому существуют <strong>уровни изоляции</strong>, которые определяют степень параллелизма транзакций.
Существуют четыре вида изоляции:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Read uncommitted</strong>;</p>
</li>
<li>
<p><strong>Read committed</strong>;</p>
</li>
<li>
<p><strong>Repeatable read</strong>;</p>
</li>
<li>
<p><strong>Serializable</strong>.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_read_uncommitted_dirty_read">Read uncommitted (Dirty read)</h5>
<div class="paragraph">
<p>Позволяет читать данные незафиксированных транзакций.
<strong>Пример</strong>: первая транзакция ввела данные, но не зафиксировала изменения, вторая прочитала, но первая отменила свои изменения данных.
В таком случае, получилась ситуация, в которой вторая транзакция прочитала несуществующие данные. Такой эффект называют <strong>грязным чтением</strong>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_read_committed">Read Committed</h5>
<div class="paragraph">
<p>При таком уровне изоляции транзакции не дадут прочитать данные, которые не зафиксировала другая транзакция после изменения.</p>
</div>
<div class="paragraph">
<p>Если первая транзакция один раз прочитала данные, а вторая транзакция сразу же их изменила и зафиксировала, то повторное чтение данных первой транзакции вернет измененные значения.
В таком случае может возникнуть ситуация, при которой первая транзакция, к концу своего выполнения, обладает недостоверной информацией, которая может повлиять на вносимые данные.</p>
</div>
</div>
<div class="sect4">
<h5 id="_repeatable_read">Repeatable Read</h5>
<div class="paragraph">
<p>Изменение данных, которые ранее прочитала первая транзакция, другими транзакциями до завершения первой невозможно.
Однако имеет место ситуация, когда другие транзакции будут не изменять, а добавлять новые данные, удовлетворяющие условию выборки первой транзакции по определенному условию.
В таком случае повторная выборка первой транзакции вернет новые значения.</p>
</div>
</div>
<div class="sect4">
<h5 id="_serializable">Serializable</h5>
<div class="paragraph">
<p><strong>Serializable</strong> - уровень изоляции который бьет по производительности системы, но позволяет избежать проблем с чтением данных.
При таком уровне транзакции работают последовательно.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_объекты_бд">Объекты БД</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_виды_объектов_бд">Виды объектов БД</h3>
<div class="paragraph">
<p><strong>Объектами баз данных</strong> называют их структурные составляющие, такие, как <strong>схемы</strong> (<strong>schema</strong>), <strong>таблицы</strong> (<strong>table</strong>), <strong>представления</strong> (<strong>view</strong>), <strong>функции</strong> (<strong>function</strong>), <strong>процедуры</strong> (<strong>procedure</strong>), <strong>триггеры</strong> (<strong>trigger</strong>), <strong>последовательности</strong> (<strong>sequence</strong>), <strong>ограничения</strong> (<strong>constraints</strong>). Они выполняют различные функции по хранению и обработке информации.</p>
</div>
<div class="sect3">
<h4 id="_схемы">Схемы</h4>
<div class="paragraph">
<p><strong>Схема</strong> (<strong>schema</strong>) — это логический контейнер таблиц и других объектов внутри базы данных, причем каждая база данных может иметь одну или несколько схем.</p>
</div>
<div class="paragraph">
<p>Схемы применяются, чтобы объединить объекты базы данных в логические группы для облегчения управления ими и избежания конфликта имен различных приложений внутри схемы.</p>
</div>
<div class="paragraph">
<div class="title">Схемы</div>
<p><span class="image"><img src="../assets/img/bd-object/postgresql-schema.png" alt="postgresql schema"></span></p>
</div>
<div class="sect4">
<h5 id="_создание_схемы_сreate_schema">Создание схемы (<code>СREATE SCHEMA</code>)</h5>
<div class="paragraph">
<p>Для создания схемы необходимо использовать следующий запрос:</p>
</div>
<div class="listingblock">
<div class="title">Создание схемы</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE SCHEMA имя_схемы;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Таблица, при создании без указания схемы, автоматически помещается в схему <code>public</code>, для создания таблицы в определенной схеме, необходимо указать её имя:</p>
</div>
<div class="listingblock">
<div class="title">Cоздание таблицы в определенной схеме</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE имя_схемы.имя_таблицы ( ... );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Часто бывает нужно создать схему, владельцем которой будет другой пользователь (это один из способов ограничения пользователей пространствами имён). Сделать это можно следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE SCHEMA имя_схемы AUTHORIZATION имя_пользователя;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Возможно опустить имя схемы, в этом случае именем схемы станет имя пользователя. Схемы с именами, начинающимися с <code>pg_</code>, являются системными - пользователям не разрешено использовать такие имена.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE SCHEMA IF NOT EXISTS имя_схемы AUTHORIZATION имя_пользователя;</code></pre>
</div>
</div>
<div class="paragraph">
<p>где <code>IF NOT EXISTS</code> означает <strong>не делать ничего</strong>  (только выдать замечание), если схема с таким именем уже существует.</p>
</div>
<div class="paragraph">
<p><strong>Пример</strong>, создание схемы, в которой сразу создаются таблица и представление:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE SCHEMA hollywood
CREATE TABLE films (title text, release date, awards text[])
CREATE VIEW winners AS
SELECT title, release FROM films WHERE awards IS NOT NULL;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы создать объекты в схеме или обратиться к ним, необходимо указать полное имя, состоящее из имён схемы и объекта, разделённых точкой:</p>
</div>
<div class="listingblock">
<div class="title">Правило обращения к объекту внутри схемы</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">схема.объект</code></pre>
</div>
</div>
<div class="paragraph">
<p>Есть ещё более общий синтаксис</p>
</div>
<div class="listingblock">
<div class="title">Обращение к объекту через базу данных</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">база_данных.схема.объект</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_удаление_схемы_drop_schema">Удаление схемы (<code>DROP SCHEMA</code>)</h5>
<div class="paragraph">
<p>Удалить схему, которая не содержит внутри себя объектов, можно следующим способом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP SCHEMA имя_схемы;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Удалить схему со всеми содержащимися в ней объектами:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP SCHEMA имя_схемы CASCADE;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>RESTRICT</code> позволяет отказать в удалении схемы, если она содержит какие-либо объекты. Это поведение по умолчанию.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP SCHEMA имя_схемы RESTRICT;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_изменение_схемы_alter_schema">Изменение схемы (<code>ALTER SCHEMA</code>)</h5>
<div class="paragraph">
<p><code>ALTER SCHEMA</code> — позволяет изменить определение схемы.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER SCHEMA имя RENAME TO новое_имя

ALTER SCHEMA имя OWNER TO { новый_владелец | CURRENT_USER | SESSION_USER }</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>имя</code> - имя существующей схемы.</p>
</li>
<li>
<p><code>новое_имя</code> - новое имя схемы. Новое имя не может начинаться с <code>pg_</code>, так как такие имена зарезервированы для системных схем.</p>
</li>
<li>
<p><code>новый_владелец</code> - новый владелец схемы.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_схемы_и_права">Схемы и права</h5>
<div class="paragraph">
<p>По умолчанию пользователь не может обращаться к объектам в чужих схемах. Чтобы изменить это, владелец схемы должен дать пользователю право <code>USAGE</code> для данной схемы. Чтобы пользователи могли использовать объекты схемы, может понадобиться назначить дополнительные права на уровне объектов.</p>
</div>
<div class="paragraph">
<p>Пользователю также можно разрешить создавать объекты в схеме, не принадлежащей ему. Для этого ему нужно дать право <code>CREATE</code> в требуемой схеме. Требуется помнить, что по умолчанию все имеют права <code>CREATE</code> и <code>USAGE</code> в схеме <code>public</code>. Благодаря этому все пользователи могут подключаться к заданной базе данных и создавать объекты в её схеме <code>public</code>.</p>
</div>
<div class="paragraph">
<p>Некоторые шаблоны использования позволяют запретить это:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">REVOKE CREATE ON SCHEMA public FROM PUBLIC;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_таблицы_2">Таблицы</h4>
<div class="paragraph">
<p><strong>Таблицы</strong> используются для хранения данных, в базе данных может находиться несколько таблиц.</p>
</div>
<div class="paragraph">
<div class="title">Таблицы</div>
<p><span class="image"><img src="../assets/img/bd-object/postgresql-tables.png" alt="postgresql tables"></span></p>
</div>
<div class="sect4">
<h5 id="_создание_таблицы_create_table_2">Создание таблицы (<code>CREATE TABLE</code>)</h5>
<div class="paragraph">
<p>Для создания таблицы используется команда <code>CREATE TABLE</code>. В этой команде необходимо указать как минимум имя новой таблицы и имена, типы данных каждого столбца.</p>
</div>
<div class="paragraph">
<p><strong>Например</strong>:</p>
</div>
<div class="listingblock">
<div class="title">Создание таблицы</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE my_first_table (
    first_column text,
    second_column integer
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Число столбцов в таблице <strong>не может быть бесконечным</strong>. Это число ограничивается максимумом в пределах`от <code>250</code> до <code>1600</code>, в зависимости от типов столбцов. Однако, создавать таблицы с таким большим числом столбцов обычно не требуется, а если такая потребность возникает, это скорее признак сомнительного дизайна.</p>
</div>
</div>
<div class="sect4">
<h5 id="_удаление_таблицы_drop_table">Удаление таблицы (<code>DROP TABLE</code>)</h5>
<div class="paragraph">
<p>Если таблица больше не нужна, можно удалить её, выполнив следующую команду <code>DROP TABLE</code>:</p>
</div>
<div class="listingblock">
<div class="title">Удаление таблицы</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP TABLE my_first_table;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_изменение_таблицы_alter_table">Изменение таблицы (<code>ALTER TABLE</code>)</h5>
<div class="paragraph">
<p><code>ALTER TABLE</code> меняет определение существующей таблицы.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE [ IF EXISTS ] [ ONLY ] имя [ * ]
действие [, ... ]

ALTER TABLE [ IF EXISTS ] [ ONLY ] имя [ * ]
RENAME [ COLUMN ] имя_столбца TO новое_имя_столбца

ALTER TABLE [ IF EXISTS ] [ ONLY ] имя [ * ]
RENAME CONSTRAINT имя_ограничения TO имя_нового_ограничения

ALTER TABLE [ IF EXISTS ] имя
RENAME TO новое_имя

ALTER TABLE [ IF EXISTS ] имя
SET SCHEMA новая_схема</code></pre>
</div>
</div>
<div class="paragraph">
<p>Действия могут быть различными, приведем несколько примеров:</p>
</div>
<div class="listingblock">
<div class="title">Действия</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ADD [ COLUMN ] [ IF NOT EXISTS ] имя_столбца тип_данных
[ COLLATE правило_сортировки ] [ ограничение_столбца [ ... ] ]

DROP [ COLUMN ] [ IF EXISTS ] имя_столбца [ RESTRICT | CASCADE ]

ADD ограничение_таблицы [ NOT VALID ]

DROP CONSTRAINT [ IF EXISTS ] имя_ограничения [ RESTRICT | CASCADE ]

DISABLE TRIGGER [ имя_триггера | ALL | USER ]

ENABLE TRIGGER [ имя_триггера | ALL | USER ]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_представления_view">Представления (View)</h4>
<div class="paragraph">
<p><strong>Представления</strong> (<strong>View</strong>) - это именованные <strong>правила выборки данных</strong>.
Они предназначены для извлечения данных из одной или нескольких таблиц, на которые основываются.</p>
</div>
<div class="paragraph">
<p>Еще можно сказать, что <strong>представление это виртуальная таблица</strong>, которая используется для упрощения сложных запросов и обеспечения безопасности для набора записей.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../assets/img/bd-object/postgresql-views.png" alt="postgresql views"></span></p>
</div>
<div class="paragraph">
<p><strong>Преимущества представления</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Обеспечивают независимость пользовательских программ от изменения логической структуры базы данных.</p>
</li>
<li>
<p>Возможность различным пользователям по-разному видеть одни и те же данные.</p>
</li>
<li>
<p>Дополнительный механизм для управления санкционированным доступом.
Представления защищают данные, так как могут дать доступ к части таблицы, а не ко всей таблице.</p>
</li>
<li>
<p>Повторное использование написанного запроса.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_создание_представления_create_view">Создание представления (<code>CREATE VIEW</code>)</h5>
<div class="paragraph">
<p>Предположим, что появилась необходимость вывести список из названий городов, но нет потребности каждый раз вводить весь запрос.
Можно создать <strong>представление</strong> по данному запросу, фактически присвоить имя запросу, а затем обращаться к нему как к обычной таблице:</p>
</div>
<div class="listingblock">
<div class="title">Создание и использование представления:</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE VIEW myview AS
    SELECT name
    FROM cities;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь получить список названий (<code>name</code>) всех городов можно через представление используя следующий запрос:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT * FROM myview;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для изменения представления можно воспользоваться запросом:</p>
</div>
<div class="listingblock">
<div class="title">Изменение представления благодаря <code>OR REPLACE</code></div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE OR REPLACE VIEW myview AS
    SELECT name, id
    FROM cities;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Команда <code>CREATE OR REPLACE VIEW</code> действует подобным образом, но если представление с этим именем уже существует, оно заменяется.
Новый запрос должен выдавать те же столбцы, что выдавал запрос, ранее определённый для этого представления, (то есть, столбцы с такими же именами должны иметь те же типы данных и следовать в том же порядке), но может добавить несколько новых столбцов в конце списка.
Вычисления, в результате которых формируются столбцы представления, могут быть совершенно другими.</p>
</div>
<div class="paragraph">
<p>Это означает, что <strong>возникнет ошибка</strong>, если переопределить представление следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE OR REPLACE VIEW myview AS
    SELECT id, name
    FROM cities;

ERROR: ОШИБКА:  изменить имя столбца "name" на "id" в представлении нельзя</code></pre>
</div>
</div>
<div class="paragraph">
<p>Или при попытке исключить столбец:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE OR REPLACE VIEW myview AS
    SELECT id
    FROM cities;

ERROR: ОШИБКА:  удалять столбцы из представления нельзя</code></pre>
</div>
</div>
<div class="paragraph">
<p>Рассмотрим механизм создания представления поподробнее.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис создания представления</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] [ RECURSIVE ] VIEW имя [ ( имя_столбца
[, ...] ) ]
[ WITH ( имя_параметра_представления [= значение_параметра_представления]
[, ... ] ) ]
AS запрос
[ WITH [ CASCADED | LOCAL ] CHECK OPTION ]</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TEMPORARY</code> или <code>TEMP</code> - с такими параметрами представление создаётся как временное. Временные представления автоматически удаляются в конце сеанса. Существующее постоянное представление с тем же именем не будет видно в текущем сеансе, пока существует временное, однако к нему можно обратиться, дополнив имя указанием схемы. Если в определении представления задействованы временные таблицы, представление так же создаётся как временное (вне зависимости от присутствия явного указания <code>TEMPORARY</code>).</p>
</li>
<li>
<p><code>RECURSIVE</code> - создаёт рекурсивное представление.</p>
</li>
<li>
<p><code>запрос</code> - команда <code>SELECT</code> или <code>VALUES</code>, которая выдаёт столбцы и строки представления.</p>
</li>
<li>
<p><code>WITH [ CASCADED | LOCAL ] CHECK OPTION</code> - это указание управляет поведением автоматически изменяемых представлений. Если оно присутствует, при выполнении операций <code>INSERT</code> и <code>UPDATE</code> с этим представлением будет проверяться, удовлетворяют ли новые строки условию, определяющему представление (то есть, проверяется, будут ли новые строки видны через это представление). Если они не удовлетворяют условию, операция не будет выполнена. Если указание <code>CHECK OPTION</code> отсутствует, команды <code>INSERT</code> и <code>UPDATE</code> смогут создавать в этом представлении строки, которые не будут видны в нём.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Поддерживаются следующие варианты проверки:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>LOCAL</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Новые строки проверяются только по условиям, определённым непосредственно в самом представлении. Любые условия, определённые в нижележащих базовых представлениях, не проверяются (если только в них нет указания <code>CHECK OPTION</code>).</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CASCADED</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Новые строки проверяются по условиям данного представления и всех нижележащих базовых. Если указано <code>CHECK OPTION</code>, а <code>LOCAL</code> и <code>CASCADED</code> опущено, подразумевается указание <code>CASCADED</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_удаление_представления_drop_view">Удаление представления (<code>DROP VIEW</code>)</h5>
<div class="paragraph">
<p>Удалить представление можно следующим образом:</p>
</div>
<div class="listingblock">
<div class="title">Удаление представления</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP VIEW имя_представления;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Удаление представления с объектами, зависящие от данного представления</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP VIEW имя_представления CASCADE;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Отказать в удалении представления, если от него зависят какие-либо объекты. Это поведение по умолчанию</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP VIEW имя_представления RESTRICT;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_изменение_определения_представления_alter_view">Изменение определения представления (<code>ALTER VIEW</code>)</h5>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER VIEW [ IF EXISTS ] имя ALTER [ COLUMN ] имя_столбца SET DEFAULT выражение

ALTER VIEW [ IF EXISTS ] имя ALTER [ COLUMN ] имя_столбца DROP DEFAULT

ALTER VIEW [ IF EXISTS ] имя OWNER TO { новый_владелец | CURRENT_USER | SESSION_USER }

ALTER VIEW [ IF EXISTS ] имя RENAME TO новое_имя

ALTER VIEW [ IF EXISTS ] имя SET SCHEMA новая_схема

ALTER VIEW [ IF EXISTS ] имя SET ( имя_параметра_представления
[= значение_параметра_представления] [, ... ] )

ALTER VIEW [ IF EXISTS ] имя RESET ( имя_параметра_представления [, ... ] )</code></pre>
</div>
</div>
<div class="paragraph">
<p>Выполнить <code>ALTER VIEW</code> может только владелец представления. Чтобы сменить схему представления, необходимо также иметь право <code>CREATE</code> в новой схеме. Чтобы сменить владельца, требуется также быть непосредственным или опосредованным членом новой роли, а эта роль должна иметь право <code>CREATE</code> в схеме представления.</p>
</div>
<div class="paragraph">
<p><strong>Параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>имя</code> - имя существующего представления (возможно, дополненное схемой).</p>
</li>
<li>
<p><code>IF EXISTS</code> - не считать ошибкой, если представление не существует.
В этом случае будет выдано замечание.</p>
</li>
<li>
<p><code>SET/DROP DEFAULT</code> - эти формы устанавливают или удаляют значение по умолчанию в заданном столбце.
Значение по умолчанию подставляется в команды <code>INSERT</code> и <code>UPDATE</code>, вносящие данные в представление, до применения каких-либо правил или триггеров в этом представлении.
Таким образом, значения по умолчанию в представлении имеют приоритет перед значениями по умолчанию в нижележащих отношениях.</p>
</li>
<li>
<p><code>новый_владелец</code> - имя пользователя, назначаемого новым владельцем представления.</p>
</li>
<li>
<p><code>новое_имя</code> - новое имя представления.</p>
</li>
<li>
<p><code>новая_схема</code> - новая схема представления.</p>
</li>
<li>
<p><code>SET</code> и <code>RESET</code> - устанавливает или сбрасывает параметры представления.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_материализованное_представление_matview">Материализованное представление (matview)</h4>
<div class="paragraph">
<p><strong>Материализованное представление</strong> — это объект базы данных, который содержит результаты запроса.</p>
</div>
<div class="paragraph">
<p>Материализованное представление похоже на представление базы данных, за исключением того, что оно физически хранится на диске и обновляется вручную.
<strong>Matview</strong> хранит результаты запроса в собственной табличной структуре, из которой можно запрашивать данные.
<strong>Невозможно добавлять или удалять строки</strong>, но в остальное время он ведет себя как настоящая таблица.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 18. Разница <strong>vies</strong> и <strong>matview</strong></caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Что сравниваем</th>
<th class="tableblock halign-left valign-top">VIEW</th>
<th class="tableblock halign-left valign-top">MATVIEW</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Способ хранения</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VIEW никогда не сохраняется, он только отображается.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Материализованное представление хранится на диске.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Способ обновления</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Представление обновляется каждый раз, когда используется виртуальная таблица (представление).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Материализованное представление должно обновляться вручную или с использованием триггеров.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Скорость</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Медленная обработка.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Быстрая обработка.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Использованием памяти</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Просмотр не требует места в памяти.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Материализованный вид использует пространство памяти.</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="title">Создание материализованного представления</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE MATERIALIZED VIEW [ IF NOT EXISTS ] имя_таблицы
    [ (имя_столбца [, ...] ) ]
    [ WITH ( параметр_хранения [= значение] [, ... ] ) ]
    [ TABLESPACE табл_пространство ]
AS запрос
    [ WITH [ NO ] DATA ]</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IF NOT EXISTS</code> - не считать ошибкой, если материализованное представление с таким именем уже существует. В этом случае будет выдано замечание. Заметьте, что нет никакой гарантии, что существующее материализованное представление как-то соотносится с тем, которое могло бы быть создано.</p>
</li>
<li>
<p><code>имя_таблицы</code> - имя создаваемого материализованного представления (возможно, дополненное схемой).</p>
</li>
<li>
<p><code>имя_столбца</code> - имя столбца в создаваемом материализованном представлении. Если имена столбцов не заданы явно, они определяются по именам столбцов результата запроса.</p>
</li>
<li>
<p><code>WITH ( параметр_хранения [= значение] [, &#8230;&#8203; ] )</code>
Это предложение задаёт дополнительные параметры хранения для создаваемого материализованного представления. Все параметры, которые поддерживает <code>CREATE TABLE</code>, поддерживает и <code>CREATE MATERIALIZED VIEW</code>.</p>
</li>
<li>
<p><code>TABLESPACE (табл_пространство)</code> — имя табличного пространства, в котором будет создано материализованное представление.</p>
</li>
<li>
<p><code>запрос</code> - команды <code>SELECT</code> или <code>VALUES</code>. Эти команды будут выполняться с ограничениями по безопасности. В частности, будут запрещены вызовы функций, которые сами создают временные таблицы.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_удаление_материализованного_представления_drop_materialized_view">Удаление материализованного представления (<code>DROP MATERIALIZED VIEW</code>)</h5>
<div class="listingblock">
<div class="title">Удаление материализованного представления</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP MATERIALIZED VIEW [ IF EXISTS ] имя [, ...] [ CASCADE | RESTRICT ]</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>где</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CASCADE</code> - автоматически удалять объекты, зависящие от данного материализованного представления (например, другие материализованные или обычные представления), и, в свою очередь, все зависящие от них объекты.</p>
</li>
<li>
<p><code>RESTRICT</code> - отказать в удалении материализованного представления, если от него зависят какие-либо объекты. Это поведение по умолчанию.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_изменение_материализованного_представления_alter_materialized_view">Изменение материализованного представления (<code>ALTER MATERIALIZED VIEW</code>)</h5>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER MATERIALIZED VIEW [ IF EXISTS ] имя
действие [, ... ]

ALTER MATERIALIZED VIEW имя
DEPENDS ON EXTENSION имя_расширения

ALTER MATERIALIZED VIEW [ IF EXISTS ] имя
RENAME [ COLUMN ] имя_столбца TO новое_имя_столбца

ALTER MATERIALIZED VIEW [ IF EXISTS ] имя
RENAME TO новое_имя

ALTER MATERIALIZED VIEW [ IF EXISTS ] имя
SET SCHEMA новая_схема</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Возможные действия</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER [ COLUMN ] имя_столбца SET STATISTICS integer

ALTER [ COLUMN ] имя_столбца SET ( атрибут = значение [, ... ] )

ALTER [ COLUMN ] имя_столбца RESET ( атрибут [, ... ] )

SET ( параметр_хранения [= значение] [, ... ] )

RESET ( параметр_хранения [, ... ] )

OWNER TO { новый_владелец | CURRENT_USER | SESSION_USER }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ALTER MATERIALIZED VIEW</code> изменяет различные расширенные свойства существующего материализованного представления.</p>
</div>
<div class="paragraph">
<p>Выполнить <code>ALTER MATERIALIZED VIEW</code> может только владелец материализованного представления. Чтобы сменить схему материализованного представления, необходимо также иметь право <code>CREATE</code> в новой схеме. Чтобы сменить владельца, требуется также быть непосредственным или опосредованным членом новой роли, а эта роль должна иметь право <code>CREATE</code> в схеме материализованного представления.</p>
</div>
<div class="paragraph">
<p><strong>Параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>имя</code> - имя существующего материализованного представления (возможно, дополненное схемой).</p>
</li>
<li>
<p><code>имя_столбца</code> - имя нового или существующего столбца.</p>
</li>
<li>
<p><code>имя_расширения</code> - имя расширения, от которого будет зависеть материализованное представление.</p>
</li>
<li>
<p><code>новое_имя_столбца</code> - новое имя существующего столбца.</p>
</li>
<li>
<p><code>новый_владелец</code> - имя пользователя, назначаемого новым владельцем материализованного представления.</p>
</li>
<li>
<p><code>новое_имя</code> - новое имя материализованного представления.</p>
</li>
<li>
<p><code>новая_схема</code> - новая схема материализованного представления.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_замена_содержимого_материализованного_представления_refresh_materialized_view">Замена содержимого материализованного представления (<code>REFRESH MATERIALIZED VIEW</code>)</h5>
<div class="listingblock">
<div class="title">Cинтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">REFRESH MATERIALIZED VIEW [ CONCURRENTLY ] имя
[ WITH [ NO ] DATA ]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>REFRESH MATERIALIZED VIEW</code> полностью заменяет содержимое материализованного представления. Эту команду разрешено выполнять только владельцам материализованного представления. Старое его содержимое при этом аннулируется. Если добавлено указание <code>WITH DATA</code> (или нет никакого), нижележащий запрос выполняется и выдаёт новые данные, так что материализованное представление остаётся в сканируемом состоянии. Если указано <code>WITH NO DATA</code>, новые данные не выдаются, и оно оказывается в несканируемом состоянии. Указать <code>CONCURRENTLY</code> вместе с <code>WITH NO DATA</code> нельзя.</p>
</div>
<div class="paragraph">
<p><strong>Параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CONCURRENTLY</code> - обновить материализованное представление, не блокируя параллельные выборки из него. Без данного параметра обновление, затрагивающее много строк, обычно задействует меньше ресурсов и выполнится быстрее, но может препятствовать чтению этого материализованного представления другими сеансами. При этом данный режим может быть быстрее при небольшом количестве строк. Данный параметр допускается, только если в материализованном представлении есть хотя бы один индекс <code>UNIQUE</code>, построенный только по именам столбцов и включающий все строки (то есть это не должен быть индекс по выражению или индекс, содержащий <code>WHERE</code>). Этот параметр нельзя использовать, когда материализованное представление ещё не наполнено. Даже с этим параметром в один момент времени допускается только одно обновление (<code>REFRESH</code>) материализованного представления.</p>
</li>
<li>
<p><code>имя</code> - имя (возможно, дополненное схемой) материализованного представления, подлежащего обновлению.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_функции_2">Функции</h4>
<div class="paragraph">
<p><strong>Функция</strong> — это многократно используемый блок кода SQL, который возвращает скалярное значение списка записей.</p>
</div>
<div class="paragraph">
<div class="title">Функции</div>
<p><span class="image"><img src="../assets/img/bd-object/postgresql-functions.png" alt="postgresql functions"></span></p>
</div>
<div class="sect4">
<h5 id="_создание_функции_create_function">Создание функции (<code>CREATE FUNCTION</code>)</h5>
<div class="paragraph">
<p>Чтобы заменить текущее определение существующей функции, используется команда <code>CREATE OR REPLACE FUNCTION</code>. Но следует учесть, что она не позволяет изменить имя или аргументы функции (если попытаться сделать это, на самом деле будет создана новая, независимая функция). Кроме того, <code>CREATE OR REPLACE FUNCTION</code> не позволит изменить тип результата существующей функции. Чтобы сделать это, придётся удалить функцию и создать её заново. Если удалить и затем вновь создадать функцию, новая функция станет другой сущностью, отличной от старой - потребуется так же удалить существующие правила, представления, триггеры, ссылающиеся на старую функцию. Поэтому, чтобы изменить определение функции, сохраняя ссылающиеся на неё объекты, следует использовать <code>CREATE OR REPLACE FUNCTION</code>.</p>
</div>
<div class="paragraph">
<p>Владельцем функции становится создавший её пользователь. Чтобы создать функцию, необходимо иметь право <code>USAGE</code> для типов её аргументов и возвращаемого типа.</p>
</div>
<div class="listingblock">
<div class="title">Cинтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE [ OR REPLACE ] FUNCTION
    имя ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента [ { DEFAULT |
= } выражение_по_умолчанию ] [, ...] ] )
    [ RETURNS тип_результата
    | RETURNS TABLE ( имя_столбца тип_столбца [, ...] ) ]
{ LANGUAGE имя_языка
    | TRANSFORM { FOR TYPE имя_типа } [, ... ]
    | WINDOW
    | { IMMUTABLE | STABLE | VOLATILE }
    | [ NOT ] LEAKPROOF
    | { CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT }
    | { [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER }
    | PARALLEL { UNSAFE | RESTRICTED | SAFE }
    | COST стоимость_выполнения
    | ROWS строк_в_результате
    | SUPPORT вспомогательная_функция
    | SET параметр_конфигурации { TO значение | = значение | FROM CURRENT }
    | AS 'определение'
    | AS 'объектный_файл', 'объектный_символ'
} ...</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Основные параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>имя</code> - имя создаваемой функции (возможно, дополненное схемой).</p>
</li>
<li>
<p><code>режим_аргумента</code> - режим аргумента: <code>IN</code> (входной), <code>OUT</code> (выходной), <code>INOUT</code> (входной и выходной) или <code>VARIADIC</code> (переменный). По умолчанию подразумевается <code>IN</code>. За единственным аргументом <code>VARIADIC</code> могут следовать только аргументы <code>OUT</code>. Кроме того, аргументы <code>OUT</code> и <code>INOUT</code> нельзя использовать с предложением <code>RETURNS TABLE</code>.</p>
</li>
<li>
<p><code>имя_аргумента</code> - имя аргумента.</p>
</li>
<li>
<p><code>тип_аргумента</code> - тип данных аргумента функции (возможно, дополненный схемой), при наличии аргументов. Тип аргументов может быть базовым, составным или доменным, либо это может быть ссылка на столбец таблицы.</p>
</li>
<li>
<p><code>выражение_по_умолчанию</code> - выражение, используемое для вычисления значения по умолчанию, если параметр не задан явно. Результат выражения должен сводиться к типу соответствующего параметра.</p>
</li>
<li>
<p><code>тип_результата</code> - тип возвращаемых данных (возможно, дополненный схемой). Это может быть базовый, составной или доменный тип, либо ссылка на тип столбца таблицы.</p>
</li>
<li>
<p><code>имя_столбца</code> - имя выходного столбца в записи <code>RETURNS TABLE</code>.</p>
</li>
<li>
<p><code>тип_столбца</code> - тип данных выходного столбца в записи <code>RETURNS TABLE</code>.</p>
</li>
<li>
<p><code>имя_языка</code> - имя языка, на котором реализована функция.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Пример</strong>:</p>
</div>
<div class="listingblock">
<div class="title">Пример создания функции на языке <code>SQL</code></div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE FUNCTION add(integer, integer) RETURNS integer
    AS 'select $1 + $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Пример создания функции на языке <code>PL/pgSQL</code></div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE FUNCTION add(integer, integer) RETURNS integer AS $$
    BEGIN
    RETURN $1 + $2;
    END; $$
    LANGUAGE plpgsql
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Вызов функции <code>add</code></div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT * FROM add(100,12);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ответом функции будет значение <code>112</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_удаление_функции_drop_function">Удаление функции (<code>DROP FUNCTION</code>)</h5>
<div class="paragraph">
<p><code>DROP FUNCTION</code> удаляет определение существующей функции. Пользователь, выполняющий эту команду, должен быть владельцем функции. Помимо имени функции требуется указать типы её аргументов, так как в базе данных могут существовать несколько функций с одним именем, но с разными списками аргументов.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP FUNCTION [ IF EXISTS ] имя [ ( [ [ режим_аргумента ] [ имя_аргумента
] тип_аргумента [, ...] ] ) ] [, ...]
[ CASCADE | RESTRICT ]</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>имя</code> - имя существующей функции (возможно, дополненное схемой). Если список аргументов не указан, имя функции должно быть уникальным в её схеме.</p>
</li>
<li>
<p><code>режим_аргумента</code> - режим аргумента: <code>IN</code>, <code>OUT</code>, <code>INOUT</code> или <code>VARIADIC</code>. По умолчанию подразумевается <code>IN</code>. Заметьте, что <code>DROP FUNCTION</code> не учитывает аргументы <code>OUT</code>, так как для идентификации функции нужны только типы входных аргументов.
Поэтому достаточно перечислить только аргументы <code>IN</code>, <code>INOUT</code> и <code>VARIADIC</code>.</p>
</li>
<li>
<p><code>имя_аргумента</code> - имя аргумента.</p>
</li>
<li>
<p><code>тип_аргумента</code> - тип данных аргументов функции (возможно, дополненный именем схемы), если таковые имеются.</p>
</li>
<li>
<p><code>CASCADE</code> - автоматически удалять объекты, зависящие от данной функции (например, операторы или триггеры), и, в свою очередь, все зависящие от них объекты.</p>
</li>
<li>
<p><code>RESTRICT</code> - отказать в удалении функции, если от неё зависят какие-либо объекты. Это поведение по умолчанию.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_изменить_определение_функции_alter_function">Изменить определение функции (<code>ALTER FUNCTION</code>)</h5>
<div class="paragraph">
<p><code>ALTER FUNCTION</code> позволяет изменить определение функции</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER FUNCTION имя [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, ...] ] ) ]
действие [ ... ] [ RESTRICT ]

ALTER FUNCTION имя [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, ...] ] ) ]
RENAME TO новое_имя

ALTER FUNCTION имя [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, ...] ] ) ]
OWNER TO { новый_владелец | CURRENT_USER | SESSION_USER }

ALTER FUNCTION имя [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, ...] ] ) ]
SET SCHEMA новая_схема

ALTER FUNCTION имя [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, ...] ] ) ]
[ NO ] DEPENDS ON EXTENSION имя_расширения</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Примеры</strong>:</p>
</div>
<div class="listingblock">
<div class="title">Переименование функции</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER FUNCTION sqrt(integer) RENAME TO square_root;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Смена владельца функции</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER FUNCTION sqrt(integer) OWNER TO joe;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_хранимые_процедуры">Хранимые процедуры</h4>
<div class="paragraph">
<p>Когда с данными нужно делать одни и те же действия очень часто на помощь приходят процедуры.</p>
</div>
<div class="paragraph">
<p><strong>Процедуры</strong> (<strong>procedure</strong>) - это блок операторов написанных на процедурном расширении языка <code>SQL</code> в контексте конкретной <strong>СУБД</strong>. Процедуры хранятся в базе данных в специально приспособленных для этого системных таблицах. Процедуры и функции могут быть вызваны на использование внутри базы данных или из клиентского приложения, но не возвращают результат, а функции возвращают.</p>
</div>
<div class="paragraph">
<p>Процедура является объектом базы данных, подобный функции, но имеющий следующие отличия:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Процедуры определяются командой <code>CREATE PROCEDURE</code>.</p>
</li>
<li>
<p>Процедуры, в отличие от функций, не возвращают значение; поэтому в <code>CREATE PROCEDURE</code> отсутствует предложение <code>RETURNS</code>. Однако процедуры могут выдавать данные в вызывающий код через выходные параметры.</p>
</li>
<li>
<p>Процедуры вызываются отдельно командой <code>CALL</code>.</p>
</li>
<li>
<p>Процедура, в отличие от функции, может фиксировать или откатывать транзакции во время её выполнения (а затем автоматически начинать новую транзакцию), если вызывающая команда <code>CALL</code> находится не в явном блоке транзакции.</p>
</li>
<li>
<p>Некоторые атрибуты функций (например, <code>STRICT</code>) неприменимы к процедурам.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_создание_процедуры_create_procedure">Создание процедуры (<code>CREATE PROCEDURE</code>)</h5>
<div class="listingblock">
<div class="title">Cинтаксис создания процедуры</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE [ OR REPLACE ] PROCEDURE
    имя ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента [   { DEFAULT |
    = } выражение_по_умолчанию ] [, ...] ] )
 { LANGUAGE имя_языка
    | TRANSFORM { FOR TYPE имя_типа } [, ... ]
    | [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER
    | SET параметр_конфигурации { TO значение | = значение | FROM   CURRENT }
    | AS 'определение'
    | AS 'объектный_файл', 'объектный_символ'
 } ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Команда <code>CREATE PROCEDURE</code> определяет новую процедуру, в тоже время <code>CREATE OR REPLACE PROCEDURE</code> создаёт новую процедуру либо заменяет определение уже существующей.</p>
</div>
<div class="paragraph">
<p>Чтобы определить процедуру, необходимо иметь право <code>USAGE</code> для соответствующего языка. Если указано имя схемы, процедура создаётся в заданной схеме, в противном случае — в текущей. Имя новой процедуры должно отличаться от имён существующих процедур и функций с такими же типами аргументов в этой схеме. Однако процедуры и функции с аргументами разных типов могут иметь одно имя (это называется перегрузкой).</p>
</div>
<div class="paragraph">
<p>Команда <code>CREATE OR REPLACE PROCEDURE</code> предназначена для изменения текущего определения существующей процедуры. С её помощью нельзя изменить имя или типы аргументов (если попытаться сделать это, будет создана новая отдельная процедура). Когда команда <code>CREATE OR REPLACE PROCEDURE</code> заменяет существующую процедуру, владелец и права доступа к этой процедуре не меняются. Все другие свойства процедуры получают значения, задаваемые командой явно или по умолчанию. Чтобы заменить процедуру, необходимо быть её владельцем (или быть членом роли-владельца). Владельцем процедуры становится создавший её пользователь. Чтобы создать процедуру, необходимо иметь право <code>USAGE</code> для типов её аргументов.</p>
</div>
<div class="paragraph">
<p><strong>Параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>имя</code> - имя создаваемой процедуры.</p>
</li>
<li>
<p><code>режим_аргумента</code> - режим аргумента: <code>IN</code>, <code>INOUT</code> или <code>VARIADIC</code>. По умолчанию подразумевается <code>IN</code>. (Режим <code>OUT</code> для процедур в настоящее время не поддерживается. Используйте вместо него <code>INOUT</code>).</p>
</li>
<li>
<p><code>имя_аргумента</code> - имя аргумента.</p>
</li>
<li>
<p><code>тип_аргумента</code> - тип данных аргумента процедуры (возможно, дополненный схемой), при наличии аргументов. Тип аргументов может быть базовым, составным или доменным, либо это может быть ссылка на столбец таблицы.</p>
</li>
<li>
<p><code>выражение_по_умолчанию</code> - выражение, используемое для вычисления значения по умолчанию, если параметр не задан явно. Результат выражения должен сводиться к типу соответствующего параметра. Для всех входных параметров, следующих за параметром с определённым значением по умолчанию, также должны быть определены значения по умолчанию.</p>
</li>
<li>
<p><code>имя_языка</code> - имя языка, на котором реализована функция.</p>
</li>
<li>
<p><code>TRANSFORM { FOR TYPE имя_типа } [, &#8230;&#8203; ] }</code> - устанавливает список трансформаций, которые должны применяться при вызове процедуры. Трансформации выполняют преобразования между типами <code>SQL</code> и типами данных, специфичными для языков. Преобразования встроенных типов обычно жёстко предопределены в реализациях процедурных языков, так что их здесь указывать не нужно. Если реализация процедурного языка не может обработать тип и трансформация для него отсутствует, будет выполнено преобразование типов по умолчанию, но это зависит от реализации.</p>
</li>
<li>
<p><code>[EXTERNAL] SECURITY INVOKER</code> / <code>[EXTERNAL] SECURITY DEFINER</code> - характеристика <code>SECURITY INVOKER</code> (безопасность вызывающего) показывает, что процедура будет выполняться с правами пользователя, вызвавшего её. Этот вариант подразумевается по умолчанию. Вариант <code>SECURITY DEFINER</code> (безопасность определившего) обозначает, что процедура выполняется с правами пользователя, владеющего ей. Ключевое слово <code>EXTERNAL</code> допускается для соответствия стандарту <code>SQL</code>, но является необязательным, так как, в отличие от <code>SQL</code>, эта характеристика распространяется на все процедуры, а не только внешние. В процедуре с характеристикой <code>SECURITY DEFINER</code> не могут выполняться операторы управления транзакциями (например, <code>COMMIT</code> и <code>ROLLBACK</code> в некоторых языках).</p>
</li>
<li>
<p><code>параметр_конфигурации</code> \ <code>значение</code> - предложение <code>SET</code> определяет, что при вызове процедуры указанный параметр конфигурации должен принять заданное значение, а затем восстановить своё предыдущее значение при завершении процедуры. Предложение <code>SET FROM CURRENT</code> сохраняет в качестве значения, которое будет применено при входе в процедуру, значение, действующее в момент выполнения <code>CREATE PROCEDURE</code>. Если в определение процедуры добавлено <code>SET</code>, то действие команды <code>SET LOCAL</code>, выполняемой внутри процедуры для того же параметра, ограничивается телом процедуры: предыдущее значение параметра так же будет восстановлено при завершении процедуры. Однако обычная команда <code>SET</code> (без <code>LOCAL</code>) переопределяет предложение <code>SET</code>, как и предыдущую команду <code>SET LOCAL</code>: действие такой команды будет сохранено и после завершения процедуры, если только не произойдёт откат транзакции. Если к определению процедуры добавлено <code>SET</code>, то в этой процедуре не могут выполняться операторы управления транзакциями (например, <code>COMMIT</code> и <code>ROLLBACK</code> в некоторых языках).</p>
</li>
<li>
<p><code>определение</code> - строковая константа, определяющая реализацию процедуры; её значение зависит от языка. Это может быть имя внутренней процедуры, путь к объектному файлу, команда <code>SQL</code> или код на процедурном языке. Часто бывает полезно заключать определение процедуры в доллары, а не в традиционные апострофы. Если не использовать доллары, все апострофы и обратные косые черты в определении процедуры придётся экранировать, дублируя их.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Пример</strong></p>
</div>
<div class="listingblock">
<div class="title">Пример создания процедуры</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE PROCEDURE insert_data(a integer, b varchar)
    LANGUAGE SQL
    AS $$
    insert into table_name VALUES (a,b);
    $$;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Процедура <code>insert_data</code> после вызова, занесет в таблицу значения <code>a</code> и <code>b</code>.</p>
</div>
<div class="paragraph">
<p>Чтобы вызвать процедуру воспользуйтесь командой <code>CALL</code>:</p>
</div>
<div class="listingblock">
<div class="title">Вызов процедуры</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CALL insert_data(1, 'data');</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_удаление_процедуры_drop_procedure">Удаление процедуры (<code>DROP PROCEDURE</code>)</h5>
<div class="paragraph">
<p>Чтобы удалить процедуры, необходимо воспользоваться командой <code>DROP PROCEDURE</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP PROCEDURE [ IF EXISTS ] имя [ ( [ [ режим_аргумента ] [ имя_аргумента
 ] тип_аргумента [, ...] ] ) ] [, ...]
 [ CASCADE | RESTRICT ]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DROP PROCEDURE</code> удаляет определение существующей процедуры. Пользователь, выполняющий эту команду, должен быть владельцем процедуры. Помимо имени процедуры требуется указать типы её аргументов, так как в базе данных могут существовать несколько процедур с одним именем, но с разными списками аргументов.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Параметры</strong>:</p>
</li>
<li>
<p><code>IF EXISTS</code> - не считать ошибкой, если процедура не существует. В этом случае будет выдано замечание.</p>
</li>
<li>
<p><code>имя</code> - имя существующей процедуры (возможно, дополненное схемой). Если список аргументов не указан, имя процедуры должно быть уникальным в её схеме.</p>
</li>
<li>
<p><code>режим_аргумента</code> - режим аргумента: <code>IN</code> или <code>VARIADIC</code>. По умолчанию подразумевается <code>IN</code>.</p>
</li>
<li>
<p><code>имя_аргумента</code> - имя аргумента.</p>
</li>
<li>
<p><code>тип_аргумента</code> - тип данных аргументов процедуры (возможно, дополненный именем схемы), если таковые имеются.</p>
</li>
<li>
<p><code>CASCADE</code> - автоматически удалять объекты, зависящие от данной процедуры, и, в свою очередь, все зависящие от них объекты.</p>
</li>
<li>
<p><code>RESTRICT</code> - отказать в удалении процедуры, если от неё зависят какие-либо объекты. Это поведение по умолчанию.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_изменение_процедуры_alter_procedure">Изменение процедуры (<code>ALTER PROCEDURE</code>)</h5>
<div class="paragraph">
<p><code>ALTER PROCEDURE</code> позволяет изменить определение процедуры. Выполнить <code>ALTER PROCEDURE</code> может только владелец процедуры. Чтобы сменить схему процедуры, необходимо также иметь право <code>CREATE</code> в новой схеме. Чтобы сменить владельца, требуется также быть непосредственным или опосредованным членом новой роли, а эта роль должна иметь право <code>CREATE</code> в схеме представления.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER PROCEDURE имя [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, ...] ] ) ]
действие [ ... ] [ RESTRICT ]

ALTER PROCEDURE имя [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, ...] ] ) ]
RENAME TO новое_имя

ALTER PROCEDURE имя [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, ...] ] ) ]
OWNER TO { новый_владелец | CURRENT_USER | SESSION_USER }

ALTER PROCEDURE имя [ ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента
[, ...] ] ) ]
SET SCHEMA новая_схема</code></pre>
</div>
</div>
<div class="paragraph">
<p>Где действие может быть следующим:</p>
</div>
<div class="listingblock">
<div class="title">Возможные действия</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SET параметр_конфигурации { TO | = } { значение | DEFAULT }

SET параметр_конфигурации FROM CURRENT

RESET параметр_конфигурации

RESET ALL</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>новое_имя</code> - новое имя процедуры.</p>
</li>
<li>
<p><code>новый_владелец</code> - новый владелец процедуры. Заметьте, что если процедура помечена как <code>SECURITY DEFINER</code>, в дальнейшем она будет выполняться от имени нового владельца.</p>
</li>
<li>
<p><code>новая_схема</code> - новая схема процедуры.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Переименование процедуры <code>procedure_name</code> с двумя аргументами типа <code>integer</code> в <code>new_procedure_name</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER PROCEDURE procedure_name(integer, integer) RENAME TO new_procedure_name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Смена владельца процедуры <code>procedure_name</code> с двумя аргументами типа <code>integer</code> на <code>user_name</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER PROCEDURE procedure_name(integer, integer) OWNER TO user_name;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_триггеры">Триггеры</h4>
<div class="paragraph">
<p><strong>Триггер</strong> (<strong>trigger)</strong> - процедура, отличается от обычной тем, что она вызывается автоматически, при некотором событии в базе данных. Триггеры применяются для гарантированного выполнения определенных действий при возникновении событий. Триггеры носят глобальный характер и не зависят от причин и способов появления событий, на который они срабатывают.</p>
</div>
<div class="paragraph">
<p>Триггерные функции могут быть написаны на большинстве доступных процедурных языков,  включая <strong>PL/pgSQL</strong>, <strong>PL/Tcl</strong>, <strong>PL/Perl</strong> и <strong>PL/Python</strong>. В настоящее время невозможно написать  триггерную функцию на чистом <strong>SQL</strong>.</p>
</div>
<div class="paragraph">
<div class="title">Триггеры</div>
<p><span class="image"><img src="../assets/img/bd-object/postgresql-triggers.png" alt="postgresql triggers"></span></p>
</div>
<div class="paragraph">
<p>В <strong>PostgreSQL</strong> триггеры создаются на основе существующих функции, т.е. сначала командой <code>CREATE FUNCTION</code> определяется триггерная функция, затем на ее основе командой <code>CREATE TRIGGER</code> определяется собственно триггер.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис определения триггера</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TRIGGER триггер
    { BEFORE | AFTER } { событие [ OR событие ] } ON таблица
    FOR EACH { ROW |  STATEMENT }
    WHEN(условие)
    EXECUTE PROCEDURE функция ( аргументы );</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Параметры</strong>:</p>
</li>
<li>
<p><code>{ BEFORE | AFTER }</code> - ключевое слово <code>BEFORE</code> означает, что функция должна выполняться перед попыткой выполнения операции, включая все встроенные проверки ограничений данных, реализуемые при выполнении команд <code>INSERT</code> и <code>DELETE</code>. Ключевое слово <code>AFTER</code> означает, что функция вызывается после завершения операции, приводящей в действие триггер.</p>
</li>
<li>
<p><code>{ событие [ OR событие &#8230;&#8203; ] }</code> - события, поддерживаемые в <strong>PostgreSQL</strong>: <code>INSERT</code>, <code>UPDATE</code> или <code>DELETE</code>. При перечислении нескольких событий в качестве разделителя используется ключевое слово <code>OR</code>.</p>
</li>
<li>
<p><code>FOR EACH { ROW | STATEMENT }</code> - ключевое слово, следующее за конструкцией <code>FOR EACH</code> и определяющее количество вызовов функции при наступлении указанного события. Ключевое слово <code>ROW</code> означает, что функция вызывается для каждой модифицируемой записи. Если функция должна вызываться всего один раз для всей команды, используется ключевое слово <code>STATEMENT</code>.</p>
</li>
<li>
<p><code>WHEN</code> - необязательный параметр. В определении триггера можно указать логическое условие <code>WHEN</code>, которое определит, вызывать триггер или нет. В триггерах на уровне строк условия <code>WHEN</code> могут проверять старые и/или новые значения столбцов в строке. Триггеры на уровне оператора так же могут содержать условие <code>WHEN</code>, хотя для них это не столь полезно, так как в этом условии нельзя ссылаться на какие-либо значения в таблице.</p>
</li>
<li>
<p><code>EXECUTE PROCEDURE функция ( аргументы )</code>- имя вызываемой функции с аргументами. На практике аргументы при вызове триггерных функций не используются.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Синтаксис определения триггерной функции</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE FUNCTION функция () RETURNS trigger AS '
    BEGIN
    команды;
    return NEW | OLD;
    END;'
LANGUAGE  plpgsql;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cпециальные переменные, доступные в триггерных функциях:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>NEW</code> - Новые значения полей записи базы данных, созданной командой <code>INSERT</code> или обновленной командой <code>UPDATE</code>, при срабатывании триггера уровня записи <code>ROW</code>. В триггерах уровня оператора и для команды <code>DELETE</code> эта переменная имеет значение <code>null</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Внимание !!!</strong> Переменная <code>NEW</code> доступна только при операциях <code>INSERT</code> и <code>UPDATE</code>. Поля записи <code>NEW</code> могут быть изменены триггером. В триггерах уровня оператора и для команды <code>INSERT</code> эта  переменная имеет значение <code>null</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>OLD</code> - Старые значения полей записи базы данных, содержавшиеся в записи перед выполнением команды <code>DELETE</code> или <code>UPDATE</code> при срабатывании триггера уровня записи <code>ROW</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Внимание !!!</strong> Переменная <code>OLD</code> доступна только при операциях <code>DELETE</code> и <code>UPDATE</code>. Поля записи <code>OLD</code> можно использовать только для чтения, изменять нельзя.</p>
</div>
<div class="paragraph">
<p>К отдельным полям записей <code>NEW</code> и <code>OLD</code> в триггерных процедурах обращаются следующим образом: <code>NEW.names</code>, <code>OLD.rg</code>.</p>
</div>
<div class="paragraph">
<p><strong>Указания по возврату из тригеров:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Триггерная функция должна возвращать <code>NULL</code> или запись, соответствующую структуре таблицы, на которую будет вешаться триггер!</p>
</li>
<li>
<p>Если <code>BEFORE</code>-триггер возвращает <code>NULL</code>, то сама операция и <code>AFTER</code>-триггер будут отменены.</p>
</li>
<li>
<p><code>BEFORE</code>-триггер может изменить строку (<code>INSERT</code> \ <code>UPDATE</code>) через <code>NEW</code> и тогда операция и <code>AFTER</code>-триггеры` будут работать с заменённой строкой.</p>
</li>
<li>
<p>Если <code>BEFORE</code>-триггер` не "хочет" изменять строку, то надо просто вернуть <code>OLD</code>.</p>
</li>
<li>
<p><code>NEW</code> = <code>null</code> при <code>DELETE</code>, так что если <code>BEFORE</code>-триггер хочет дать ход <code>DELETE</code>, надо вернуть <code>OLD</code>.</p>
</li>
<li>
<p>Возвращаемое значение из построчного <code>AFTER</code>-триггера (или из <code>BEFORE</code> и из <code>AFTER</code>-триггеров на утверждения) игнорируется &#8658; можно возвращать <code>NULL</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Пример</strong>:</p>
</div>
<div class="listingblock">
<div class="title">Создаем триггер</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TRIGGER tr
    AFTER
    INSERT ON table_name
    FOR EACH ROW
    EXECUTE PROCEDURE func();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Создаем функцию</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE OR REPLACE FUNCTION func() RETURNS trigger AS '
    BEGIN
    delete from table_name where age = 1;
    return NEW;
    END;'
LANGUAGE plpgsql;</code></pre>
</div>
</div>
<div class="paragraph">
<p>После внесения данных в таблицу <code>table_name</code> вызывается функция <code>func()</code>, которая удалит из таблицы значения <code>age = 1</code>;</p>
</div>
<div class="paragraph">
<p>Если есть несколько триггеров на одно и то же событие для одной и той же таблицы, то они  будут вызываться в алфавитном порядке по имени триггера.</p>
</div>
<div class="sect4">
<h5 id="_удаление_триггера_drop_trigger">Удаление триггера (<code>DROP TRIGGER</code>)</h5>
<div class="paragraph">
<p><code>DROP TRIGGER</code> удаляет существующее определение триггера. Пользователь, выполняющий эту команду, должен быть владельцем таблицы, для которой определён данный триггер.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP TRIGGER [ IF EXISTS ] имя ON имя_таблицы [ CASCADE | RESTRICT ]</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IF EXISTS</code> - не считать ошибкой, если триггер не существует. В этом случае будет выдано замечание.</p>
</li>
<li>
<p><code>имя</code> - имя триггера, подлежащего удалению.</p>
</li>
<li>
<p><code>имя_таблицы</code> - имя (возможно, дополненное схемой) таблицы, для которой определён триггер.</p>
</li>
<li>
<p><code>CASCADE</code> - автоматически удалять объекты, зависящие от данного триггера, и, в свою очередь, все зависящие от них объекты .</p>
</li>
<li>
<p><code>RESTRICT</code> - Отказать в удалении триггера, если от него зависят какие-либо объекты. Это поведение по умолчанию.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_изменение_определения_триггера_alter_trigger">Изменение определения триггера (<code>ALTER TRIGGER</code>)</h5>
<div class="paragraph">
<p>Изменять свойства триггера может только владелец таблицы, с которой работает триггер следующим запросом:</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TRIGGER имя ON имя_таблицы RENAME TO новое_имя

ALTER TRIGGER имя ON имя_таблицы [ NO ] DEPENDS ON EXTENSION имя_расширения</code></pre>
</div>
</div>
<div class="paragraph">
<p>Предложение <code>RENAME</code> переименовывает данный триггер, не затрагивая его определение. Предложение <code>DEPENDS ON EXTENSION</code> помечает триггер как зависимый от расширения, так что при удалении расширения будет автоматически удаляться и триггер.</p>
</div>
<div class="paragraph">
<p><strong>Параметры</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Имя</code> - имя существующего триггера, подлежащего изменению.</p>
</li>
<li>
<p><code>Имя_таблицы</code> - имя таблицы, с которой работает триггер.</p>
</li>
<li>
<p><code>Новое_имя</code> - новое имя триггера.</p>
</li>
<li>
<p><code>Имя_расширения</code> - имя расширения, от которого будет зависеть триггер (или не будет, если указано <code>NO</code>).
Триггер, помеченный как зависимый от расширения, автоматически удаляется при удалении расширения.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_последовательности_sequence">Последовательности (<code>Sequence</code>)</h4>
<div class="paragraph">
<p>Последовательности используются для управления столбцами с автоинкрементом, которые определены в таблице, как <code>SERIAL</code>.</p>
</div>
<div class="paragraph">
<div class="title">Последовательности (<code>Sequence</code>)</div>
<p><span class="image"><img src="../assets/img/bd-object/postgresql-sequence.png" alt="postgresql sequence"></span>]</p>
</div>
<div class="sect4">
<h5 id="_создание_последовательности_create_sequence">Создание последовательности (<code>CREATE SEQUENCE</code>)</h5>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE [ TEMPORARY | TEMP ] SEQUENCE [ IF NOT EXISTS ] имя
    [ AS тип_данных ]
    [ INCREMENT [ BY ] шаг ]
    [ MINVALUE мин_значение | NO MINVALUE ] [ MAXVALUE макс_значение | NO MAXVALUE ]
    [ START [ WITH ] начало ] [ CACHE кеш ] [ [ NO ] CYCLE ]
    [ OWNED BY { имя_таблицы.имя_столбца | NONE } ]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Такой запрос создаёт генератор последовательности. Эта операция включает создание и инициализацию специальной таблицы имя, содержащей одну строку. Владельцем генератора будет пользователь, выполняющий эту команду. Если указано имя схемы, последовательность создаётся в заданной схеме, в противном случае — в текущей. Временные последовательности существуют в специальной схеме, так что при создании таких последовательностей имя схемы задать нельзя. Имя последовательности должно отличаться от имён других последовательностей, таблиц, индексов, представлений или сторонних таблиц, уже существующих в этой схеме.</p>
</div>
<div class="paragraph">
<p>Хотя непосредственно изменить значение последовательности нельзя, получить её параметры и текущее состояние можно таким запросом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT * FROM name;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TEMPORARY</code> или <code>TEMP</code> - если указано, объект последовательности создаётся только для данного сеанса и автоматически удаляется при завершении сеанса. Существующая постоянная последовательность с тем же именем не будут видна (в этом сеансе), пока существует временная, однако к ней можно обратиться, дополнив имя указанием схемы.</p>
</li>
<li>
<p><code>IF NOT EXISTS</code> - не считать ошибкой, если отношение с таким именем уже существует. В этом случае будет выдано замечание. Заметьте, что нет никакой гарантии, что существующее отношение как-то соотносится с последовательностью, которая могла бы быть создана — это может быть даже не последовательность.</p>
</li>
<li>
<p><code>тип_данных</code> - необязательное предложение <code>AS</code> тип_данных задаёт тип данных для последовательности. Допустимые типы: <em>smallint</em>, <em>integer</em> и <em>bigint</em>. По умолчанию устанавливается тип <em>bigint</em>. От типа данных зависят принимаемые по умолчанию минимальное и максимальное значения последовательности.</p>
</li>
<li>
<p><code>шаг</code> - необязательное предложение <code>INCREMENT BY</code> шаг определяет, какое число будет добавляться к текущему значению последовательности для получения нового значения. С положительным шагом последовательность будет возрастающей, а с отрицательным — убывающей. Значение по умолчанию: <code>1</code>.</p>
</li>
<li>
<p><code>мин_значение</code> - Необязательное предложение <code>MINVALUE</code> определяет наименьшее число, которое будет генерировать последовательность. Если это предложение опущено либо указано <code>NO MINVALUE</code>, используется значение по умолчанию: <code>1</code> для возвращающей последовательности или минимальное значение типа данных — для убывающей.</p>
</li>
<li>
<p><code>макс_значения</code> - Необязательное предложение <code>MAXVALUE</code> определяет наибольшее число, которое будет генерировать последовательность. Если это предложение опущено либо указано <code>NO MAXVALUE</code>, используется значение по умолчанию: максимальное значение типа данных для возрастающей последовательности или <code>-1</code> — для убывающей</p>
</li>
<li>
<p><code>начало</code> - необязательное предложение <code>START WITH</code> начало позволяет запустить последовательность с любого значения. По умолчанию началом считается мин_значение для возрастающих последовательностей и максимальное значение для убывающих.</p>
</li>
<li>
<p><code>кеш</code> - необязательное предложение <code>CACHE</code> кеш определяет, сколько чисел последовательности будет выделяться и сохраняться в памяти для ускорения доступа к ним. Минимальное значение равно 1 (за один раз генерируется только одно значение, т. е. кеширования нет), и оно же предполагается по умолчанию.</p>
</li>
<li>
<p><code>CYCLE / NO CYCLE</code> - параметр <code>CYCLE</code> позволяет зациклить последовательность при достижении макс_значения или мин_значения для возрастающей или убывающей последовательности, соответственно. Когда этот предел достигается, следующим числом этих последовательностей будет соответственно мин_значение или макс_значение. Если указывается <code>NO CYCLE</code>, при каждом вызове <code>nextval</code> после достижения предельного значения будет возникать о</p>
</li>
<li>
<p><code>OWNED BY имя_таблицы.имя_столбца / OWNED BY NONE</code> - предложение <code>OWNED BY</code> позволяет связать последовательность с определённым столбцом таблицы так, чтобы при удалении этого столбца (или всей таблицы) последовательность удалялась автоматически.Указанная таблица должна иметь того же владельца и находиться в той же схеме, что и последовательность. Подразумеваемое по умолчанию предложение <code>OWNED BY NONE</code> указывает, что такая связь не устанавливается.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Примеры</strong>:</p>
</div>
<div class="paragraph">
<p>Создание возрастающей последовательности с именем <code>serial</code>, с начальным значением <code>101</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE SEQUENCE serial START 101;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Использование этой последовательности в команде <code>INSERT</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">INSERT INTO table_name VALUES (nextval('serial'), 'nothing');</code></pre>
</div>
</div>
<div class="paragraph">
<p>Добавив через такой запрос в таблицу значения, последовательность увеличится на единицу и <code>nextval('serial') = 102</code>;</p>
</div>
<div class="paragraph">
<p>Чтобы узнать следующий номер этой последовательности выполните запрос:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT * FROM serial;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_удаление_последовательности_drop_sequence">Удаление последовательности (<code>DROP SEQUENCE</code>)</h5>
<div class="paragraph">
<p>Удалить последовательность может только её владелец или суперпользователь, для этого воспользуйтесь запросом:</p>
</div>
<div class="listingblock">
<div class="title">Для удаления последовательности</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP SEQUENCE [ IF EXISTS ] имя [, ...] [ CASCADE | RESTRICT ]</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IF EXISTS</code> - не считать ошибкой, если последовательность не существует. В этом случае будет выдано замечание.</p>
</li>
<li>
<p><code>имя</code> - имя последовательности (возможно, дополненное схемой).</p>
</li>
<li>
<p><code>CASCADE</code> - автоматически удалять объекты, зависящие от данной последовательности, и, в свою очередь, все зависящие от них объекты.</p>
</li>
<li>
<p><code>RESTRICT</code> - отказать в удалении последовательности, если от неё зависят какие-либо объекты. Это поведение по умолчанию</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_изменение_определение_генератора_последовательности_alter_sequence">Изменение определение генератора последовательности (<code>ALTER SEQUENCE</code>)</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER SEQUENCE [ IF EXISTS ] имя
    [ AS тип_данных ]
    [ INCREMENT [ BY ] шаг ]
    [ MINVALUE мин_значение | NO MINVALUE ] [ MAXVALUE макс_значение | NO MAXVALUE ]
    [ START [ WITH ] начало ]
    [ RESTART [ [ WITH ] перезапуск ] ]
    [ CACHE кеш ] [ [ NO ] CYCLE ]
    [ OWNED BY { имя_таблицы.имя_столбца | NONE } ]

    ALTER SEQUENCE [ IF EXISTS ] имя OWNER TO { новый_владелец | CURRENT_USER |
    SESSION_USER }

    ALTER SEQUENCE [ IF EXISTS ] имя RENAME TO новое_имя

    ALTER SEQUENCE [ IF EXISTS ] имя SET SCHEMA новая_схема</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ALTER SEQUENCE</code> меняет параметры существующего генератора последовательности. Параметры, не определяемые явно в команде <code>ALTER SEQUENCE</code>, сохраняют свои предыдущие значения. Выполнить <code>ALTER SEQUENCE</code> может только владелец соответствующей последовательности. Чтобы сменить схему последовательности, необходимо также иметь право <code>CREATE</code> в новой схеме. Чтобы сменить владельца, необходимо быть непосредственным или опосредованным членом новой роли-владельца, а эта роль должна иметь право <code>CREATE</code> в схеме последовательности.</p>
</div>
<div class="paragraph">
<p>Дополнительные параметры, отсутствующие в запросе создания <code>sequence</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>новый_владелец</code> - имя пользователя, назначаемого новым владельцем последовательности.</p>
</li>
<li>
<p><code>новое_имя</code> - новое имя последовательности.</p>
</li>
<li>
<p><code>новая_схема</code> - новая схема последовательности.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ограничения_constraints">Ограничения (<code>Constraints</code>)</h3>
<div class="paragraph">
<p><span class="image"><img src="../assets/img/bd-object/postgresql-constraints.png" alt="postgresql constraints"></span></p>
</div>
<div class="paragraph">
<p>С помощью ключевого слова <code>CONSTRAINT</code> можно задать имя для ограничений. В качестве ограничений могут использоваться <code>PRIMARY KEY</code>, <code>UNIQUE</code>, <code>CHECK</code>.</p>
</div>
<div class="sect3">
<h4 id="_ограничения_проверки">Ограничения-проверки</h4>
<div class="paragraph">
<p><strong>Ограничение-проверка</strong> — наиболее общий тип ограничений. В его определении можно указать, что значение данного столбца должно удовлетворять логическому выражению (проверке истинности). Например, цену товара можно ограничить положительными значениями так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ограничение определяется после типа данных, как и значение по умолчанию. Значения по умолчанию и ограничения могут указываться в любом порядке. Ограничение-проверка состоит из ключевого слова <code>CHECK</code>, за которым идёт выражение в скобках. Это выражение должно включать столбец, для которого задаётся ограничение, иначе оно не имеет большого смысла.</p>
</div>
<div class="paragraph">
<p>Можно также присвоить ограничению отдельное имя. Это улучшит сообщения об ошибках и позволит ссылаться на это ограничение, когда понадобится изменить его. Имена ограничений можно задать на уровне столбцов. Они указываются после <code>CONSTRAINT</code> перед атрибутами:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CONSTRAINT positive_price CHECK (price &gt; 0)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>То есть, чтобы создать именованное ограничение, напишите ключевое слово <code>CONSTRAINT</code>, а за ним идентификатор и собственно определение ограничения.</p>
</div>
<div class="paragraph">
<p>Ограничение-проверка может также ссылаться на несколько столбцов. Например, если необходимо хранить обычную цену и цену со скидкой, так можете гарантировать, что цена со скидкой будет всегда меньше обычной.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE table_name (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric CHECK (discounted_price &gt; 0),
    CHECK (price &gt; discounted_price)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Этот пример можно переписать иначе:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE table_name (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    CHECK (price &gt; discounted_price)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>или так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE table_name (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0 AND price &gt; discounted_price)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ограничениям таблицы можно присваивать имена так же, как и ограничениям столбцов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE table_name (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    CONSTRAINT valid_discount CHECK (price &gt; discounted_price)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следует заметить, что ограничение-проверка удовлетворяется, если выражение принимает значение <code>true</code> или <code>NULL</code>. Так как результатом многих выражений с операндами <code>NULL</code> будет значение <code>NULL</code>, такие ограничения не будут препятствовать записи <code>NULL</code> в связанные столбцы. Чтобы гарантировать, что столбец не содержит значения <code>NULL</code>, можно использовать ограничение <code>NOT NULL</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ограничение_not_null_2">Ограничение <code>NOT NULL</code></h4>
<div class="paragraph">
<p>Ограничение <code>NOT NULL</code> просто указывает, что столбцу нельзя присваивать значение <code>NULL</code>.</p>
</div>
<div class="listingblock">
<div class="title">Синтаксис</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ограничение <code>NOT NULL</code> всегда записывается как ограничение столбца и функционально эквивалентно ограничению <code>CHECK (имя_столбца IS NOT NULL)</code>, но в <strong>Postgres Pro</strong> явное ограничение <code>NOT NULL</code> работает более эффективно. Хотя у такой записи есть недостаток — назначить имя таким ограничениям нельзя.</p>
</div>
<div class="paragraph">
<p>Для столбца можно определить больше одного ограничения. Для этого их нужно просто указать одно за другим:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric NOT NULL CHECK (price &gt; 0)
);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ограничения_уникальности">Ограничения уникальности</h4>
<div class="paragraph">
<p>Ограничения уникальности гарантируют, что данные в определённом столбце или группе столбцов уникальны среди всех строк таблицы. Ограничение записывается так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE products (
    product_no integer UNIQUE,
    name text,
    price numeric
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>или:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    UNIQUE (product_no)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы определить ограничение уникальности для группы столбцов, запишите его в виде ограничения таблицы, перечислив имена столбцов через запятую:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    UNIQUE (a, c)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Такое ограничение указывает, что сочетание значений перечисленных столбцов должно быть уникально во всей таблице, тогда как значения каждого столбца по отдельности не должны быть (и обычно не будут) уникальными.</p>
</div>
<div class="paragraph">
<p>Можно назначить уникальному ограничению имя обычным образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE products (
    product_no integer CONSTRAINT must_be_different UNIQUE,
    name text,
    price numeric
);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_первичный_ключ_primary_key">Первичный ключ (<code>PRIMARY KEY</code>)</h4>
<div class="paragraph">
<p>Ограничение первичного ключа означает, что образующий его столбец или группа столбцов может быть уникальным идентификатором строк в таблице. Для этого требуется, чтобы значения были одновременно уникальными и отличными от <code>NULL</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Первичные ключи могут включать несколько столбцов; синтаксис похож на запись ограничений уникальности:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    PRIMARY KEY (a, c)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>При добавлении первичного ключа автоматически создаётся уникальный индекс-B-дерево для столбца или группы столбцов, перечисленных в первичном ключе, и данные столбцы помечаются как <code>NOT NULL</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ограничение_внешнего_ключа_references">Ограничение внешнего ключа (<code>REFERENCES</code>)</h4>
<div class="paragraph">
<p>Ограничение внешнего ключа указывает, что значения столбца (или группы столбцов) должны соответствовать значениям в некоторой строке другой таблицы. Это называется ссылочной целостностью двух связанных таблиц.</p>
</div>
<div class="paragraph">
<p>Пусть у вас уже есть таблица продуктов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Предположим, что есть таблица с заказами этих продуктов. Чтобы в таблице заказов содержались только заказы действительно существующих продуктов, определим в ней ограничение внешнего ключа, ссылающееся на таблицу продуктов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer REFERENCES products (product_no),
    quantity integer
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>С таким ограничением создать заказ отсутствующим в таблице <code>products</code> (и не равным <code>NULL</code>), будет невозможно.</p>
</div>
<div class="paragraph">
<p>В такой схеме таблицу <code>orders</code> называют подчинённой таблицей, а <code>products</code> — главной. Соответственно, столбцы называют так же <code>подчинённым</code> и <code>главным</code> (или ссылающимся и целевым).</p>
</div>
<div class="paragraph">
<p>Предыдущую команду можно сократить так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer REFERENCES products,
    quantity integer
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если опустить список столбцов, внешний ключ будет неявно связан с первичным ключом главной таблицы.</p>
</div>
<div class="paragraph">
<p>Внешний ключ также может ссылаться на группу столбцов. В этом случае его нужно записать в виде обычного ограничения таблицы.</p>
</div>
<div class="paragraph">
<p><strong>Например</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE t1 (
  a integer PRIMARY KEY,
  b integer,
  c integer,
  FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Естественно, число и типы столбцов в ограничении должны соответствовать числу и типам целевых столбцов.</p>
</div>
<div class="sect4">
<h5 id="_добавление_ограничения_alter_table">Добавление ограничения (<code>ALTER TABLE</code>)</h5>
<div class="paragraph">
<p>Для добавления ограничения используется синтаксис ограничения таблицы. <strong>Например:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE products ADD CHECK (name &lt;&gt; '');

ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);

ALTER TABLE products ADD FOREIGN KEY (product_group_id)
REFERENCES product_groups;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы добавить ограничение <code>NOT NULL</code>, которое нельзя записать в виде ограничения таблицы,  используется такой синтаксис:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ограничение проходит проверку автоматически и будет добавлено, только если ему  удовлетворяют данные таблицы.</p>
</div>
</div>
<div class="sect4">
<h5 id="_удаление_ограничения_drop_constraint">Удаление ограничения (<code>DROP CONSTRAINT</code>)</h5>
<div class="paragraph">
<p>Для удаления ограничения необходимо знать его имя. Если ранее ограничению не присваивали имя, это  неявно сделала система, и необходимо выяснить его. Здесь может быть полезна команда <code>psql \d имя_таблицы</code> (или другие программы, показывающие подробную информацию о таблицах). Зная
имя, можно использовать команду:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE products DROP CONSTRAINT some_name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Как и при удалении столбца необходимо удалить ограничение с зависимыми объектами,  добавьте указание <code>CASCADE</code>. Примером такой зависимости может быть ограничение внешнего  ключа, связанное со столбцами ограничения первичного ключа. Так можно удалить ограничения любых типов, кроме <code>NOT NULL</code>.</p>
</div>
<div class="paragraph">
<p>Чтобы удалить ограничение <code>NOT NULL</code>, используйте команду:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_права_доступа">Права доступа</h3>
<div class="paragraph">
<p>Когда в базе данных создаётся объект, ему назначается владелец. Владельцем обычно становится роль, с которой был выполнен оператор создания. Для большинства типов объектов в исходном состоянии только владелец (или суперпользователь) может делать с объектом всё что угодно. Чтобы разрешить использовать его другим ролям, нужно дать им права.</p>
</div>
<div class="sect3">
<h4 id="_добавление_нового_пользователя">Добавление нового пользователя</h4>
<div class="paragraph">
<p>Если в базе данных не существует пользователя, его можно создать следующим образом:</p>
</div>
<div class="listingblock">
<div class="title">Создание пользователя</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE USER user-name WITH PASSWORD 'password';</code></pre>
</div>
</div>
<div class="paragraph">
<p>где в таблице</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>user-name</code> - логин пользователя базы данных.</p>
</li>
<li>
<p><code>password</code> - пароль нового пользователя.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>На этом этапе новый пользователь не имеет никаких разрешений на работу с базами данных. Он не может войти в систему, поэтому нужно предоставить ему неограниченные права доступа, выполнить это можно через следующий запрос.</p>
</div>
<div class="sect4">
<h5 id="_присвоение_прав_доступа_grant">Присвоение прав доступа (<code>GRANT</code>)</h5>
<div class="listingblock">
<div class="title">Предоставление пользователю неограниченные права доступа</div>
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">GRANT ALL PRIVILEGES ON table_name TO user-name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь пользователь получил новые права и может работать с базой данных.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_настройка_прав_доступа_для_пользователей">Настройка прав доступа для пользователей</h4>
<div class="paragraph">
<p>Предоставить другой уровень доступа к базам данных для пользователя возможно через следующую команду:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">GRANT [тип прав] ON [имя базы данных].[имя таблицы] TO user-name [ WITH GRANT OPTION ];</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если указано <code>WITH GRANT OPTION</code>, получатель права, в свою очередь, может давать его другим. Без  этого указания распоряжаться своим правом он не сможет. Группе <code>PUBLIC</code> право передачи права  дать нельзя.</p>
</div>
<div class="paragraph">
<p>В <strong>PostgreSQL</strong> права доступа бывают несколько типов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ALL PRIVILEGES</code> – даёт пользователю полный доступ к заданной базе данных (если база данных не указана, то ко всем);</p>
</li>
<li>
<p><code>CREATE</code> – позволяет пользователю создавать базы данных/таблицы;</p>
</li>
<li>
<p><code>SELECT</code> – позволяет пользователю делать выборку данных;</p>
</li>
<li>
<p><code>INSERT</code> – позволяет пользователю добавлять новые записи в таблицы;</p>
</li>
<li>
<p><code>UPDATE</code> – позволяет пользователю изменять существующие записи в таблицах;</p>
</li>
<li>
<p><code>DELETE</code> – позволяет пользователю удалять записи из таблиц;</p>
</li>
<li>
<p><code>DROP</code> – позволяет пользователю удалять записи в базе данных/таблицах;</p>
</li>
<li>
<p><code>TRIGGER</code> - создание триггеров;</p>
</li>
<li>
<p><code>TRUNCATE</code> - очистка таблицы;</p>
</li>
<li>
<p><code>USAGE</code> - право на использование последовательностей и использовать объекты в конкретной схеме;</p>
</li>
<li>
<p><code>REFERENCES</code> - право ссылаться на таблицу;</p>
</li>
<li>
<p><code>CONNECT</code> - право на подключение к базе данных</p>
</li>
<li>
<p><code>TEMPORARY</code> - разрешает создавать в базе данных временные таблицы;</p>
</li>
<li>
<p><code>EXECUTE</code> - право на использование функции.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Право удалять объект или изменять его определение произвольным образом не считается назначаемым, оно неотъемлемо связано с владельцем, так что отозвать это право или дать его кому-то другому нельзя.</strong></p>
</div>
<div class="paragraph">
<p>Если необходимо назначить несколько видов прав доступа, можно разделить их запятыми, как в команде:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">GRANT UPDATE, DELETE ON table_name TO user-name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если необходимо забрать у пользователя права доступа:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">REVOKE [тип прав] ON [имя базы данных].[имя таблицы] FROM user-name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если необходимо отменить все привилегии у пользователя, введите команду:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">REVOKE ALL PRIVILEGES ON table_name FROM user-name;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_удаление_пользователей">Удаление пользователей</h5>
<div class="paragraph">
<p>Если на роль есть ссылки в какой-либо базе данных в кластере, возникнет ошибка и роль не будет удалена. Прежде чем удалять роль, необходимо удалить все принадлежащие ей объекты, а также лишить её данных ей прав для других объектов.</p>
</div>
<div class="paragraph">
<p>Удалить пользователя можно следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP ROLE user-name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>или</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">DROP USER user-name;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DROP USER</code> — просто альтернативное написание команды <code>DROP ROLE</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_изменение_роли_в_базе_alter_role">Изменение роли в базе (<code>ALTER ROLE</code>)</h5>
<div class="paragraph">
<p>Изменение пароля пользователя:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER ROLE user_name WITH PASSWORD 'hu8jmn3';</code></pre>
</div>
</div>
<div class="paragraph">
<p>Удаление пароля пользователя:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER ROLE user_name WITH PASSWORD NULL;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Переименовать пользователя:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">ALTER ROLE user1 RENAME TO user2;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_виды_ролей">Виды ролей</h4>
<div class="sect4">
<h5 id="_суперпользователи">Суперпользователи</h5>
<div class="paragraph">
<p><strong>Суперпользователи</strong> –  имеют полный доступ ко всем объектам (проверки не выполняются).</p>
</div>
</div>
<div class="sect4">
<h5 id="_владельцы">Владельцы</h5>
<div class="paragraph">
<p><strong>Владельцы</strong> – владельцем становиться тот, кто создал объект. Но право владения можно передать. Владелец имеет все привилегии на принадлежащий ему объект. Также создатель объекта обладает правом удалять его, и это право у него нельзя отнять.</p>
</div>
</div>
<div class="sect4">
<h5 id="_псевдо_роль_public">Псевдо роль public</h5>
<div class="paragraph">
<p>Псевдороль <code>public</code> не видна, но про неё следует знать. Это групповая роль, в которую включены все остальные  роли. Это означает, что все роли по умолчанию будут иметь привилегии наследуемые от <code>public</code>. Поэтому иногда у <code>public</code> отбирают некоторые привилегии, чтобы отнять их у всех пользователей.</p>
</div>
<div class="paragraph">
<p>Роль <code>public</code> по умолчанию имеет следующие привилегии для всех баз данных:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CONNECT</code> – это означает что любая созданная роль сможет подключаться к базам данных;</p>
</li>
<li>
<p><code>TEMPORARY</code> – любая созданная роль сможет создавать временные объекты во всех база данных и объекты эти могут быть любого размера;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>для схемы <code>public</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CREATE</code> (создание объектов) – любая роль может создавать объекты в этой схеме;</p>
</li>
<li>
<p><code>USAGE</code> (доступ к объектам) – любая роль может использовать объекты в этой схеме;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>для всех функций:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>EXECUTE</code> (выполнение) – любая роль может выполнять любую функцию. Ещё нужны ещё права <code>USAGE</code> на ту схему, в которой функция находится, и права к объектам к которым обращается функция. Это сделано для удобства, но снижает безопасность сервера баз данных.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-10-15 01:34:15 UTC
</div>
</div>
</body>
</html>