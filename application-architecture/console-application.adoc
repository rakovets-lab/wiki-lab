= Консольное приложение
:imagesdir: ../assets/img/application-architecture/console-application

*Консольное приложение* - это компьютерное приложение без графического интерфейса пользователя (*GUI*), предназначенное для работы исключительно с командами клавиатуры через текстовый компьютерный интерфейс. Многие ранние операционные системы работали исключительно в таких режимах, и только позже компании начали разрабатывать операционные системы с графическим интерфейсом для простоты использования. Можно запустить консольное приложение без графического интерфейса или запустить операционную систему в режиме консоли по диагностическим и другим причинам.

В консольном приложении пользователь выдает команды через клавиатуру, в отличие от приложений с графическим интерфейсом пользователя, которые обычно требуют использования мыши или другого указывающее устройство. Можно запустить приложение, чтобы участвовать в различных действиях, и результат будет отображаться на консоли. Программа способна извлекать и редактировать файлы, печатать, передавать данные, массово удалять и выполнять другие функции. Многие приложения, работающие в фоновом режиме в операционной системе, работают в режиме консоли, поскольку пользователю не нужно взаимодействовать с ними, за исключением редких случаев.

*Текстовый интерфейс пользователя* (англ. *Text user interface*, *TUI*; также *Character User Interface*, *CUI*) — система средств взаимодействия пользователя с компьютером, основанная на использовании текстового (буквенно-цифрового) режима дисплея или аналогичных устройств — например, командная строка. Приложения, использующие текстовый интерфейс, называют консольными программами.

В простейшем случае консольная программа использует интерфейс командной строки, однако многие из таких программ с помощью управляющих последовательностей терминалов создают более дружественный интерфейс, приближающийся к графическому.

В Windows командная строка является примером консольного приложения. Пользователь может открыть командную строку для редактирования системных файлов и для других целей. Когда он вводит команды, они прокручивают экран вверх вместе с ответами из приложения.

* терминал *Linux*
image:terminal-linux.png[]

* командная строка *Windows*
image:terminal-windows.png[]

* терминал *macOS*
image:terminal-mac-os.png[]

Преимущества консольных приложений:

* Более скромные требования к ресурсам по сравнению с другими видами интерфейсов.
* При большом наборе возможных команд опытные пользователи могут работать с приложением быстрее, чем с системой меню
* *Основным преимуществом* является то, что *консольные приложения* дают возможность использовать себя в скриптах для автоматизации (рутинных) действий.

== Стандартные потоки

Говоря про *консольные приложения* стоит знать о *стандартных потоках* ввода/вывода данных.

*Стандартные потоки ввода/вывода* в системах типа *UNIX* (и некоторых других) — потоки процесса, имеющие номер (*дескриптор*), зарезервированный для выполнения некоторых *«стандартных»* функций. Как правило(хотя и не обязательно), эти дескрипторы открыты уже в момент запуска задачи (исполняемого файла).

Существует три стандартных потока ввода/вывода данных:

* стандартный поток ввода *standard input* (*stdin*);
* стандартный поток вывода *standard output* (*stdout*);
* стандартный поток ошибок *standard error* (*stderr*).

image:type-stream.png[]

Вывод данных на экран и чтение их с клавиатуры происходит потому, что по умолчанию стандартные потоки ассоциированы с терминалом пользователя. Это не является обязательным — потоки можно подключать к чему угодно — к файлам, программам и даже устройствам.

=== Стандартный ввод

*Поток №0* (*stdin*) зарезервирован для чтения команд пользователя или входных данных. Номера потоков ещё называют *дескрипторами*. Этот поток представляет собой некую информацию, передаваемую в терминал, в частности — инструкции, переданные в оболочку для выполнения. Обычно данные в этот поток попадают в ходе ввода их пользователем с клавиатуры.

=== Стандартный вывод

*Поток №1* данных (*stdout*), которые оболочка выводит после выполнения каких-то действий. Обычно эти данные попадают в то же окно терминала, где была введена команда, вызвавшая их появление.

=== Стандартный вывод ошибок

Поток ошибок (*stderr*) имеет дескриптор 2. Этот поток похож на стандартный поток вывода, так как обычно то, что в него попадает, оказывается на экране терминала. Однако, он, по своей сути, отличается от стандартного вывода, как результат, этими потоками, при желании, можно управлять раздельно. Это полезно, например, в следующей ситуации. Есть команда, которая обрабатывает большой объём данных, выполняя сложную и подверженную ошибкам операцию. Нужно, чтобы полезные данные, которые генерирует эта команда, не смешивались с сообщениями об ошибках. Реализуется это благодаря раздельному перенаправлению потоков вывода и ошибок.

== Конвейер

*Конвейер* - некоторое множество процессов, для которых выполнено следующее перенаправление ввода-вывода: то, что выводит на поток стандартного вывода предыдущий процесс, попадает в поток стандартного ввода следующего процесса.

Другими словами, конвейер умеет передавать выходные данные из одной программы, как входные данные для другой. Т.е. выполняется команда, мы получаем результат и передаем эти данные далее на обработку другой программе.

* `|` - отправить следующей команде
* `Tee` - отправить в файл и на стандартный вывод
* `Xargs` – построчно передать на ввод команде

Конвейер создаётся с помощью вызова pipe(), который возвращает два файловых дескриптора: один ссылается на вход конвейера, второй на выход и разделяются `|` (`stdout/stderr | stdin`).

[source,bash]
----
$ ls | grep r
----

image:process-working-streams.jpg[]

== Перенаправление потоков

*Перенаправление ввода/вывода* - изменения стандартных входных или выходных потоков и привязка к определенным условиям или файлам.

*Перенаправление ввода/вывода* означает работу с вышеописанными потоками и перенаправление данных туда, куда нужно программисту. Делается это с использованием символов `>` и `<` в различных комбинациях, применение которых зависит от того, куда, в итоге, должны попасть перенаправляемые данные.

* `<` - изменение (назначение) нестандартного входного устройства (`< файл` - файл в поток ввода);
* `<<` - считывать стандартный ввод, пока не встретится указанный текст;
* `>` - переназначение стандартного вывода (`> файл` - поток вывода в новый файл);
* `>>` - переназначение вывода, добавление вывода команды в конец существующего файла (`>> файл` - поток вывода в конец файла);
* `2>` - переназначения стандартного потока сообщений об ошибках (`2> файл` - поток ошибок в новый файл);
* `2>>` - переназначение вывода сообщений об ошибках, добавление сообщений об ошибках в конец существующего файла (`2>> файл` - поток ошибок в конец файла);
* `&>`, `>&` - направляет потоки вывода и ошибок в один файл (`&> файл` или `>& файл` - потоки вывода и ошибок в новый файл);
* `2>&1` - направляет поток ошибок туда, куда направлен поток вывода (`2>&1 файл` - потоки ошибок туда, куда и поток вывода);
* `1>&2` - направляет поток вывода туда, куда направлен поток ошибок (`1>&2 файл` - поток вывода туда, куда и поток ошибок).

image:Stdout-redirect.jpg[]

=== Перенаправление стандартного потока вывода

Обычно команды выводят данные в стандартный поток вывода. Для того, чтобы эти данные оказались в файле, нужно добавить символ `>` после команды, перед именем целевого файла. До и после `>` надо поставить `пробел`. При использовании перенаправления любой файл, указанный после > будет перезаписан. Если в файле нет ничего ценного и его содержимое можно потерять, в нашей конструкции допустимо использовать уже существующий файл. Обычно же лучше использовать в подобном случае имя файла, которого пока не существует. Этот файл будет создан после выполнения команды.

[source,bash]
----
$ date > date.txt
----

Для того, чтобы это данные добавлялись в конец файла, а не перезаписывали файл, надо использовать два символа `>>`, поставленные один за другим. В результате новая команда, перенаправляющая вывод в файл, но не перезаписывающая его, а добавляющая новые данные после старых, будет выглядеть так:

[source,bash]
----
$ traceroute google.com >> date.txt
----

=== Перенаправление стандартного потока ввода

Используя знак `<` мы можем перенаправить стандартный ввод, заменив его содержимым файла.

[source,bash]
----
$ comm <(sort list1.txt) <(sort list2.txt)
----

Круглые скобки тут имеют тот же смысл, что и в математике. Оболочка сначала обрабатывает команды в скобках, а затем всё остальное. В нашем примере сначала производится сортировка строк из файлов, а потом то, что получилось, передаётся команде `comm`, которая затем выводит результат сравнения списков.

=== Перенаправление стандартного потока ошибок

Это может понадобиться, например, для создания лог-файлов с ошибками или объединения в одном файле сообщений об ошибках и возвращённых некоей командой данных.

Обычно, когда обычный пользователь запускает команду, она выводит в терминал и полезные данные и ошибки. При этом, последних обычно больше, чем первых, что усложняет нахождение в выводе команды того, что нужно. Решить эту проблему довольно просто: достаточно перенаправить стандартный поток ошибок в файл, используя команду `2>`. В результате на экран попадёт только то, что команда отправляет в стандартный вывод:

[source,bash]
----
$ find / -name wireless 2> denied.txt
----

Если нужно сохранить результаты работы команды в отдельный файл, не смешивая эти данные со сведениями об ошибках  можно добавить команду перенаправления стандартного потока вывода в файл:

[source,bash]
----
$ find / -name wireless 2> denied.txt > found.txt
----

Если нужно, чтобы всё, что выведет команда, попало в один файл, можно перенаправить оба потока в одно и то же место, воспользовавшись командой `&>`:

[source,bash]
----
$ find / -name wireless &> results.txt
----

== Формат и параметры команд

Наиболее общий формат команд (в квадратные скобки помещены необязательные части):

[source,bash]
----
[символ_начала_команды]имя_команды [параметр_1 [параметр_2 […]]]
----

Символ начала команды может быть самым разным, однако чаще всего для этой цели используется косая черта `/`. Если строка вводится без этого символа, выполняется некоторая базовая команда. Если же такой базовой команды нет, символ начала команды отсутствует вообще (как, например, в *DOS*).

Параметры команд могут иметь самый разный формат. В основном применяются следующие правила:

* параметры разделяются пробелами (и отделяются от названия команды пробелом)
* параметры, содержащие пробелы, обрамляются кавычками-апострофами `'` или двойными кавычками `"`
* если параметр используется для обозначения включения какой-либо опции, выключенной по умолчанию, он начинается с косой черты `/` или дефиса `-`
* если параметр используется для включения/выключения какой-либо опции, он начинается (или заканчивается) знаком плюс или минус (для включения и выключения соответственно)
* если параметр указывает действие из группы действий, назначенных команде, он не начинается со специальных символов
* если параметр указывает объект, к которому применяется действие команды, он не начинается со специальных символов
* если параметр указывает дополнительный параметр какой-либо опции, то он имеет формат `/опция:дополнительный_параметр` (вместо косой черты также может употребляться дефис).

[source,bash]
----
/map dm1 /skill:2
----

* `/` — символ начала команды
* `map` — название команды (переход на другой уровень)
* `dm1` — обязательный параметр (название уровня)
* `/skill:2` — дополнительный параметр (задание уровня сложности)

== Примеры консольных программ

* Любая программа, осуществляющая получение данных от пользователя путём чтения *stdin* и отправку данных пользователю путём записи в *stdout*, по определению является консольной программой. Однако, такие программы могут обходиться и безо всякого пользователя, например обрабатывая данные из файлов.
* Unix shell, а также все утилиты, предназначенные для работы в этой среде.
* *Midnight Commander* (*UNIX*), *FAR Manager* (*Windows*) - это двухпанельный файловый менеджер для операционных систем.
image:example-midnight-commander.png[]

* *Alpine* (клиент электронной почты)
image:example-alpine-email-client.png[]

* *Irssi* (IRC-клиент (Internet Relay Chat))
image:example-irssi.png[]

* *Lynx* (веб-браузер)
image:example-lynx.png[]

* *Music on Console* (аудиоплеер)
* *Mutt* (клиент электронной почты)
image:example-mutt.png[]

* *VIM* (текстовый редактор)
image:example-vim.png[]

* RTORRENT (ТОРРЕНТ КЛИЕНТ)
image:example-rtorent.png[]

* *newsbeuter* (RSS-ридер)
image:example-newsbeuter.png[]
