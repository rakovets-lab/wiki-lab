= N-tier Architecture
:imagesdir: ../assets/img/application-architecture

*N-tier architecture* (*multitier architecture*, *многослойная архитектура*) это *client-server architecture*, в которой разделяются функции представления, обработки и хранения данных. Наиболее распространённой разновидностью многоуровневой архитектуры является трёхуровневая архитектура.

== Tiers

Стоит выделить несколько _tiers_ на которые обычно разделяют систему.

=== Presentation tier

*Presentation tier* (*слой представления*) - это *user interface* (*пользовательский интерфейс*) и *communication layer* (*уровень связи приложения*), где конечный пользователь взаимодействует с приложением. Его основная цель - отображать информацию и собирать информацию от пользователя. Этот *top-level tier* (*верхне-уровневый слой*) может работать, например, в веб-браузере, как настольное приложение или как *graphical user interface* (*графический пользовательский интерфейс*, *GUI*). *Web presentation tiers* обычно разрабатываются с использованием _HTML_, _CSS_ и _JavaScript_. Настольные приложения могут быть написаны на разных языках в зависимости от платформы.

=== Application tier

*Application tier* (*слой приложения*), также известный как *logic tier* (*слой логики*) или *middle tier* (*средний слой*), является сердцем приложения. На этом уровне информация, собранная на _presentation tier_, обрабатывается, и обычно с использованием некой бизнес-логики и определенного набора бизнес-правил. _Application tier_ также может добавлять, удалять или изменять данные на _data tier_.

_Application tier_ обычно разрабатывается с использованием Java, Python, Perl, PHP или Ruby и взаимодействует с _data tier_ с помощью вызовов некоторого API.

=== Data tier

*Data tier* (*слой данных*), иногда называемый *database tier* (*слоем базы данных*), *data access tier* (*слоем доступа к данным*) или *back-end* (*серверной частью*), - это место, где информация, обрабатываемая приложением, хранится и управляется. Это может быть *relational database management system* (*система управления реляционными базами данных*), такая как _PostgreSQL_, _MariaDB_, _Oracle_, _DB2_, _Informix_ или _Microsoft SQL Server_, или *NoSQL Database server* (*сервером NoSQL базы данных*), таким как _Cassandra_, _CouchDB_ или _MongoDB_.

== Layer против tier

При обсуждении N-tier architecture, *layer* (*уровень*)  часто используется взаимозаменяемо с *tier* (*слой*), что является не совсем верно, например, _presentation layer_ или _business logic layer_.

Это не одно и то же. *Layer* относится к функциональному разделению программного обеспечения, а *tier* относится к функциональному разделению программного обеспечения, которое выполняется на разных инфраструктурных единицах, независимо от других. Приложение _Контакты_ на телефоне, например, представляет собой _three-layer application_, но _single-tier application_, потому что все три _layers_ работают на телефоне.

Разница важна, потому что _layers_ не могут предложить те же преимущества, что и _tiers_.

== Single-tier architecture

*Single-tier application* AKA *Standalone application*

image::single-tier-architecture.png[Single-tier architecture]

_Single-tier architecture_ включает в себя все _tiers_, такие как _presentation tier_, _application tier_ и _data tier_, в одном приложении. Приложения, которые включают в себя все три _tiers_, например, MP3-плеер, MS Office и т.д., являются *single-tier application*. Данные хранятся в локальной системе или на общем диске.

== Two-tier architecture

image::two-tier-architecture.png[Two-tier architecture]

*Two-tier architecture* (*двухзвенная архитектура*, *двухуровневая архитектура*) - это классическая (т.е. первоначальная) _client-server architecture_, состоящая из _presentation tier_ и _data tier_; бизнес-логика находится на _presentation tier_, _data tier_ или на обоих _tiers_. В _two-tier architecture_ _presentation tier_, а следовательно, конечный пользователь - имеет прямой доступ к _data tier_, а бизнес-логика часто ограничена. Простое приложение для управления бухгалтерией, в котором бухгалтеры могут фиксировать денежные операции в компании, является примером _two-tier application_.

=== Преимущества

* С точки зрения разработки и обслуживания:
** Простая структура
** Простота установки
** Простота обслуживания
* С точки зрения производительности:
** Хорошая производительность для небольших и средних объемов данных
** Бизнес-логика и база данных физически близко, что обеспечивает более высокую производительность.

=== Недостатки

* С точки зрения разработки и обслуживания:
** Сложную бизнес-логику приложения трудно реализовать на сервере базы данных, поэтому требуется реализовывать на клиенте
** Сложная бизнес-логика приложения на клиенте, ведет к снижению производительности
** Изменения в бизнес-логике, если они на клиенте, требуют нового программного обеспечения на стороне клиента, соответственно они должны быть доступны и установленны
** Привязка к поставщику СУБД
* С точки зрения производительности:
** Плохая производительность для больших и огромных объемов данных, так как сервер базы данных выполняет еще и бизнес-логику. Это замедляет операции в БД на сервере базы данных.

== Three-tier architecture

image::three-tier-architecture.png[Three-tier architecture]

*Three-tier architecture* (*трехзвенная архитектура*, *трехуровневая архитектура*) - это хорошо зарекомендовавшая себя архитектура программных приложений, которая объединяет приложения в три логических и физических вычислительных _tiers_:

* _presentation tier_ или пользовательский интерфейс;
* _application tier_, на котором обрабатываются данные;
* _data tier_, где хранятся и управляются данные, связанные с приложением.

На протяжении десятилетий _three-tier architecture_ была преобладающей _client-server architecture_ для приложений.

=== Преимущества

* Главное преимущество _three-tier architecture_ - *логическое и физическое разделение функций*. Каждый _tier_ может работать на отдельной операционной системе и на отдельной серверной платформе - например, на веб-сервере, сервере приложений, сервере базы данных - что наилучшим образом соответствует его функциональным требованиям. И каждый уровень работает по крайней мере на одном выделенном серверном оборудовании или виртуальном сервере, поэтому службы каждого уровня могут быть настроены и оптимизированы без влияния на другие уровни.

Другие преимущества (по сравнению с _single-tier_ или _two-tier architecture_):

* *Более быстрая разработка*: поскольку каждый _tier_ может разрабатываться одновременно разными командами, организация может быстрее вывести приложение на рынок, а программисты могут использовать подходящие и более новые версии языков и инструментов для каждого _tier_.
* *Улучшенная масштабируемость*: любой _tier_ можно масштабировать независимо от других по мере необходимости.
* *Повышенная надежность*: сбой на одном _tier_ с меньшей вероятностью повлияет на доступность или производительность других _tiers_.
* *Повышенная безопасность*: поскольку _presentation tier_ и _data tier_ не могут взаимодействовать напрямую, хорошо спроектированный _application tier_ может функционировать как своего рода внутренний брандмауэр, предотвращая SQL-инъекции и другие вредоносные эксплойты.

Так же можно структурировать преимущества.

* С точки зрения разработки и обслуживания:
** Сложную бизнес-логику приложения легко реализовать на сервере приложений
** Бизнес-логика отсутствует на сервере базы данных и клиенте, что улучшает производительность
** Изменение бизнес-логики автоматически доступно клиенту после установки на _application server_
** Бизнес-логика _application server_ совместима с другими серверами баз данных, после небольших изменений
* С точки зрения производительности:
** Высокая производительность для средних и больших объемов данных

=== Недостатки

* С точки зрения разработки и обслуживания:
** Более сложная структура
** Более сложная в настройке
** Более сложная в обслуживании.
* С точки зрения производительности:
** Физическое разделение на _application server_, содержащий бизнес-логику и _database server_, содержащий базы данных, может незначительно повлиять на производительность.

== Three-tier application в web-разработке

В web-разработке _tiers_ имеют разные имена, но выполняют схожие функции:

* *Web-server* является _presentation tier_ и предоставляет пользовательский интерфейс. Обычно это web-страница или web-сайт, например, сайт электронной коммерции, где пользователь добавляет продукты в корзину, добавляет реквизиты для оплаты или создает учетную запись. Контент может быть статическим или динамическим и обычно разрабатывается с использованием HTML, CSS и Javascript.
* *Application server*  соответствует _middle tier_, в котором размещается бизнес-логика, используемая для обработки вводимых пользователем данных. Продолжая пример электронной торговли, это _tier_, который запрашивает из базы данных продукты, чтобы получить информацию о наличии продукта, или добавляет подробности в профиль клиента. Этот уровень часто разрабатывается с использованием Java, Python, Ruby, JavaScript и PHP, при поддержке таких фреймворков, как, например, Spring, Django, Rails, NodeJS и Symphony соответственно.
* *Database server* - это _data tier_ для web-приложения. Он работает с программным обеспечением для управления базами данных, например PostgreSQL, MariaDB, Oracle или DB2.

== N-tier architecture

image:n-tier-architecture.jpg[N-tier architecture]

*N-tier architecture* - также называемая *multi-tier architecture* - относится к любой архитектуре приложения с более чем одним _tiers_. Так же встречаются приложения с более чем тремя _tiers_. Например, где источником данных является другой *multi-tier application*.

'''

Resources:

* https://www.ibm.com/cloud/learn/three-tier-architecture
