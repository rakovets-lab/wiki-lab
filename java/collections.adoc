= Коллекции
:imagesdir: ../assets/img/java/collections

== Иерархия коллекций: Абстрактные классы, Интерфейсы и Классы

image::collectios-hierarcy.gif[иерархия коллекций]

== Структура данных `ArrayList`

[source, java]
----
ArrayList<String> list = new ArrayList<String>();
----

Только что созданный объект `list` содержит свойства `elementData` и `size`.

Хранилище значений `elementData` есть не что иное, как *массив* определенного типа (указанного в generic), в нашем случае `String[]`. Если вызывается конструктор без параметров, то по умолчанию будет создан массив из десяти элементов типа `Object` (с приведением к типу, разумеется).

[source, java]
----
elementData = (E[]) new Object[10];
----

image:arraylist-empty.png[пустой arrayList после создания]

Добавим новый элемент:

[source, java]
----
list.add("0");
----

image::arraylist-add-one-element.png[arrayList полсе добавления одного элемента]

Внутри метода `add(value)` происходят следующие вещи:

* проверяется, достаточно ли места в массиве для вставки нового элемента;

[source, java]
----
ensureCapacity(size + 1);
----

* добавляется элемент в конец (согласно значению `size`) массива.

[source, java]
----
elementData[size++] = element;
----

Если места в массиве не достаточно, новая ёмкость рассчитывается по формуле `(oldCapacity * 3) / 2 + 1`. Второй момент это *копирование элементов*. Оно осуществляется с помощью *native-метода* `System.arraycopy()`, который написан не на Java.

[source, java]
----
// newCapacity - новое значение емкости
elementData = (E[])new Object[newCapacity];

// oldData - временное хранилище текущего массива с данными
System.arraycopy(oldData, 0, elementData, 0, size);
----

Если массив заполнен:

image::arraylist-full.png[заполененный массив]

То при добавлении нового элемента, проверка покажет что места в массиве нет. Соответственно создается новый массив и вызывается `System.arraycopy()`.

[source, java]
----
list.add("10");
----

image::arraylist-new-size.png[массив нового размера]

После этого добавление элементов продолжается.

image::arraylist-add-to-new-size.png[доваление элемента в массив с новым размером]

Добавление элементов в середину ArrayList происходит следующим образом:

[source, java]
----
list.add(5, "100");
----

Добавление элемента на позицию с определенным индексом происходит в три этапа:

* проверяется, достаточно ли места в массиве для вставки нового элемента;

[source, java]
----
ensureCapacity(size+1);
----

* подготавливается место для нового элемента с помощью `System.arraycopy()`;

[source, java]
----
System.arraycopy(elementData, index, elementData, index + 1, size - index);
----

image::inseriton-midle-copy.png[копирование массива при вставке в середину]

* перезаписывается значение у элемента с указанным индексом.

[source, java]
----
elementData[index] = element;
size++;
----

image::insertion-midle-insertion.png[вставка элемента в ноый масиссив на пустое место]

В случаях, когда происходит вставка элемента по индексу и при этом в вашем массиве нет свободных мест, то вызов `System.arraycopy()` случится дважды: первый в `ensureCapacity()`, второй в самом методе `add(index, value)`, что явно скажется на скорости всей операции добавления.

В случаях, когда в исходный список необходимо добавить другую коллекцию, да еще и в «середину», стоит использовать метод `addAll(index, Collection)`. И хотя, данный метод скорее всего вызовет `System.arraycopy()` три раза, в итоге это будет гораздо быстрее поэлементного добавления.

Удалять элементы можно двумя способами:

* по индексу `remove(index)`
* по значению `remove(value)`

С удалением элемента по индексу всё достаточно просто:

[source, java]
----
list.remove(5);
----
Сначала определяется какое количество элементов надо скопировать:

[source, java]
----
int numMoved = size - index - 1;
----

Затем копируем элементы используя `System.arraycopy():`

[source, java]
----
System.arraycopy(elementData, index + 1, elementData, index, numMoved);
----
Уменьшаем размер массива и забываем про последний элемент:

[source, java]
----
elementData[--size] = null; // Let gc do its work
----

При удалении по значению, в цикле просматриваются все элементы списка, до тех пор пока не будет найдено соответствие. Удален будет лишь первый найденный элемент.

При удалении элементов текущая величина `capacity` *не уменьшается*, что может привести к своеобразным утечкам памяти. Поэтому не стоит пренебрегать методом `trimToSize()`.

== Структура данных `LinkedList`

`LinkedList` — класс, реализующий два интерфейса — `List` и `Deque`. Это обеспечивает возможность создания двунаправленной очереди из любых, в том числе и `null` элементов. Каждый объект, помещенный в связанный список, является *узлом* (*node*). Каждый узел содержит *элемент*, ссылку на *предыдущий* и *следующий* узел. Фактически связанный список состоит из последовательности узлов, каждый из которых предназначен для хранения объекта определенного при создании типа.

image::linkedList-view.jpg[общий вид связанного списка]

===  Создание связанного списка

[source, java]
----
LinkedList<Integer> numbers = new LinkedList<>();
----

Данный код создает объект класса `LinkedList` и сохраняет его в ссылке `numbers`. Созданный объект предназначен для хранения целых чисел `Integer`. Пока этот объект пуст.

Класс LinkedList содержит три поля:

[source, java]
----
// модификатор transient указывает на то, что данное свойство класса нельзя
// сериализовать
transient int size = 0;
transient Node<E> first;
transient Node<E> last;
----

image::linkedList-empty-object-state.jpg[состояние объекта сразу полсе создания]

=== Добавление объекта в конец связанного списка

[source, java]
----
numbers.add(8);
----

Данный код добавляет число `8` в конец ранее созданного списка. Под «капотом» этот метод вызывает ряд других методов, обеспечивающих создание объекта типа `Integer`, создание нового узла, установку объекта класса `Integer` в поле `item` этого узла, добавление узла в конец списка и установку ссылок на соседние узлы.

Для установки ссылок на предыдущий и следующий элементы `LinkedList` использует объекты своего вложенного класса `Node`:

[source, java]
----
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
----

При каждом добавлении объекта в список создается один новый узел, а также изменяются значения полей связанного списка `size`, `first`, `last`.

image::linkedList-add-item.jpg[добавление первого объкта]

В случае с добавлением первого элемента создается *узел*, у которого предыдущий и следующий элементы отсутствуют, т.е. являются `null`, размер коллекции увеличивается на 1, а созданный узел устанавливается как первый и последний элемент коллекции.

Добавление еще одного элемента в коллекцию:

[source, java]
----
numbers.add(5);
----

Сначала создается *узел* для нового элемента (число `5`) и устанавливается ссылка на существующий элемент (узел с числом `8`) коллекции как на *предыдущий*, а следующим элементом у созданного узла остается `null`. Также этот новый узел сохраняется в переменную связанного списка `last`:

image::linkedList-add-second-item.jpg[добавление второго объекта в коллекцию первый этап]

Как можно увидеть, первый элемент коллекции (под индексом `0`) пока ссылается на `null` как на следующий элемент. Теперь эта ссылка заменяется и первый элемент начинает ссылаться на второй элемент коллекции (под индексом 1), а также увеличивается размер коллекции:

image::linkedList-add-second-item-stage-two.jpg[добавление второго объекта в коллекцию второй этап]

=== Добавление объекта в середину связанного списка

[source, java]
----
numbers.add(1, 13);
----

*LinkedList* позволяет добавить элемент в середину списка. Для этого используется метод `add(index, element)`, где `index` — это место в списке, куда будет вставлен элемент `element`.

Как и метод `add(element)`, данный метод вызывает несколько других методов. Сначала осуществляется проверка значения `index`, которое должно быть положительным числом, меньшим или равным размеру списка. Если `index` не удовлетворит этим условиям, то будет сгенерировано исключение `IndexOutOfBoundsException`.

Затем, если `index` равен размеру коллекции, то осуществляются действия, добавления последнего элемента в коллекцию, так как фактически необходимо вставить элемент в конец существующего списка.

Если же `index` не равен `size` списка, то осуществляется вставка перед элементом, который до этой вставки имеет заданный индекс.

Для начала с помощью метода `node(index)` определяется узел, находящийся в данный момент под индексом, под который нам необходимо вставить новый узел. Поиск данного узла осуществляется с помощью простого цикла `for` по половине списка (в зависимости от значения индекса — либо с начала до элемента, либо с конца до элемента). Далее создается узел для нового элемента (число `13`), ссылка на предыдущий элемент устанавливается на узел, в котором элементом является число `8`. Ссылка на следующий элемент устанавливается на узел, в котором элементом является число `5`. Ссылки ранее существующих узлов пока не изменены:

image::linkedList-add-item-midle-stage-one.jpg[добавление элемента в середину связного списка этап 1]

Теперь последовательно заменяются ссылки: для элемента, следующего за новым элементом, заменяется ссылка на предыдущий элемент (теперь она указывает на узел со значением `13`), для предшествующего новому элементу заменяется ссылка на следующий элемент (теперь она указывает на узел со значением `5`). И в последнюю очередь увеличивается размер списка:

image::linkedList-add-item-midle-stage-two.jpg[добавление элемента в середину связного списка этап 2]

=== Удаление объекта из списка

Рассмотрим удаление элемента из связанного списка по его значению. Удалим элемент со значением `5` из ниже представленного списка:

image::linkedList-state-before-delete.jpg[состояние списка перед удалением]

[source, java]
----
numbers.remove(Integer.valueOf(5));
----

Принимаемым значением в методе `remove(object)` является именно объект, если попытаться удалить элемент со значением `5` следующей строкой:

[source, java]
----
numbers.remove(5);
----

Tо сгенерируется `IndexOutOfBoundsException`, т.к. компиллятор воспримет число `5` как *индекс* и вызовет метод `remove(index)`.

Что происходит при вызове метода `remove(object)`? Сначала искомый объект сравнивается по порядку со всеми элементами, сохраненными в узлах списка, начиная с нулевого узла. Когда найден узел, элемент которого равен искомому объекту, первым делом элемент сохраняется в отдельной переменной. Потом переопределяются ссылки соседних узлов так, чтобы они указывали друг на друга:

image::linkedList-delet-item-stage-one.jpg[удаление элемента из списка этап 1]

Затем обнуляется значение узла, который содержит удаляемый объект, а также уменьшается размер коллекции:

image::linkedList-delet-item-stage-two.jpg[удаление элемента из списка этап 2]

== Структура данных HashMap

=== Создание объекта

[source, java]
----
Map<String, String> hashmap = new HashMap<String, String>();
----

Новоявленный объект hashmap, содержит ряд свойств:

* *table* — массив типа `Entry`, который является хранилищем ссылок на списки (цепочки) значений;
* *loadFactor* — коэффициент загрузки. Значение по умолчанию `0.75` является хорошим компромиссом между временем доступа и объемом хранимых данных;
* threshold — предельное количество элементов, при достижении которого, размер хэш-таблицы увеличивается вдвое. Рассчитывается по формуле (`capacity * loadFactor`);
* *size* — количество элементов `HashMap`-а;

В конструкторе, выполняется проверка валидности переданных параметров и установка значений в соответствующие свойства класса.

`HashMap` содержит *массив* `Node` и `Node` может представлять класс, содержащий следующие объекты:

* `int` — хэш
* `K` — ключ
* `V` — значение
* `Node` — следующий элемент

Теперь разберем как все это работает. Для начала рассмотрим процесс хеширования.

=== Хеширование

*Хеширование* -это процесс преобразования *объекта* в *целочисленную форму*, выполняется с помощью метода `hashCode()`. Очень важно правильно реализовать метод `hashCode()` для обеспечения лучшей производительности класса `HashMap`.

==== Метод `hashCode()`

Метод `hashCode()` используется для получения хэш кода объекта. Метод `hashCode()` класса `Object` возвращает ссылку памяти объекта в целочисленной форме (*идентификационный хеш*/*identity hash code*). Сигнатура метода `public native hashCode()`. Это говорит о том, что метод реализован как нативный, поскольку в java нет какого-то метода позволяющего получить ссылку на объект. Допускается определять собственную реализацию метода `hashCode()`. В классе `HashMap` метод `hashCode()` используется для вычисления *корзины* (*bucket*) и, следовательно, вычисления индекса.

==== Метод `equals()`

Метод `equals` используется для проверки двух объектов на равенство. Метод реализован в классе `Object`. Можно переопределить его в своем собственном классе. В классе `HashMap` метод `equals()` используется для проверки равенства ключей. В случае, если ключи равны, метод `equals()` возвращает `true`, иначе `false`.

==== Корзины (Buckets)

*Bucket* -это единственный элемент массива `HashMap`. Он используется для хранения *узлов* (Nodes). Два или более узла могут иметь один и тот-же *bucket*. В этом случае для связи узлов используется структура данных *связанный список*. *Bucket* различаются по ёмкости (свойство `capacity`). Отношение между `bucket` и `capacity` выглядит следующим образом:

[source, java]
----
capacity = number of buckets * load factor
----

Один `bucket` может иметь более, чем один узел, это зависит от реализации метода `hashCode()`. Чем лучше реализован метод `hashCode()`, тем лучше будут использоваться `bucket`.

=== Вычисление индекса в `HashMap`

Хэш код ключа может быть достаточно большим для создания массива. Сгенерированный хэш код может быть в диапазоне целочисленного типа и если создать массив такого размера, то легко получим исключение `outOfMemoryException`. Потому генерируется индекс для минимизации размера массива. По сути для вычисления индекса выполняется следующая операция:

[source, java]
----
index = hashCode(key) & (n-1).
----

Где n равна числу bucket или значению длины массива.

=== Вставка пары ключ/значение в `HashMap`

Изначально пустой `HashMap` выглядит так:

[source, java]
----
HashMap map = new HashMap();
----

image::hashMap-empty.jpeg[пустая hashMap]

Добавление одной пары ключ/значение:

[source, java]
----
map.put(new Key("vishal"), 20);
----

Этапы:

* Вычислить значение ключа `vishal`. Оно будет сгенерировано, как `118`.
* Вычислить индекс с помощью метода `index`, который будет равен `6`.
* Создать объект `node`.
* Поместить объект в позицию с индексом `6`, если место свободно.

Теперь `HashMap` выглядит примерно так:

image::hash-map-one-element.jpeg[hashMap с одним элементом]

=== Возникновение коллизий при вставке

[source, java]
----
map.put(new Key("vaibhav"), 40);
----

Этапы:

* Вычислить значение ключа `vaibhav`. Оно будет сгенерировано, как `118`.
* Вычислить индекс с помощью метода `index`, который будет равен `6`.
* Создать объект `node`.
* Поместить объект в позицию с индексом `6`, если место *свободно*.
* В данном случае в позиции с индексом `6` уже существует другой объект, этот случай называется *коллизией*.
* В таком случае проверяется с помощью методов `hashCode()` и `equals()`, что оба ключа одинаковы.
* Если ключи одинаковы, заменить текущее значение новым.
* Иначе связать новый и старый объекты с помощью структуры данных `связанный список`, указав ссылку на следующий объект в текущем и сохранить оба под индексом `6`.

Теперь `HashMap` выглядит примерно так:

image::hashMap-collision.jpeg[hashMap при вставке с коллизией]

=== Получение значения по ключу

[source, java]
----
map.get(new Key("vaibhav"));
----

Этапы:

* Вычислить хэш код объекта `vaibhav`. Он был сгенерирован, как `118`.
* Вычислить индекс с помощью метода `index`, который будет равен `6`.
* Перейти по индексу ``6 ``и сравнить ключ первого элемента с имеющемся значением. Если они равны, то вернуть значение, иначе выполнить проверку для следующего элемента, если он существует.
* В данном случае он не найден и следующий объект `node` не равен `null`.
* Если следующий объект node равен `null`, возвращаем `null`.
* Если следующий объект node не равен `null`, переходим к нему и повторяем первые три шага до тех пор, пока элемент не будет найден или следующий объект `node` не будет равен `null`.

=== Изменения в Java8

В случае возникновения коллизий объект `node` сохраняется в структуре данных "связанный список" и метод `equals()` используется для сравнения ключей. Это сравнения для поиска верного ключа в связанном списке - линейная операция и в худшем случае сложность равна `O(n)`.

Для исправления этой проблемы в *Java 8* после достижения определенного порога вместо *связанных списков* используются *сбалансированные деревья*. Это означает, что `HashMap` в начале сохраняет объекты в *связанном списке*, но после того, как количество элементов в хеше достигает определенного порога, происходит переход к *сбалансированным деревьям*. Что улучшает производительность в худшем случае с `O(n)` до `O(log n)`.

=== Основные моменты

Сложность операций `get()` и `put()` практически константна до тех пор, пока не будет проведено повторное хеширование.

В случае коллизий, если индексы двух и более объектов `node` одинаковые, объекты `node` соединяются с помощью *связанного списка*, т.е. ссылка на второй объект `node` хранится в первом, на третий во втором и т.д.

Если данный ключ уже существует в HashMap, значение перезаписывается.

Хэш код `null` равен *0*.

Когда объект получается по ключу происходят переходы по связанному списку до тех пор, пока объект не будет найден или ссылка на следующий объект не будет равна `null`.

== Структура данных LinkedHashMap

[source, java]
----
Map<Integer, String> linkedHashMap = new LinkedHashMap<Integer, String>();
----

Только что созданный объект `linkedHashMap`, помимо свойств унаследованных от `HashMap` (такие, как: `table`, `loadFactor`, `threshold`, `size,` `entrySet` и т.п.), так же содержит два доп. свойства:
`header` — «голова» двусвязного списка. При инициализации указывает сам на себя;
`accessOrder` — указывает каким образом будет осуществляться доступ к элементам при использовании итератора. При значении `true` — по порядку последнего доступа (об этом в конце). При значении `false` доступ осуществляется в том порядке, в котором элементы были вставлены.

Конструкторы класса `LinkedHashMap` достаточно скучные, вся их работа сводится к вызову конструктора родительского класса и установке значения свойству `accessOrder`. А вот инициализация свойства `header` происходит в переопределенном методе `init()` .

image::linkedHashMap-empty.png[пустой объект linkedHashMap]

=== Добавление элементов

[source, java]
----
linkedHashMap.put(1, "obj1");
----

При добавлении элемента, первым вызывается метод `createEntry(hash, key, value, bucketIndex)` (по цепочке `put()`, `addEntry()`, `createEntry()`)

[source, java]
----
void createEntry(int hash, K key, V value, int bucketIndex) {
    HashMap.Entry<K,V> old = table[bucketIndex];
    Entry<K,V> e = new Entry<K,V>(hash, key, value, old);
    table[bucketIndex] = e;
    e.addBefore(header);
    size++;
}
----

Первые три строки добавляют элемент (при коллизиях добавление произойдет в начало цепочки):

image::linkedHashMap-add-stage-one.png[добавление объекта этап 1]

Четвертая строка переопределяет ссылки двусвязного списка:

image::linkedHashMap-add-stage-two.png[второй этап добавления]

Всё что дальше происходит в методе `addEntry()` либо не представляет «функционального интереса» либо повторяет функционал родительского класса.

Добавим еще парочку элементов:

[source, java]
----
linkedHashMap.put(15, "obj15");
linkedHashMap.put(4, "obj4")
----

При добавлении следующего элемента происходит коллизия, и элементы с ключами `4` и `38` образуют цепочку:

[source, java]
----
linkedHashMap.put(38, "obj38");
----

image::linkedHashMap-add-collision.png[добавление объекта с коллизией]

=== `accessOrder == true`

А теперь давайте рассмотрим пример когда свойство `accessOrder` имеет значение `true`. В такой ситуации поведение `LinkedHashMap` меняется и при вызовах методов `get()` и `put()` порядок элементов будет изменен — элемент к которому обращаемся, будет помещен в конец.

[source, java]
----
Map<Integer, String> linkedHashMap = new LinkedHashMap<>(15, 0.75f, true);
linkedHashMap.put(1, "obj1");
linkedHashMap.put(15, "obj15");
linkedHashMap.put(4, "obj4");
linkedHashMap.put(38, "obj38");
System.out.println(linkedHashMap);

linkedHashMap.get(1); // or linkedHashMap.put(1, "Object1");
System.out.println(linkedHashMap);
----

.Output
----
{1=obj1, 15=obj15, 4=obj4, 38=obj38}
{15=obj15, 4=obj4, 38=obj38, 1=obj1}
----

image::linkedHashMap-accessOrder.png[продок элементов при accessOrder == true]

== Алгоритмическая сложность операций в коллекциях Java

image::algoritmic-difficulty.png[алгоритмическая сложность]
