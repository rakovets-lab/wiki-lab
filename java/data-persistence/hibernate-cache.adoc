= Hibernate cache
:imagesdir: ../../assets/img/java/data-persistence/hibernate-cache

*Кэш* - это память с большей скоростью доступа, предназначенная для ускорения обращения к данным, содержащимся постоянно в памяти с меньшей скоростью доступа. Кэширование применяется *ЦПУ*, *жёсткими дисками*, *браузерами*, *веб-серверами*, *службами DNS* и *WINS*.

Кэш состоит из набора записей. Каждая запись ассоциирована с элементом данных или блоком данных (небольшой части данных), которая является копией элемента данных в основной памяти. Каждая запись имеет идентификатор, часто называемый тегом, определяющий соответствие между элементами данных в кэше и их копиями в основной памяти.

image:cache.png[]

Когда клиент кэша (*ЦПУ*, *веб-браузер*, *операционная система*) обращается к данным, прежде всего исследуется кэш. Если в кэше найдена запись с идентификатором, совпадающим с идентификатором затребованного элемента данных, то используются элементы данных в кэше. Такой случай называется *попаданием кэша*. Если в кэше не найдена запись, содержащая затребованный элемент данных, то он читается из основной памяти в кэш, и становится доступным для последующих обращений. Такой случай называется *промахом кэша*.

Кеширование является одним из способов оптимизации работы приложения, ключевой задачей которого является уменьшить количество прямых обращений к базе данных.

Кэширование, как правило, есть смысл применять в больших, высоконагруженных проектах, с десятками тысяч запросов в минуту. В таких проектах, чтобы не перегружать базу, как правило, кэшируют обращения к репозиторию. Особенно если известно, что данные из какой-нибудь мастер-системы обновляются с некоторой периодичностью. Если же проект маленький и перегрузки ему не грозят, тогда, конечно, лучше ничего не кэшировать — всегда свежие данные всегда лучше периодически обновляемых.

image:app-hibernate-db.png[]

В *Hibernate* имеется 3 вида кеширования:

* *First-level cache* (*Кеш первого уровня*);
* *Second-level cache* (*Кеш второго уровня*);
* *Query cache* (*Кеш запросов*);

image:hibernate-first-and-second-level-cache.jpg[]

== Кеш первого уровня

В *Hibernate* *кэш первого уровня* представлен интерфейсом `Session`, который является расширением к *JPA* `EntityManager`. В терминологии *JPA* *кэш первого уровня* называется *Persistence Context*, и он представлен интерфейсом `EntityManager`.

*Кеш первого уровня* всегда привязан к объекту `Session`. *Hibernate* по умолчанию использует этот кеш и его нельзя отключить.

В *JPA* и *Hibernate* *кэш первого уровня* - это *Java Map*, в котором *ключ* представлен объектом, инкапсулирующим имя сущности и ее идентификатор, а *значение* - это сам объект сущности. Поэтому в *JPA* `EntityManager` или *Hibernate* `Session` может быть только одна сущность, хранящаяся с использованием одного и того же идентификатора и типа класса сущности. Причина, по которой невозможно иметь не более одного представления сущности, хранящегося в *кэше первого уровня*, заключается в том, что в противном случае мы можем получить различные отображения одной и той же строки базы данных, не зная, какая из них является правильной версией, синхронизируемой с соответствующей записью базы данных.

[source,java]
----
Session session = sessionFactory.openSession();
Pet pet = (Pet) session.load(Pet.class, id);
pet = (Pet) session.load(Pet.class, id);
----

В примере выше будет выполнен 1 запрос в базу, несмотря на то, что делается 2 вызова `load()`, так как эти вызовы происходят в контексте одной сессии. Во время второй попытки загрузить план с тем же идентификатором будет использован кеш сессии.

Сначала *Hibernate* проверяет, хранится ли сущность в *кэше первого уровня*, и если да, то возвращается текущая управляемая ссылка на нее. Если сущность не найдена в *кэше первого уровня*, то *Hibernate* загрузит ее из базы данных с помощью *SQL*-запроса.

При использовании методов `save()`, `update()`, `saveOrUpdate()`, `load()`, `get()`, `list()`, `iterate()`, `scroll()` всегда будет задействован *кеш первого уровня*.

Для работы с данными кеша в сессии имеются следующие методы:

* `flush()` — обновляет объекты кеша с базой данных.
* `evict()` — удаляет объект из кеша.
* `contains()` — определяет, находится ли объект в кеше или нет.
* `clear()` — очищает весь кеш.

При *кеше первого уровня* все активные сессии работает изолированно друг от друга, и у каждой сессии соответственно имеется свой кеш, который очищается при закрытии сессии.

== Кеш второго уровня

*Кеш второго уровня* привязан к `SessionFactory`, поэтому видимость этого кеша гораздо шире *кеша первого уровня*. Данный вид кеша доступен на протяжении всего времени работы приложения.

По умолчанию *кеш второго уровня* отключен. Для включения необходимо при конфигурировании настроек *Hibernate* в строке `hibernate.cache.use_second_level_cache` установить значение `true`.

На самом деле, *Hibernate* сам не реализует кеширование как таковое, а лишь предоставляет структуру для его реализации. Поэтому подключить можно любую реализацию, которая соответствует спецификации *ORM* фреймворка.

Из сказанного выше следует, что помимо `hibernate.cache.use_second_level_cache` еще необходимо в настройках указать провайдера кеша `hibernate.cache.region.factory_class: org.hibernate.cache.ehcache.EhCacheRegionFactory`, которого также нужно добавить в зависимости *Maven*.

[source,yaml]
----
spring:
  jpa:
    properties:
      hibernate:
        cache:
          use_second_level_cache: true
          region:
            factory_class: org.hibernate.cache.ehcache.EhCacheRegionFactory
----

Из популярных реализаций провайдеров можно выделить следующие:

* EHCache
* OSCache
* SwarmCache
* JBoss TreeCache

Эти провайдеры дополнительно можно настраивать, например в файле `ehcache.xml`, который должен находиться в директории ресурсов. В данном файле, например, можно ограничить количество записей в кеше `maxElementsInMemory="500"`.

[source,xml]
----
<ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:noNamespaceSchemaLocation="ehcache.xsd" updateCheck="true"
	monitoring="autodetect" dynamicConfig="true">

    <diskStore path="java.io.tmpdir"/>
    <defaultCache
        maxElementsInMemory="500"
        eternal="false"
        timeToIdleSeconds="60"
        timeToLiveSeconds="60"
        overflowToDisk="true"/>
    <cache name="cache1"
        maxElementsInMemory="500"
        maxEntriesLocalHeap="10000"
        maxEntriesLocalDisk="1000"
        eternal="false"
        diskSpoolBufferSizeMB="20"
        timeToIdleSeconds="300" timeToLiveSeconds="600"
        memoryStoreEvictionPolicy="LFU"
        transactionalMode="off">
        <persistence strategy="localTempSwap"/>
    </cache>
</ehcache>
----



Помимо вышеуказанного нужно еще самому *Hibernate*, что именно кешировать. Делается это с помощью аннотаций `@Cacheable` и `@Cache`.

[source,java]
----
@Entity
@Table(name = "shared_doc")
@Cacheable
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class SharedDoc{
    private Set<User> users;
}
----

`@Cacheable` это аннотация *JPA* и позволяет объекту быть закэшированным. *Hibernate* поддерживает эту аннотацию в том же ключе. `@Cache` это аннотация *Hibernate*, настраивающая тонкости кэширования объекта в *кэше второго уровня* *Hibernate*. Аннотации `@Cacheable`  достаточно, чтобы объект начал кэшироваться с настройками по умолчанию. При этом `@Cache`, использованная без `@Cacheable`, не разрешит кэширование объекта.

Аннотация `@Cache` имеет несколько атрибутов:

* `usage` - отвечает за стратегию кеширования.
* `region` - это логический разделитель памяти вашего кеша. Для каждого региона можно настроить свою политику кеширования (для *EhCache* в том же `ehcache.xml`). Если регион не указан, то используется регион по умолчанию, который имеет полное имя вашего класса для которого применяется кеширование.
* `include` - Могут ли свойства сущности, указанные с `lazy=true`, кэшироваться, когда разрешена
"ленивая" выборка на уровне атрибутов. По-умолчанию *all* и может быть также *non-lazy*

Стратегии кеширования определяют поведения кеша в определенных ситуациях. Выделяют четыре группы:

* *Read-only* - используется только для сущностей, которые никогда не изменяются (выбрасывается исключение  при попытке обновить такую сущность). Это очень просто и эффективно. Очень подходит для некоторых статических эталонных данных, которые не меняются.
* *Nonstrict-read-write* - кэш обновляется после фиксации транзакции, которая изменила затронутые данные. Таким образом, строгая согласованность не гарантируется, и существует небольшое временное окно, в течение которого устаревшие данные могут быть получены из кэша. Этот тип стратегии подходит для вариантов использования, которые могут допустить возможную согласованность.
* *Read-write* - эта стратегия гарантирует строгую согласованность, которая достигается за счет использования «мягких» блокировок - когда кэшированный объект обновляется, программная блокировка также сохраняется в кэше для этого объекта, которая освобождается после фиксации транзакции. Все параллельные транзакции, которые обращаются к заблокированным записям, будут извлекать соответствующие данные непосредственно из базы данных.
* *Transactional* - изменения кэша выполняются в распределенных транзакциях. Изменение в кэшированном объекте либо фиксируется, либо откатывается как в базе данных, так и в кэше в одной и той же транзакции.

Помимо вышесказанного, следует помнить — зависимости Вашего класса по умолчанию также не кешируются. Например, если рассмотреть класс выше — `SharedDoc`, то при выборке коллекция `users` будет доставаться из базы данных, а не из *кеша второго уровня*. Если Вы хотите также кешировать и зависимости, то необходимо также проаннотировать все необходимы объекты аннотацией `@Cache`.

[source,java]
----
@Entity
@Table(name = "shared_doc")
@Cacheable
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class SharedDoc{
    @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
    private Set<User> users;
}
----

Еще одна важная деталь про *кеш второго уровня*. *Hibernate* не хранит сами объекты классов. Он хранит информацию в разобранном (гидратированном) состоянии, в виде массивов строк, чисел и т. д.

* `Id` (первичный ключ) не сохраняется (он хранится как часть ключа кэша)
* Переходные свойства не сохраняются
* Коллекции не хранятся
* Значения свойств, не связанные с ассоциацией, хранятся в исходном виде
* Для отношений *ToOne* сохраняется только идентификатор (внешний ключ)

Идентификатор объекта выступает указателем на эту информацию. Концептуально это нечто вроде *Map*, в которой `id` объекта — ключ, а массивы данных — значение. Приблизительно можно представить себе это так - `1 -> { "Pupkin", 1, null , {1,2,5} }`, что есть очень разумно, учитывая сколько лишней памяти занимает каждый объект.

Как уже говорилось выше, сначала *Hibernate* проверяет, хранится ли сущность в *кэше первого уровня*, затем проверяется *кеш второго уровня*, и только после этого, если запрашиваемый объект не найден, *Hibernate* выполнит запрос в базу данных.

[source,java]
----
Session session = factory.openSession();
Pet pet = (Pet) session.load(Pet.class, 1L);
session.close();
session = factory.openSession();
pet = (Pet) session.load(Pet.class, 1L);
session.close();
----

В примере выше, если будет реализован *кеш второго уровня*, то к базе данных будет выполнен всего один запрос.

== Кеш запросов

*Кэш запросов*, так же как и *кэш второго уровня*, существует на уровне `SessionFactory` и доступен во всех *persistence context*. Для *кэша запросов* требуются две дополнительные области физического кэша, в которых хранятся результаты кэшированного запроса и отметки времени последнего обновления таблицы.

*Кэши первого* и *второго уровней* работают с объектами загружаемыми по `id`. Но к базе данных чаще выполняются запросы с условиями, чем загружаются какие-то заранее известные объекты. И результат выполнения таких запросов тоже может потребоваться кэшировать. Например, если вы делаете поисковый сайт по автозапчастям, то можете кэшировать запросы пользователей, которые, скорее всего, ищут одни запчасти гораздо чаще других.

У *кэша запросов* есть и своя цена — *Hibernate* будет вынужден отслеживать сущности закешированные с определённым запросом и выкидывать запрос из кэша, если кто-то поменяет значение сущности. То есть для *кэша запросов* стратегия параллельного доступа всегда *read-only*. По этим причинам, *Hibernate* по-умолчанию выключает *кэширование запросов*.

*Кеш запросов* похож на *кеш второго уровня*. Но в отличии от него — ключом к данным кеша выступает не идентификатор объекта, а совокупность параметров запроса. А сами данные — это идентификаторы объектов соответствующих критериям запроса. Таким образом, этот кеш рационально использовать с *кешем второго уровня*.

Если у вас есть запросы, выполняющиеся снова и снова, с одними и теми же параметрами, *кэширование запросов* предоставит выигрыш в производительности.

Для включения нужно добавить свойства `hibernate.cache.use_query_cache=true`. Установив свойства значение true, вы заставляете *Hibernate* создавать необходимые кеши в памяти для хранения наборов запросов и идентификаторов. Также надо установить `setCacheable(true)`.

[source,yaml]
----
spring:
  jpa:
    properties:
      hibernate:
        cache:
          use_query_cache: true
----

[source,java]
----
Session session = SessionFactory.openSession();
Query query = session.createQuery("FROM EMPLOYEE");
query.setCacheable(true);
query.setCacheRegion("employee");
List users = query.list();
SessionFactory.closeSession();
----

*Hibernate* также поддерживает очень тонкую поддержку кэша благодаря концепции области кэша. Регион кеша является частью кеша, которому дано имя. Пример выше использует метод, чтобы сообщить *Hibernate* хранить и искать запрос в области кэша сотрудников.

== Link

* link:https://habr.com/ru/post/135176/[Hibernate cache]
* link:https://habr.com/ru/post/465667/[Spring Cache: от подключения кэширования за 1 минуту до гибкой настройки кэш-менеджера]
* link:https://habr.com/ru/company/ruvds/blog/350310/[Кэширование и производительность веб-приложений]
* link:https://habr.com/ru/company/otus/blog/596087/[Кэш первого уровня JPA и Hibernate]
* link:https://www.baeldung.com/hibernate-second-level-cache[Hibernate Second-Level Cache]
* link:https://coderlessons.com/tutorials/java-tekhnologii/vyuchit-hibernate/hibernate-keshirovanie[Hibernate — Кэширование]
* link:https://sysout.ru/kesh-pervogo-i-vtorogo-urovnya-v-hibernate-i-read_only-cacheconcurrencystrategy/[Кэш первого и второго уровня в Hibernate и READ_ONLY CacheConcurrencyStrategy]
* link:https://easyjava.ru/data/hibernate/keshirovanie-v-hibernate/[Кэширование в Hibernate]
* link:https://proselyte.net/tutorials/hibernate-tutorial/caching/[Кэширование в Hibernate]
* link:https://www.youtube.com/watch?v=0s48OsEbIU0&ab_channel=KataAcademy[YouTube: «HIBERNATE CACHING»: разбор всех уровней на примере чужих ошибок]
* link:https://www.youtube.com/watch?v=6mm3EE06ODE&ab_channel=EPAMRUSSIA[YouTube: Секция JAVA: Кэширование в Hibernate]
* link:https://www.youtube.com/watch?v=qu9UygWQy7A&ab_channel=SportmasterLab[YouTube: Как мы выбирали кеширование Java backend'а]