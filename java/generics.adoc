= Generics
:imagesdir: ../assets/img/generics

== Type Inference (Вывод типа)

*Вывод типа* - это способность *компилятора Java* просматривать каждый *вызов метода* и соответствующее *объявление*, чтобы определить *тип аргумента* (или аргументов), которые делают вызов применимым. Алгоритм *вывода типа* определяет *типы аргументов* и, если они доступны, тип, которому *присваивается* или *возвращается* результат. Наконец, *алгоритм вывода* пытается найти *наиболее конкретный тип*, который работает со всеми аргументами.

В следующем примере *логический вывод типа* определяет, что второй аргумент, передаваемый методу `pick()`, имеет тип `Serializable`:

[source, java]
----
static <T> T pick(T a1, T a2) {
    return a2;
}
Serializable s = pick("d", new ArrayList<String>());
----

=== Вывод типа и обобщенные методы

*Вывод типа*, позволяет вызывать *обобщенный метод*, как обычный метод, без указания типа в угловых скобках.

Полный синтаксис для вызова этого метода:

[source, java]
----
Pair<Integer, String> p1 = new Pair<>(1, "apple");
Pair<Integer, String> p2 = new Pair<>(2, "pear");
boolean same = Util.<Integer, String>compare(p1, p2);
----
Компилятор может определить *тип* ориентируясь на *аргументы* переданные в *метод*:

[source, java]
----
Pair<Integer, String> p1 = new Pair<>(1, "apple");
Pair<Integer, String> p2 = new Pair<>(2, "pear");
boolean same = Util.compare(p1, p2);
----

Эта функция называется *вывод типа*, она позволяет вызывать *обобщенный метод* как *обычный метод* без указания типа в угловых скобках.

=== Вывод типа и создание экземпляров обобщенных классов

Можно заменить *аргументы типа*, необходимые для вызова конструктора обобщенного класса, пустым набором параметров типа `<>`, если компилятор может вывести аргументы типа из контекста. Эта пара угловых скобок неофициально называется *diamond*.

Например, рассмотрим следующее объявление переменной:

[source, java]
----
Map<String, List<String>> myMap = new HashMap<String, List<String>>();
----

Можно заменить *параметризованный тип конструктора* на пустой набор параметров типа `<>`:

[source, java]
----
Map<String, List<String>> myMap = new HashMap<>();
----

Обратите внимание, что для использования *вывода типа* во время создания экземпляра обобщенного класса необходимо использовать *diamond*. В следующем примере *компилятор* генерирует *предупреждение о непроверенном преобразовании*, поскольку конструктор `HashMap()` относится к *сырому типу* `HashMap`, а не к типу `Map <String, List <String>>`:

[source, java]
----
Map<String, List<String>> myMap = new HashMap(); // unchecked conversion warning
----

=== Выведение типов и обобщенные конструкторы обобщенных и необобщенных классов

Конструкторы могут быть обобщенными (другими словами, объявлять свои собственные параметры обобщенного типа) как в обобщенных, так и в необобщенных  классах. Рассмотрим следующий пример:

[source, java]
----
class MyClass<X> {
    <T> MyClass(T t) {
        // ...//
    }
}
----

Рассмотрим следующий экземпляр класса `MyClass`:

[source, java]
----
new MyClass<Integer>("")
----

Этот оператор создает экземпляр параметризованного типа `MyClass <Integer>`; оператор явно указывает тип `Integer` для параметра обобщенного типа `X` обобщенного класса `MyClass <X>`. Конструктор для этого обобщенного класса содержит параметр обобщенного типа `T`. Компилятор определяет тип `String` для параметра обобщенного типа `T` конструктора этого обобщенного класса (поскольку фактическим параметром этого конструктора является объект `String`).

Компиляторы из выпусков предшествующих Java SE 7, могут определять фактические параметры типов обобщенных конструкторов, аналогично обобщенным методам. Однако компиляторы в Java SE 7 и более поздних версиях могут вывести фактические параметры типа создаваемого экземпляра универсального класса, если вы используете `<>`:

[source, java]
----
MyClass<Integer> myObject = new MyClass<>("");
----

В этом примере компилятор определяет тип `Integer` для параметра обобщенного типа `X` обобщенного класса `MyClass <X>`. Он определяет тип `String` для параметра формального типа `T` конструктора этого универсального класса.

=== Целевые типы (Target Types)

*Компилятор Java* использует *целевую типизацию* для вывода параметров типа вызова обобщенного метода. *Целевой тип выражения* - это тип данных, ожидаемый *компилятором Java* в зависимости от того, где находится выражение. Рассмотрим метод `Collections.emptyList()`, который объявлен следующим образом:

[source, java]
----
static <T> List<T> emptyList();
----

Рассмотрим следующий оператор присваивания:

[source, java]
----
List<String> listOne = Collections.emptyList();
----

Этот оператор ожидает экземпляр `List <String>`; этот тип данных является целевым типом. Поскольку метод `emptyList()` возвращает значение типа `List <T>`, *компилятор* делает вывод, что аргумент типа `T` должен быть значением `String`. Это работает как в *Java SE 7*, так и в *8*. В качестве альтернативы можно использовать подтверждающий тип и указать значение `T` следующим образом:

[source, java]
----
List<String> listOne = Collections.<String>emptyList();
----

Однако в данном контексте это необязательно. Однако это было необходимо в других контекстах. Рассмотрим следующий метод:

[source, java]
----
void processStringList(List<String> stringList) {
    // process stringList
}
----

Если есть необходимость вызвать метод `processStringList()` с пустым списком. В *Java SE 7* следующий код не компилируется:

[source, java]
----
processStringList(Collections.emptyList());
----

Компилятор *Java SE 7* выдает сообщение об ошибке, подобное следующему:

[source, shell script]
----
List<Object> cannot be converted to List<String>
----

Компилятору требуется значение для аргумента типа `T`, поэтому он начинается со значением `Object`. Следовательно, вызов `Collections.emptyList()` возвращает значение типа `List <Object>`, которое несовместимо с методом `processStringList()`. В *Java SE 7* необходимо указать значение значения аргумента типа следующим образом:

[source, java]
----
processStringList(Collections.<String>emptyList());
----

В *Java SE 8* в этом больше нет необходимости. Понятие целевого типа было расширено за счет включения *аргументов метода*, таких как аргумент метода `processStringList()`. В этом случае для `processStringList()` требуется аргумент типа `List <String>`. Метод `Collections.emptyList()` возвращает значение `List <T>`, поэтому, используя целевой тип `List <String>`, компилятор делает вывод, что аргумент типа `T` имеет значение `String`. Таким образом, в *Java SE 8* следующий код компилируется:

[source, java]
----
processStringList(Collections.emptyList());
----

== Generics, наследование и подтипы

Возможно присвоить объект одного типа объекту другого типа при условии, что типы совместимы. Например, можно типу `Object` присвоить `Integer`, поскольку `Object` является одним из суперклассов `Integer`:

[source, java]
----
Object someObject = new Object();
Integer someInteger = new Integer(10);
someObject = someInteger; // OK
----

В объектно-ориентированной терминологии это называется отношением «есть». Поскольку `Integer`  является разновидностью `Object`, присвоение разрешено. Но `Integer` также является разновидностью `Number`, поэтому следующий код также валиден:

[source, java]
----
public void someMethod(Number n) {
    /* ... */
}

someMethod(new Integer(10)); // OK
someMethod(new Double(10.1)); // OK
----

То же самое и с generics. Вы можете выполнить вызов обобщенного типа, передав `Number` в качестве *аргумента типа*, и любой последующий вызов `add()` будет разрешен, если аргумент совместим с `Number`:

[source, java]
----
Box<Number> box = new Box<Number>();
box.add(new Integer(10));   // OK
box.add(new Double(10.1));  // OK
----

Теперь рассмотрим следующий метод:

[source, java]
----
public void boxTest(Box<Number> n) { /* ... */ }
----

Какие аргументы он принимает? Посмотрев на его, видно, что он принимает единственный аргумент, тип которого - `Box <Number>`. Но что это значит? Можно ли передать в качестве аргумента `Box <Integer`> или `Box <Double>`, как и следовало ожидать? Ответ - «нет», потому что `Box <Integer>` и `Box <Double>` не являются подтипами `Box <Number>`.

image::generics-subtype-relationship.gif[связь обобщенных подтипов]

Это распространенное заблуждение, когда дело доходит до программирования с использованием generics, но это важная концепция, которую нужно изучить.

=== Обобщенные классы и подтипы

Можно создать подтипы общего класса или интерфейса, расширив или реализуя его. Отношения между параметрами типа одного класса или интерфейса и параметрами типа другого определяются ключевыми словами `extends` и `implements`.

Используя классы `Collections` в качестве примера, `ArrayList <E>` реализует `List <E>`, а `List <E>` расширяет `Collection <E>`. Итак, `ArrayList <String>` является подтипом `List <String>`, который является подтипом `Collection <String>`. Пока вы не изменяете *аргумент типа*, отношения подтипов между типами сохраняются.

image::generics-sample-hierarchy.gif[пример иерархии обобщенных подтипов]

Теперь представьте, что мы хотим определить наш собственный интерфейс списка, `PayloadList`, который связывает необязательное значение универсального типа `P` с каждым элементом. Его объявление может выглядеть так:

[source, java]
----
interface PayloadList<E,P> extends List<E> {
    void setPayload(int index, P val);
}
----

Следующие параметризации `PayloadList` являются подтипами `List <String>`:

[source, java]
----
PayloadList<String,String>
PayloadList<String,Integer>
PayloadList<String,Exception>
[source, java]
----

image::generics-payload-list-hierarchy.gif[иерархия playLoadList]
