= Generics
:imagesdir: ../assets/img/generics

== Сырые типы

Сырой тип - это имя *generic* класса или интерфейса без каких-либо аргументов типа. Например, возьмем обобщенный класс Box:

[source, java]
----
public class Box<T> {
    public void set(T t) { /* ... */ }
    // ...
}
----

Чтобы создать *параметризованный тип* `Box <T>`, подставляется конкретный *аргумент типа* для параметра типа `T`:

[source, java]
----
Box<Integer> intBox = new Box<>();
----

Если конкретный *аргумент типа* опущен, создается *сырой тип* `Box <T>`:

[source, java]
----
Box rawBox = new Box();
----

Следовательно, `Box` является *сырым типом* *универсального типа* `Box <T>`. Однако *не generic класс* или *интерфейс* не является сырым типом.

*Сырые типы* встречаются в *устаревшем коде* (legacy code), потому что большинство *API классов* такие как *Collections classes* не использовали *generics* до *JDK 5.0*. При использовании *сырых типов* по сути получается поведение которое было распространено до *generics* - `Box` выдает `Object`. Для обратной совместимости позволяется присваивать *сырым* типам *параметризованные*:

[source, java]
----
Box<String> stringBox = new Box<>();
Box rawBox = stringBox; // OK
----

Но если присвоить *параметризованному* типу *сырой* то компилятор выдаст *предупреждение*:

[source, java]
----
Box rawBox = new Box(); // rawBox is a raw type of Box<T>
Box<Integer> intBox = rawBox; // warning: unchecked conversion
----

Также компилятор выдаст *предупреждение* если использовать *сырой тип* для вызова *параметризованного метода* определенного в соответствующем *параметризованном классе*:

[source, java]
----
Box<String> stringBox = new Box<>();
Box rawBox = stringBox;
rawBox.set(8); // warning: unchecked invocation to set(T)
----

Предупреждение показывает, что *сырые типы* обходят проверки *универсального типа*, откладывая обнаружение небезопасного кода до *Runtime*. Следовательно, следует избегать использования *сырых типов*.

== Множественное ограничение

*Параметр типа* может иметь несколько границ:

[source, java]
----
<T extends B1 & B2 & B3>
----

*Переменная типа* с несколькими границами является *подтипом* всех типов, перечисленных в привязке. Если одна из границ является *классом*, она должна быть указана в *первую очередь.* Например:

[source, java]
----
class A { /* ... */ }
interface B { /* ... */ }
interface C { /* ... */ }

class D <T extends A & B & C> { /* ... */ }
----

Если привязка `A` не указана *первой*, получится *ошибка времени компиляции*:

[source, java]
----
class D <T extends B & A & C> { /* ... */ } // compile-time error
----

== Обобщенные методы

Полный синтаксис для вызова этого метода:

[source, java]
----
Pair<Integer, String> p1 = new Pair<>(1, "apple");
Pair<Integer, String> p2 = new Pair<>(2, "pear");
boolean same = Util.<Integer, String>compare(p1, p2);
----
Компилятор может определить *тип* ориентируясь на *аргументы* переданные в *метод*:

[source, java]
----
Pair<Integer, String> p1 = new Pair<>(1, "apple");
Pair<Integer, String> p2 = new Pair<>(2, "pear");
boolean same = Util.compare(p1, p2);
----

Эта функция называется *вывод типа*, она позволяет вызывать *обобщенный метод* как *обычный метод* без указания типа в угловых скобках.

== Обобщенные методы с ограниченным обобщением

*Ограниченные обобщения* в методах являются ключом к реализации универсальных алгоритмов. Рассмотрим следующий метод, который подсчитывает количество элементов в массиве `T[]` больше указанного элемента `elem`.

[source, java]
----
public static <T> int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e > elem) // compiler error
            // ++count;
            // return count;
}
----

Реализация метода проста, но он не компилируется, потому что оператор больше `(>)` применяется только к *примитивным типам*, таким как `short`, `int`, `double`, `long`, `float`, `byte` и `char`. Нельзя использовать оператор `>` для сравнения *объектов*. Чтобы устранить проблему, можно использовать *параметр типа*, ограниченный интерфейсом `Comparable<T>` :

[source, java]
----
public interface Comparable<T> {
    public int compareTo(T o);
}
----
В результате получится такой код:

[source, java]
----
public static <T extends Comparable<T>> int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e.compareTo(elem) > 0)
            ++count;
        return count;
}
----

== Type Inference (Вывод типа)

*Вывод типа* - это способность *компилятора Java* просматривать каждый *вызов метода* и соответствующее *объявление*, чтобы определить *тип аргумента* (или аргументов), которые делают вызов применимым. Алгоритм *вывода типа* определяет *типы аргументов* и, если они доступны, тип, которому *присваивается* или *возвращается* результат. Наконец, *алгоритм вывода* пытается найти *наиболее конкретный тип*, который работает со всеми аргументами.

В следующем примере *логический вывод типа* определяет, что второй аргумент, передаваемый методу `pick()`, имеет тип `Serializable`:

[source, java]
----
static <T> T pick(T a1, T a2) {
    return a2;
}
Serializable s = pick("d", new ArrayList<String>());
----

=== Вывод типа и обобщенные методы

*Вывод типа*, позволяет вызывать *обобщенный метод*, как обычный метод, без указания типа в угловых скобках.

=== Вывод типа и создание экземпляров обобщенных классов

Можно заменить *аргументы типа*, необходимые для вызова конструктора обобщенного класса, пустым набором параметров типа `<>`, если компилятор может вывести аргументы типа из контекста. Эта пара угловых скобок неофициально называется *diamond*.

Например, рассмотрим следующее объявление переменной:

[source, java]
----
Map<String, List<String>> myMap = new HashMap<String, List<String>>();
----

Можно заменить *параметризованный тип конструктора* на пустой набор параметров типа `<>`:

[source, java]
----
Map<String, List<String>> myMap = new HashMap<>();
----

Обратите внимание, что для использования *вывода типа* во время создания экземпляра обобщенного класса необходимо использовать *diamond*. В следующем примере *компилятор* генерирует *предупреждение о непроверенном преобразовании*, поскольку конструктор `HashMap()` относится к *сырому типу* `HashMap`, а не к типу `Map <String, List <String>>`:

[source, java]
----
Map<String, List<String>> myMap = new HashMap(); // unchecked conversion warning
----

=== Выведение типов и обобщенные конструкторы обобщенных и необобщенных классов

Конструкторы могут быть обобщенными (другими словами, объявлять свои собственные параметры обобщенного типа) как в обобщенных, так и в необобщенных  классах. Рассмотрим следующий пример:

[source, java]
----
class MyClass<X> {
    <T> MyClass(T t) {
        // ...//
    }
}
----

Рассмотрим следующий экземпляр класса `MyClass`:

[source, java]
----
new MyClass<Integer>("")
----

Этот оператор создает экземпляр параметризованного типа `MyClass <Integer>`; оператор явно указывает тип `Integer` для параметра обобщенного типа `X` обобщенного класса `MyClass <X>`. Конструктор для этого обобщенного класса содержит параметр обобщенного типа `T`. Компилятор определяет тип `String` для параметра обобщенного типа `T` конструктора этого обобщенного класса (поскольку фактическим параметром этого конструктора является объект `String`).

Компиляторы из выпусков предшествующих Java SE 7, могут определять фактические параметры типов обобщенных конструкторов, аналогично обобщенным методам. Однако компиляторы в Java SE 7 и более поздних версиях могут вывести фактические параметры типа создаваемого экземпляра универсального класса, если вы используете `<>`:

[source, java]
----
MyClass<Integer> myObject = new MyClass<>("");
----

В этом примере компилятор определяет тип `Integer` для параметра обобщенного типа `X` обобщенного класса `MyClass <X>`. Он определяет тип `String` для параметра формального типа `T` конструктора этого универсального класса.

=== Целевые типы (Target Types)

*Компилятор Java* использует *целевую типизацию* для вывода параметров типа вызова обобщенного метода. *Целевой тип выражения* - это тип данных, ожидаемый *компилятором Java* в зависимости от того, где находится выражение. Рассмотрим метод `Collections.emptyList()`, который объявлен следующим образом:

[source, java]
----
static <T> List<T> emptyList();
----

Рассмотрим следующий оператор присваивания:

[source, java]
----
List<String> listOne = Collections.emptyList();
----

Этот оператор ожидает экземпляр `List <String>`; этот тип данных является целевым типом. Поскольку метод `emptyList()` возвращает значение типа `List <T>`, *компилятор* делает вывод, что аргумент типа `T` должен быть значением `String`. Это работает как в *Java SE 7*, так и в *8*. В качестве альтернативы можно использовать подтверждающий тип и указать значение `T` следующим образом:

[source, java]
----
List<String> listOne = Collections.<String>emptyList();
----

Однако в данном контексте это необязательно. Однако это было необходимо в других контекстах. Рассмотрим следующий метод:

[source, java]
----
void processStringList(List<String> stringList) {
    // process stringList
}
----

Если есть необходимость вызвать метод `processStringList()` с пустым списком. В *Java SE 7* следующий код не компилируется:

[source, java]
----
processStringList(Collections.emptyList());
----

Компилятор *Java SE 7* выдает сообщение об ошибке, подобное следующему:

[source, shell script]
----
List<Object> cannot be converted to List<String>
----

Компилятору требуется значение для аргумента типа `T`, поэтому он начинается со значением `Object`. Следовательно, вызов `Collections.emptyList()` возвращает значение типа `List <Object>`, которое несовместимо с методом `processStringList()`. В *Java SE 7* необходимо указать значение значения аргумента типа следующим образом:

[source, java]
----
processStringList(Collections.<String>emptyList());
----

В *Java SE 8* в этом больше нет необходимости. Понятие целевого типа было расширено за счет включения *аргументов метода*, таких как аргумент метода `processStringList()`. В этом случае для `processStringList()` требуется аргумент типа `List <String>`. Метод `Collections.emptyList()` возвращает значение `List <T>`, поэтому, используя целевой тип `List <String>`, компилятор делает вывод, что аргумент типа `T` имеет значение `String`. Таким образом, в *Java SE 8* следующий код компилируется:

[source, java]
----
processStringList(Collections.emptyList());
----

== Generics, наследование и подтипы

Возможно присвоить объект одного типа объекту другого типа при условии, что типы совместимы. Например, можно типу `Object` присвоить `Integer`, поскольку `Object` является одним из суперклассов `Integer`:

[source, java]
----
Object someObject = new Object();
Integer someInteger = new Integer(10);
someObject = someInteger; // OK
----

В объектно-ориентированной терминологии это называется отношением «есть». Поскольку `Integer`  является разновидностью `Object`, присвоение разрешено. Но `Integer` также является разновидностью `Number`, поэтому следующий код также валиден:

[source, java]
----
public void someMethod(Number n) {
    /* ... */
}

someMethod(new Integer(10)); // OK
someMethod(new Double(10.1)); // OK
----

То же самое и с generics. Вы можете выполнить вызов обобщенного типа, передав `Number` в качестве *аргумента типа*, и любой последующий вызов `add()` будет разрешен, если аргумент совместим с `Number`:

[source, java]
----
Box<Number> box = new Box<Number>();
box.add(new Integer(10));   // OK
box.add(new Double(10.1));  // OK
----

Теперь рассмотрим следующий метод:

[source, java]
----
public void boxTest(Box<Number> n) { /* ... */ }
----

Какие аргументы он принимает? Посмотрев на его, видно, что он принимает единственный аргумент, тип которого - `Box <Number>`. Но что это значит? Можно ли передать в качестве аргумента `Box <Integer`> или `Box <Double>`, как и следовало ожидать? Ответ - «нет», потому что `Box <Integer>` и `Box <Double>` не являются подтипами `Box <Number>`.

image::generics-subtype-relationship.gif[связь обобщенных подтипов]

Это распространенное заблуждение, когда дело доходит до программирования с использованием generics, но это важная концепция, которую нужно изучить.

=== Обобщенные классы и подтипы

Можно создать подтипы общего класса или интерфейса, расширив или реализуя его. Отношения между параметрами типа одного класса или интерфейса и параметрами типа другого определяются ключевыми словами `extends` и `implements`.

Используя классы `Collections` в качестве примера, `ArrayList <E>` реализует `List <E>`, а `List <E>` расширяет `Collection <E>`. Итак, `ArrayList <String>` является подтипом `List <String>`, который является подтипом `Collection <String>`. Пока вы не изменяете *аргумент типа*, отношения подтипов между типами сохраняются.

image::generics-sample-hierarchy.gif[пример иерархии обобщенных подтипов]

Теперь представьте, что мы хотим определить наш собственный интерфейс списка, `PayloadList`, который связывает необязательное значение универсального типа `P` с каждым элементом. Его объявление может выглядеть так:

[source, java]
----
interface PayloadList<E,P> extends List<E> {
    void setPayload(int index, P val);
}
----

Следующие параметризации `PayloadList` являются подтипами `List <String>`:

[source, java]
----
PayloadList<String,String>
PayloadList<String,Integer>
PayloadList<String,Exception>
[source, java]
----

image::generics-payload-list-hierarchy.gif[иерархия playLoadList]

== WildCards

В обобщениях вопросительный знак (`?`), называемый *подстановочным знаком*, представляет *неизвестный тип*. *Подстановочный знак* можно использовать в различных ситуациях: как *тип параметра*, *поля* или *локальной переменной*; иногда как *возвращаемый тип* (хотя более конкретная практика программирования лучше). *Подстановочный знак* никогда не используется в качестве *аргумента типа* для вызова обобщенного метода, создания экземпляра обобщенного класса или супертипа.

=== Подстановочные знаки с ограничением сверху (Upper bounded WildCard)

Можно использовать *ограниченный сверху подстановочный знак*,  чтобы ослабить ограничения на переменную. Например, необходимо написать метод, который работает с `List <Integer>`, `List <Double>` и `List <Number>`; этого можно добиться, используя *ограниченный сверху подстановочный знак*.

Чтобы объявить подстановочный знак с ограничением сверху, используется подстановочный знак `?`. За которым следует ключевое слово `extends`, за которым следует его *верхняя граница*. Обратите внимание, что в этом контексте `extends` используется в общем смысле и обозначает либо `extend` (как в классах), либо `implements` (как в интерфейсах).

Чтобы написать метод, который работает со списками `Number` и подтипами `Number`, такими как `Integer`, `Double` и `Float`, необходимо указать `List <? extends Number>`. `List <Number>` является более строгим, чем `List <? extends Number>`, потому что первый соответствует только списку типа `Number`, тогда как последний соответствует списку типа `Number` или любому из его подклассов.

Рассмотрим следующий метод `process()`:

[source, java]
----
public static void process(List<? extends Foo> list){
    /* ... */
}
----

Верхний ограниченный подстановочный знак, `<? extends Foo>`, где `Foo` - это любой тип, соответствует `Foo` и любому подтипу `Foo`. Метод `process()` может обращаться к элементам списка как к типу `Foo`:

[source, java]
----
public static void process(List<? extends Foo> list) {
    for (Foo elem : list) {
        // ...
    }
}
----

В цикле _foreach_ переменная `elem` выполняет итерацию по каждому элементу в списке. Любой метод, определенный в классе `Foo`, теперь можно использовать через `elem`.

Метод `sumOfList()` возвращает сумму чисел в списке:

[source, java]
----
public static double sumOfList(List<? extends Number> list) {
    double s = 0.0;
    for (Number n : list)
        s += n.doubleValue();
    return s;
}
----

Следующий код, используя список объектов `Integer`, выводит `sum = 6.0`:

[source, java]
----
List<Integer> li = Arrays.asList(1, 2, 3);
System.out.println("sum = " + sumOfList(li));
----

Список значений `Double` может использовать тот же метод `sumOfList()`. Следующий код выводит `sum = 7.0`:

[source, java]
----
List<Double> ld = Arrays.asList(1.2, 2.3, 3.5);
System.out.println("sum = " + sumOfList(ld));
----

=== Неограниченные подстановочные знаки (Unbounded WildCard)

Тип *неограниченного подстановочного знака* указывается с помощью подстановочного знака `?`, Например `List <?>`. Это называется списком неизвестного типа. Есть два сценария, в которых неограниченный подстановочный знак является полезным подходом:

* Если вы пишете метод, который можно реализовать с использованием методов, предоставляемых в классе `Object`.
* Когда код использует методы в обобщенном классе, которые не зависят от параметра типа. Например, `List.size` или `List.clear`. Фактически, `Class <?>` Так часто используется, потому что большинство методов в `Class <T>` не зависят от `T`.

Рассмотрим следующий метод `printList()`:

[source, java]
----
public static void printList(List<Object> list) {
    for (Object elem : list) {
        System.out.println(elem + " ");
    }
    System.out.println();
}
----

Цель `printList()` - распечатать список любого типа, но он не достигает этой цели - он печатает только список экземпляров `Object`; он не может печатать `List <Integer>`, `List <String>`, `List <Double>` и так далее, потому что они не являются подтипами `List <Object>`. Чтобы написать общий метод `printList()`, используйте `List <?>`:

[source, java]
----
public static void printList(List<?> list) {
    for (Object elem: list) {
        System.out.print(elem + " ");
    }
    System.out.println();
}
----

Поскольку для любого конкретного типа `A` `List <A>` является подтипом `List <?>`, можно использовать `printList()` для печати списка любого типа:

[source, java]
----
List<Integer> li = Arrays.asList(1, 2, 3);
List<String> ls = Arrays.asList("one", "two", "three");
printList(li);
printList(ls);
----

=== Подстановочные знаки с ограничением снизу (Lower Bounded WildCard)

Аналогично *подстановочным знакам с ограничением сверху*  *ограниченный снизу подстановочный знак* ограничивает неизвестный тип определенным типом или супертипом этого типа.

*Ограниченный снизу подстановочный знак* выражается с помощью подстановочного символа `?`, за которым следует ключевое слово `super` и затем следует его нижняя граница: `<? super А>`.

Допустим, необходимо написать метод, который помещает объекты `Integer` в список. Для максимальной гибкости необходимо, чтобы метод работал с `List <Integer>`, `List <Number>` и `List <Object>` - всем, что может содержать целочисленные значения.

Чтобы написать метод, который работает со списками `Integer` и супертипами `Integer`, такими как `Integer`, `Number` и `Object`, необходимо указать `List <? super Integer>`. `List <Integer>` является более строгим, чем `List <? super Integer>`, потому что первый соответствует списку только типа `Integer`, тогда как последний соответствует списку любого типа, который является супертипом `Integer`.

Следующий код добавляет числа от 1 до 10 в конец списка:

[source, java]
----
public static void addNumbers(List<? super Integer> list) {
    for (int i = 1; i <= 10; i++) {
        list.add(i);
    }
}
----

=== Подстановочные знаки и подтипы

*Подстановочные знаки* можно использовать для создания связи между универсальными классами или интерфейсами.

Имея два обычных (неуниверсальных) класса:

[source, java]
----
class A { /* ... */ }
class B extends A { /* ... */ }
----

Можно написать такой код:

[source, java]
----
B b = new B();
A a = b;
----

Этот пример показывает, что наследование обычных классов следует правилу создания подтипов: класс `B` является подтипом класса `A`, если `B` расширяет `A`. Это не применяется к универсальным типам:

[source, java]
----
List<B> lb = new ArrayList<>();
List<A> la = lb;   // compile-time error
----

Учитывая, что `Integer` является подтипом `Number`, какова связь между `List <Integer>` и `List <Number>`?

image::generics-list-parant.gif[связь list из примера]

Хотя `Integer` является подтипом `Number`, `List <Integer>` не является подтипом `List <Number>` и, по сути, эти два типа не связаны. Общим родителем `List <Number>` и `List <Integer>` является `List <?>`.

Чтобы создать связь между этими классами, чтобы код мог обращаться к методам `Number` через элементы `List <Integer>`, используйте *подстановочный знак с ограничением сверху*:

[source, java]
----
List<? extends Integer> intList = new ArrayList<>();
List<? extends Number>  numList = intList;  // OK. List<? extends Integer> is a subtype of List<? extends Number>
----

Поскольку `Integer` является подтипом `Number`, а `numList` - списком объектов `Number`, теперь существует связь между `intList` (списком объектов `Integer`) и `numList`. На следующей диаграмме показаны отношения между несколькими классами `List`, объявленными с *ограниченными сверху и снизу подстановочными знаками*.

image::generics-wildcard-subtyping.gif[подтипы с ограничением сверху и снизу]

=== Захват подстановочных знаков и вспомогательные методы.

В некоторых случаях *компилятор* определяет тип *подстановочного знака*. Например, список может быть определен как `List <?>`, но при оценке выражения *компилятор* выводит *конкретный* тип из кода. Этот сценарий известен как *захват подстановочного знака*.

По большей части не стоит беспокоиться о захвате подстановочных знаков, за исключением случаев, когда генерируется *сообщение об ошибке*, содержащее фразу «*capture of*».

Пример `WildcardError` при компиляции вызывает ошибку захвата:

[source, java]
----
import java.util.List;

public class WildcardError {
    void foo(List<?> i) {
        i.set(0, i.get(0));
    }
}
----

В этом примере *компилятор* обрабатывает входной параметр `i` как имеющий тип `Object`. Когда метод `foo()` вызывает `List.set (int, E)`, компилятор не может подтвердить тип объекта, который вставляется в список, и возникает ошибка. Когда возникает этот тип ошибки, это обычно означает, что компилятор считает, что идет присваивание неправильного типа переменной. По этой причине в язык Java были добавлены generics - для обеспечения безопасности типов во время компиляции.

Пример `WildcardError` генерирует следующую ошибку при компиляции javac-реализацией *Oracle JDK 7*:

----
WildcardError.java:6: error: method set in interface List<E> cannot be applied to given types;
i.set(0, i.get(0));
^
required: int,CAP#1
found: int,Object
reason: actual argument Object cannot be converted to CAP#1 by method invocation conversion
where E is a type-variable:
E extends Object declared in interface List
where CAP#1 is a fresh type-variable:
CAP#1 extends Object from capture of ?
1 error
----

Обойти ошибку компилятора можно написав частный *вспомогательный метод*, который *захватывает* подстановочный знак. Пример, создадим вспомогательный метод `fooHelper()`, в `WildcardFixed`:

[source, java]
----
public class WildcardFixed {
    void foo(List<?> i) {
        fooHelper(i);
    }

    // Helper method created so that the wildcard can be captured
    // through type inference.
    private <T> void fooHelper(List<T> l) {
        l.set(0, l.get(0));
    }
}
----

Благодаря вспомогательному методу компилятор использует *выведение типов*, чтобы определить, что `T` является `CAP1`, переменной захвата, в вызове. Теперь пример успешно компилируется.

По соглашению вспомогательные методы обычно называются `originalMethodNameHelper()`.

=== Принцип PECS

*PECS* - *Producer Extends Consumer Super*.

Рассмотрим принцип *PECS* с точки зрения коллекции. Если необходимо только извлекать элементы из общей коллекции, это производитель, и необходимо использовать `extends`; если необходимо только добавлять элементы, это потребитель, и необходимо использовать `super`. Если необходимо осуществлять обе операции с одной коллекцией, не следует использовать `extends` или `super`.

Предположим, есть метод, который принимает в качестве параметра `Collection` объектов `Thing`, но необходимо сделать его более гибким:

Случай 1: Необходимо просмотреть коллекцию и произвести какие-то действия с каждым компонентом как с объектом `Thing`.

Тогда список является *producer*, поэтому необходимо использовать `Collection<? extends Thing>`.

Основная идея в том, что `Collection<? extends Thing>` может содержать любой подтип `Thing`, и, таким образом, каждый элемент будет вести себя как `Thing` при выполнении необходимой операции. На самом деле невозможно ничего добавить в `Collection<? extends Thing>`, потому что не возможно  знать во время выполнения, какой определенный подтип `Thing` содержится в коллекции.

Случай 2: Необходимо добавлять вещи в коллекцию.

Тогда список является *consumer*, поэтому необходимо использовать `Collection<? super Thing>`.

Причиной здесь является то, что в отличие от `Collection<? extends Thing>`, `Collection<? super Thing>` всегда может содержать `Thing` независимо от того, что является фактическим параметризованным типом.
